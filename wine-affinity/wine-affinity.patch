From 7846c206196a481cd35f7d2f4802e8132ff4d98a Mon Sep 17 00:00:00 2001
From: Herman Semenov <GermanAizek@yandex.ru>
Date: Sun, 28 Jul 2024 21:17:46 -0500
Subject: [PATCH 01/98] gdiplus: Fixed order of adding offset and result
 ternary operator.

---
 dlls/gdiplus/metafile.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/gdiplus/metafile.c b/dlls/gdiplus/metafile.c
index 19c4998d2d3..e529f237941 100644
--- a/dlls/gdiplus/metafile.c
+++ b/dlls/gdiplus/metafile.c
@@ -5532,7 +5532,7 @@ GpStatus METAFILE_DrawArc(GpMetafile *metafile, GpPen *pen, const GpRectF *rect,
     integer_rect = is_integer_rect(rect);
 
     stat = METAFILE_AllocateRecord(metafile, EmfPlusRecordTypeDrawArc, FIELD_OFFSET(EmfPlusDrawArc, RectData) +
-        integer_rect ? sizeof(record->RectData.rect) : sizeof(record->RectData.rectF),
+        (integer_rect ? sizeof(record->RectData.rect) : sizeof(record->RectData.rectF)),
         (void **)&record);
     if (stat != Ok)
         return stat;
-- 
2.48.1


From c63cc782abcbd87f4e8996381df35fcb1fc089d6 Mon Sep 17 00:00:00 2001
From: Eric Pouech <epouech@codeweavers.com>
Date: Mon, 29 Jul 2024 11:32:22 +0200
Subject: [PATCH 02/98] cmd: Fix test failures for SET /P command.

Signed-off-by: Eric Pouech <epouech@codeweavers.com>
---
 programs/cmd/builtins.c                  | 1 -
 programs/cmd/tests/test_builtins.cmd.exp | 2 +-
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/programs/cmd/builtins.c b/programs/cmd/builtins.c
index dcf5fb02a7e..b31669b246c 100644
--- a/programs/cmd/builtins.c
+++ b/programs/cmd/builtins.c
@@ -3185,7 +3185,6 @@ RETURN_CODE WCMD_setshow_env(WCHAR *s)
       /* Output the prompt */
       *p++ = '\0';
       if (*p) {
-        p = WCMD_strtrim(p);
         if (*p == L'"') {
           WCHAR* last = wcsrchr(p+1, L'"');
           p++;
diff --git a/programs/cmd/tests/test_builtins.cmd.exp b/programs/cmd/tests/test_builtins.cmd.exp
index ab5a92d28c4..8f4c18ee86b 100644
--- a/programs/cmd/tests/test_builtins.cmd.exp
+++ b/programs/cmd/tests/test_builtins.cmd.exp
@@ -709,7 +709,7 @@ I'm here!@space@
 prompt XbarX
 prompt YfooY
 'prompt' YfooY
-@todo_wine@promptYfooY
+promptYfooY
 ------------ Testing 'choice' ------------
 Example message [A,B,C]?A@or_broken@choice unavailable
 1@or_broken@9009
-- 
2.48.1


From 4c011a8d485552a5c140f7c700a4fa29ea8042f9 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 03/98] mshtml: Use dispex_next_id in NextProperty
 implementation.

---
 dlls/mshtml/dispex.c | 25 +++++--------------------
 1 file changed, 5 insertions(+), 20 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index d9d7b35526f..c34ff889b11 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -2391,31 +2391,16 @@ static HRESULT WINAPI JSDispatchHost_LookupProperty(IWineJSDispatchHost *iface,
 static HRESULT WINAPI JSDispatchHost_NextProperty(IWineJSDispatchHost *iface, DISPID id, struct property_info *desc)
 {
     DispatchEx *This = impl_from_IWineJSDispatchHost(iface);
-    func_info_t *func;
+    DISPID next;
     HRESULT hres;
 
     TRACE("%s (%p)->(%lx)\n", This->info->desc->name, This, id);
 
-    if(id == DISPID_STARTENUM) {
-        func = This->info->funcs;
-    }else {
-        hres = get_builtin_func(This->info, id, &func);
-        if(FAILED(hres))
-            return hres;
-        func++;
-    }
+    hres = dispex_next_id(This, id, &next);
+    if(hres != S_OK)
+        return hres;
 
-    while(func < This->info->funcs + This->info->func_cnt) {
-        if(func->func_disp_idx == -1) {
-            desc->id = func->id;
-            desc->name = func->name;
-            desc->flags = PROPF_WRITABLE | PROPF_CONFIGURABLE | PROPF_ENUMERABLE;
-            desc->func_iid = 0;
-            return S_OK;
-        }
-        func++;
-    }
-    return S_FALSE;
+    return get_host_property_descriptor(This, next, desc);
 }
 
 static HRESULT WINAPI JSDispatchHost_GetProperty(IWineJSDispatchHost *iface, DISPID id, LCID lcid, VARIANT *r,
-- 
2.48.1


From 88d6e02ba7b82556a04b2e5bd49abdf3c36799e7 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 04/98] jscript: Ensure that external property is still valid
 in jsdisp_next_prop.

---
 dlls/jscript/dispex.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/jscript/dispex.c b/dlls/jscript/dispex.c
index 3859f4c9a30..1b61ba531e9 100644
--- a/dlls/jscript/dispex.c
+++ b/dlls/jscript/dispex.c
@@ -3033,6 +3033,12 @@ HRESULT jsdisp_next_prop(jsdisp_t *obj, DISPID id, enum jsdisp_enum_type enum_ty
     }
 
     for(iter = &obj->props[idx]; iter < obj->props + obj->prop_cnt; iter++) {
+        if(iter->type == PROP_EXTERN) {
+            dispex_prop_t *prop;
+            hres = find_external_prop(obj, iter->name, FALSE, iter, &prop);
+            if(FAILED(hres) || prop != iter)
+                iter->type = PROP_DELETED;
+        }
         if(iter->type == PROP_DELETED)
             continue;
         if(enum_type != JSDISP_ENUM_ALL && iter->type == PROP_PROTREF)
-- 
2.48.1


From eb2729ab8da55275b373289dcfaecb0f87915a6b Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 05/98] mshtml: Use host object script bindings for storage
 objects.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on patch by Gabriel IvÄƒncescu.
---
 dlls/mshtml/htmlstorage.c         | 26 +++++++++++++-------------
 dlls/mshtml/tests/documentmode.js |  4 ++--
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/dlls/mshtml/htmlstorage.c b/dlls/mshtml/htmlstorage.c
index 9920a641957..05ef086a814 100644
--- a/dlls/mshtml/htmlstorage.c
+++ b/dlls/mshtml/htmlstorage.c
@@ -1117,17 +1117,6 @@ static HRESULT HTMLStorage_get_dispid(DispatchEx *dispex, const WCHAR *name, DWO
     return get_prop(This, name, dispid);
 }
 
-static HRESULT HTMLStorage_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLStorage *This = impl_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-
-    if(idx >= This->num_props)
-        return DISP_E_MEMBERNOTFOUND;
-
-    return (*name = SysAllocString(This->props[idx])) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLStorage_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -1278,16 +1267,27 @@ static HRESULT HTMLStorage_next_dispid(DispatchEx *dispex, DISPID id, DISPID *pi
     return S_OK;
 }
 
+static HRESULT HTMLStorage_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
+{
+    HTMLStorage *This = impl_from_DispatchEx(dispex);
+
+    desc->name = This->props[id - MSHTML_DISPID_CUSTOM_MIN];
+    desc->id = id;
+    desc->flags = PROPF_WRITABLE | PROPF_CONFIGURABLE | PROPF_ENUMERABLE;
+    desc->func_iid = 0;
+    return S_OK;
+}
+
 static const dispex_static_data_vtbl_t HTMLStorage_dispex_vtbl = {
     .query_interface  = HTMLStorage_query_interface,
     .destructor       = HTMLStorage_destructor,
     .traverse         = HTMLStorage_traverse,
     .unlink           = HTMLStorage_unlink,
     .get_dispid       = HTMLStorage_get_dispid,
-    .get_name         = HTMLStorage_get_name,
     .invoke           = HTMLStorage_invoke,
     .delete           = HTMLStorage_delete,
     .next_dispid      = HTMLStorage_next_dispid,
+    .get_prop_desc    = HTMLStorage_get_prop_desc,
 };
 
 static const tid_t HTMLStorage_iface_tids[] = {
@@ -1451,7 +1451,7 @@ HRESULT create_html_storage(HTMLInnerWindow *window, BOOL local, IHTMLStorage **
     storage->window = window;
     IHTMLWindow2_AddRef(&window->base.IHTMLWindow2_iface);
 
-    init_dispatch(&storage->dispex, &HTMLStorage_dispex, NULL,
+    init_dispatch(&storage->dispex, &HTMLStorage_dispex, window,
                   dispex_compat_mode(&window->event_target.dispex));
 
     *p = &storage->IHTMLStorage_iface;
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 5fada630a51..3fb0fbab1d9 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -300,7 +300,7 @@ sync_test("builtin_toString", function() {
     test("elements", document.getElementsByTagName("body"), "HTMLCollection", null, true);
     test("history", window.history, "History");
     test("implementation", document.implementation, "DOMImplementation");
-    if(localStorage) test("localStorage", localStorage, "Storage", null, true);
+    if(localStorage) test("localStorage", localStorage, "Storage");
     test("location", window.location, "Object", window.location.href, null, true);
     if(v >= 11 /* todo_wine */) test("mimeTypes", window.navigator.mimeTypes, v < 11 ? "MSMimeTypesCollection" : "MimeTypeArray");
     test("navigator", window.navigator, "Navigator");
@@ -309,7 +309,7 @@ sync_test("builtin_toString", function() {
     test("performanceTiming", window.performance.timing, "PerformanceTiming");
     if(v >= 11 /* todo_wine */) test("plugins", window.navigator.plugins, v < 11 ? "MSPluginsCollection" : "PluginArray");
     test("screen", window.screen, "Screen");
-    test("sessionStorage", window.sessionStorage, "Storage", null, true);
+    test("sessionStorage", window.sessionStorage, "Storage");
     test("style", document.body.style, "MSStyleCSSProperties", null, true);
     test("styleSheet", sheet, "CSSStyleSheet", null, true);
     test("styleSheetRule", sheet.rules[0], "CSSStyleRule", null, true);
-- 
2.48.1


From 81a2aa5ad7d682ad2a7c258bc919623cc200b168 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 06/98] mshtml: Use host object script bindings for frame
 elements.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on patch by Gabriel IvÄƒncescu.
---
 dlls/mshtml/htmlframe.c           | 16 +++++++---------
 dlls/mshtml/htmlwindow.c          | 22 ++++++++++++++++++++--
 dlls/mshtml/mshtml_private.h      |  4 ++++
 dlls/mshtml/tests/documentmode.js |  2 +-
 4 files changed, 32 insertions(+), 12 deletions(-)

diff --git a/dlls/mshtml/htmlframe.c b/dlls/mshtml/htmlframe.c
index 78890b43e05..b9f92bb5563 100644
--- a/dlls/mshtml/htmlframe.c
+++ b/dlls/mshtml/htmlframe.c
@@ -870,17 +870,15 @@ static HRESULT HTMLFrameElement_get_dispid(DispatchEx *dispex, const WCHAR *name
     return search_window_props(This->framebase.content_window->base.inner_window, name, grfdex, dispid);
 }
 
-static HRESULT HTMLFrameElement_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
+static HRESULT HTMLFrameElement_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
 {
     HTMLFrameElement *This = frame_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
 
-    if(!This->framebase.content_window ||
-       idx >= This->framebase.content_window->base.inner_window->global_prop_cnt)
+    if(!This->framebase.content_window)
         return DISP_E_MEMBERNOTFOUND;
 
-    *name = SysAllocString(This->framebase.content_window->base.inner_window->global_props[idx].name);
-    return *name ? S_OK : E_OUTOFMEMORY;
+    return HTMLWindow_get_prop_desc(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                                    id, desc);
 }
 
 static HRESULT HTMLFrameElement_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
@@ -893,8 +891,8 @@ static HRESULT HTMLFrameElement_invoke(DispatchEx *dispex, DISPID id, LCID lcid,
         return E_FAIL;
     }
 
-    return IWineJSDispatchHost_InvokeEx(&This->framebase.content_window->IWineJSDispatchHost_iface, id, lcid,
-            flags, params, res, ei, caller);
+    return HTMLWindow_invoke(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                             id, lcid, flags, params, res, ei, caller);
 }
 
 static const NodeImplVtbl HTMLFrameElementImplVtbl = {
@@ -915,7 +913,7 @@ static const event_target_vtbl_t HTMLFrameElement_event_target_vtbl = {
         .traverse       = HTMLFrameElement_traverse,
         .unlink         = HTMLFrameElement_unlink,
         .get_dispid     = HTMLFrameElement_get_dispid,
-        .get_name       = HTMLFrameElement_get_name,
+        .get_prop_desc  = HTMLFrameElement_get_prop_desc,
         .invoke         = HTMLFrameElement_invoke
     },
     HTMLELEMENT_EVENT_TARGET_VTBL_ENTRIES,
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index ceac07e4dd3..a7a6b0df383 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -3830,8 +3830,8 @@ static HRESULT HTMLWindow_find_dispid(DispatchEx *dispex, const WCHAR *name, DWO
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
+HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
+                          VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
     global_prop_t *prop;
@@ -3946,6 +3946,24 @@ static HRESULT HTMLWindow_next_dispid(DispatchEx *dispex, DISPID id, DISPID *pid
     return S_OK;
 }
 
+HRESULT HTMLWindow_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
+{
+    HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
+    global_prop_t *prop;
+
+    if(id - MSHTML_DISPID_CUSTOM_MIN >= This->global_prop_cnt)
+        return DISP_E_MEMBERNOTFOUND;
+
+    prop = &This->global_props[id - MSHTML_DISPID_CUSTOM_MIN];
+    desc->name = prop->name;
+    desc->id = id;
+    desc->flags = PROPF_WRITABLE | PROPF_CONFIGURABLE;
+    if(prop->type == GLOBAL_DISPEXVAR)
+        desc->flags |= PROPF_ENUMERABLE;
+    desc->func_iid = 0;
+    return S_OK;
+}
+
 static compat_mode_t HTMLWindow_get_compat_mode(DispatchEx *dispex, HTMLInnerWindow **script_global)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 04c51fb2503..9d84cbabe55 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1069,6 +1069,10 @@ void HTMLDocumentObj_Service_Init(HTMLDocumentObj*);
 void HTMLDocumentObj_OleCmd_Init(HTMLDocumentObj*);
 void TargetContainer_Init(HTMLDocumentObj*);
 
+HRESULT HTMLWindow_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc);
+HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
+                          VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller);
+
 void HTMLDocumentNode_Persist_Init(HTMLDocumentNode*);
 void HTMLDocumentNode_Service_Init(HTMLDocumentNode*);
 void HTMLDocumentNode_OleCmd_Init(HTMLDocumentNode*);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 3fb0fbab1d9..f608e573a34 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -150,7 +150,7 @@ sync_test("builtin_toString", function() {
         [ "font",            "Font", -1 ],
         [ "footer",          "" ],
         [ "form",            "Form" ],
-        [ "frame",           "Frame", -1 ],
+        [ "frame",           "Frame" ],
         [ "frameset",        "FrameSet", -1 ],
         [ "h1",              "Heading", -1 ],
         [ "h2",              "Heading", -1 ],
-- 
2.48.1


From b505bef4922a38739280a4c2a111acd3a132203d Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 07/98] mshtml: Use host object script bindings for iframe
 elements.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on patch by Gabriel IvÄƒncescu.
---
 dlls/mshtml/htmlframe.c           | 16 +++++++---------
 dlls/mshtml/tests/documentmode.js |  2 +-
 2 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/dlls/mshtml/htmlframe.c b/dlls/mshtml/htmlframe.c
index b9f92bb5563..8082af43be5 100644
--- a/dlls/mshtml/htmlframe.c
+++ b/dlls/mshtml/htmlframe.c
@@ -1305,17 +1305,15 @@ static HRESULT HTMLIFrame_get_dispid(DispatchEx *dispex, const WCHAR *name, DWOR
     return search_window_props(This->framebase.content_window->base.inner_window, name, grfdex, dispid);
 }
 
-static HRESULT HTMLIFrame_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
+static HRESULT HTMLIFrame_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
 {
     HTMLIFrame *This = iframe_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
 
-    if(!This->framebase.content_window ||
-       idx >= This->framebase.content_window->base.inner_window->global_prop_cnt)
+    if(!This->framebase.content_window)
         return DISP_E_MEMBERNOTFOUND;
 
-    *name = SysAllocString(This->framebase.content_window->base.inner_window->global_props[idx].name);
-    return *name ? S_OK : E_OUTOFMEMORY;
+    return HTMLWindow_get_prop_desc(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                                    id, desc);
 }
 
 static HRESULT HTMLIFrame_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
@@ -1328,8 +1326,8 @@ static HRESULT HTMLIFrame_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD
         return E_FAIL;
     }
 
-    return IWineJSDispatchHost_InvokeEx(&This->framebase.content_window->IWineJSDispatchHost_iface, id, lcid,
-            flags, params, res, ei, caller);
+    return HTMLWindow_invoke(&This->framebase.content_window->base.inner_window->event_target.dispex,
+                             id, lcid, flags, params, res, ei, caller);
 }
 
 static const NodeImplVtbl HTMLIFrameImplVtbl = {
@@ -1350,7 +1348,7 @@ static const event_target_vtbl_t HTMLIFrame_event_target_vtbl = {
         .traverse       = HTMLIFrame_traverse,
         .unlink         = HTMLIFrame_unlink,
         .get_dispid     = HTMLIFrame_get_dispid,
-        .get_name       = HTMLIFrame_get_name,
+        .get_prop_desc  = HTMLIFrame_get_prop_desc,
         .invoke         = HTMLIFrame_invoke
     },
     HTMLELEMENT_EVENT_TARGET_VTBL_ENTRIES,
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index f608e573a34..ff4fbdf306b 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -164,7 +164,7 @@ sync_test("builtin_toString", function() {
         [ "hr",              "HR", -1 ],
         [ "html",            "Html" ],
         [ "i",               "Phrase", -1 ],
-        [ "iframe",          "IFrame", -1 ],
+        [ "iframe",          "IFrame" ],
         [ "img",             "Image" ],
         [ "input",           "Input" ],
         [ "ins",             "Mod", -1 ],
-- 
2.48.1


From 9e581e26ac73abfb086e35538f04c23598e182ec Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 08/98] mshtml: Introduce get_outer_iface and use it instead of
 get_dispatch_this.

---
 dlls/mshtml/dispex.c         |  9 +++++++++
 dlls/mshtml/htmlevent.c      | 19 +++++++------------
 dlls/mshtml/htmlevent.h      |  1 -
 dlls/mshtml/htmlwindow.c     | 13 ++++++++++---
 dlls/mshtml/mshtml_private.h |  4 ++++
 5 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index c34ff889b11..61c86ec47df 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -745,6 +745,15 @@ HRESULT dispex_get_dynid(DispatchEx *This, const WCHAR *name, BOOL hidden, DISPI
     return S_OK;
 }
 
+IWineJSDispatchHost *dispex_outer_iface(DispatchEx *dispex)
+{
+    if(dispex->info->desc->vtbl->get_outer_iface)
+        return dispex->info->desc->vtbl->get_outer_iface(dispex);
+
+    IWineJSDispatchHost_AddRef(&dispex->IWineJSDispatchHost_iface);
+    return &dispex->IWineJSDispatchHost_iface;
+}
+
 static HRESULT dispex_value(DispatchEx *This, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
diff --git a/dlls/mshtml/htmlevent.c b/dlls/mshtml/htmlevent.c
index 6eed0916117..8125a3eebc8 100644
--- a/dlls/mshtml/htmlevent.c
+++ b/dlls/mshtml/htmlevent.c
@@ -321,12 +321,13 @@ static void remove_event_listener(EventTarget *event_target, const WCHAR *type_n
 
 static IEventTarget *get_event_target_iface(EventTarget *event_target)
 {
-    const event_target_vtbl_t *vtbl = dispex_get_vtbl(&event_target->dispex);
+    const dispex_static_data_vtbl_t *vtbl = dispex_get_vtbl(&event_target->dispex);
     IEventTarget *ret;
 
-    if(vtbl->get_dispatch_this) {
-        IDispatch *disp = vtbl->get_dispatch_this(&event_target->dispex);
-        IDispatch_QueryInterface(disp, &IID_IEventTarget, (void**)&ret);
+    if(vtbl->get_outer_iface) {
+        IWineJSDispatchHost *disp = vtbl->get_outer_iface(&event_target->dispex);
+        IWineJSDispatchHost_QueryInterface(disp, &IID_IEventTarget, (void**)&ret);
+        IWineJSDispatchHost_Release(disp);
     }else {
         ret = &event_target->IEventTarget_iface;
         IEventTarget_AddRef(ret);
@@ -4191,11 +4192,8 @@ static void call_event_handlers(EventTarget *event_target, DOMEvent *event, disp
             skip_onevent_listener = TRUE;
 
             V_VT(&arg) = VT_DISPATCH;
-            V_DISPATCH(&arg) = (IDispatch*)&event_target->dispex.IWineJSDispatchHost_iface;
+            V_DISPATCH(&arg) = (IDispatch*)dispex_outer_iface(&event_target->dispex);
             V_VT(&v) = VT_EMPTY;
-            if(vtbl->get_dispatch_this)
-                V_DISPATCH(&arg) = vtbl->get_dispatch_this(&event_target->dispex);
-            IDispatch_AddRef(V_DISPATCH(&arg));
 
             TRACE("%p %s >>>\n", event_target, debugstr_w(event->type));
             hres = call_disp_func(listener->function, &dp, &v);
@@ -4272,10 +4270,7 @@ static void call_event_handlers(EventTarget *event_target, DOMEvent *event, disp
             DISPPARAMS dp = {args, &named_arg, 2, 1};
 
             V_VT(args) = VT_DISPATCH;
-            V_DISPATCH(args) = (IDispatch*)&event_target->dispex.IWineJSDispatchHost_iface;
-            if(vtbl->get_dispatch_this)
-                V_DISPATCH(args) = vtbl->get_dispatch_this(&event_target->dispex);
-            IDispatch_AddRef(V_DISPATCH(args));
+            V_DISPATCH(args) = (IDispatch *)dispex_outer_iface(&event_target->dispex);
 
             V_VT(args+1) = VT_DISPATCH;
             V_DISPATCH(args+1) = dispatch_mode == DISPATCH_LEGACY
diff --git a/dlls/mshtml/htmlevent.h b/dlls/mshtml/htmlevent.h
index 324f39ea746..6dec8cf9a9a 100644
--- a/dlls/mshtml/htmlevent.h
+++ b/dlls/mshtml/htmlevent.h
@@ -127,7 +127,6 @@ void detach_nsevent(HTMLDocumentNode*,const WCHAR*);
 /* We extend dispex vtbl for EventTarget functions to avoid separated vtbl. */
 typedef struct {
     dispex_static_data_vtbl_t dispex_vtbl;
-    IDispatch *(*get_dispatch_this)(DispatchEx*);
     nsISupports *(*get_gecko_target)(DispatchEx*);
     void (*bind_event)(DispatchEx*,eventid_t);
     EventTarget *(*get_parent_event_target)(DispatchEx*);
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index a7a6b0df383..534a0bae9d2 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -3970,10 +3970,17 @@ static compat_mode_t HTMLWindow_get_compat_mode(DispatchEx *dispex, HTMLInnerWin
     return lock_document_mode(This->doc);
 }
 
-static IDispatch *HTMLWindow_get_dispatch_this(DispatchEx *dispex)
+static IWineJSDispatchHost *HTMLWindow_get_outer_iface(DispatchEx *dispex)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
-    return (IDispatch*)&This->base.outer_window->base.IHTMLWindow2_iface;
+    IWineJSDispatchHost *ret;
+
+    if(This->base.outer_window)
+        ret = &This->base.outer_window->IWineJSDispatchHost_iface;
+    else
+        ret = &This->event_target.dispex.IWineJSDispatchHost_iface;
+    IWineJSDispatchHost_AddRef(ret);
+    return ret;
 }
 
 static nsISupports *HTMLWindow_get_gecko_target(DispatchEx *dispex)
@@ -4152,8 +4159,8 @@ static const event_target_vtbl_t HTMLWindow_event_target_vtbl = {
         .invoke              = HTMLWindow_invoke,
         .next_dispid         = HTMLWindow_next_dispid,
         .get_compat_mode     = HTMLWindow_get_compat_mode,
+        .get_outer_iface     = HTMLWindow_get_outer_iface,
     },
-    .get_dispatch_this       = HTMLWindow_get_dispatch_this,
     .get_gecko_target        = HTMLWindow_get_gecko_target,
     .bind_event              = HTMLWindow_bind_event,
     .set_current_event       = HTMLWindow_set_current_event
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 9d84cbabe55..2952149d881 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -375,6 +375,9 @@ typedef struct {
     /* Called on the last release, when the refcount reaches 0 */
     void (*last_release)(DispatchEx*);
 
+    /* Called to get outer interface when it may be different than DispatchEx */
+    IWineJSDispatchHost *(*get_outer_iface)(DispatchEx*);
+
     /* Called when the object wants to handle DISPID_VALUE invocations */
     HRESULT (*value)(DispatchEx*,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
 
@@ -517,6 +520,7 @@ HRESULT dispex_get_id(DispatchEx *dispex, const WCHAR *name, DWORD flags, DISPID
 HRESULT dispex_next_id(DispatchEx *dispex, DISPID id, DISPID *ret);
 HRESULT dispex_prop_name(DispatchEx *dispex, DISPID id, BSTR *ret);
 HRESULT dispex_index_prop_desc(DispatchEx*,DISPID,struct property_info*);
+IWineJSDispatchHost *dispex_outer_iface(DispatchEx *dispex);
 
 typedef enum {
     DISPEXPROP_CUSTOM,
-- 
2.48.1


From 6674023843004b9134848e6c9abc2c99abf9f67e Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:20 +0200
Subject: [PATCH 09/98] jscript: Allow host objects to specify an outer
 interface.

---
 dlls/jscript/dispex.c    |  5 +++--
 dlls/jscript/jsdisp.idl  |  1 +
 dlls/mshtml/dispex.c     |  9 +++++++++
 dlls/mshtml/htmlwindow.c | 10 ++++++++++
 4 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/dlls/jscript/dispex.c b/dlls/jscript/dispex.c
index 1b61ba531e9..bd509a2e6f2 100644
--- a/dlls/jscript/dispex.c
+++ b/dlls/jscript/dispex.c
@@ -3515,6 +3515,7 @@ HRESULT init_host_object(script_ctx_t *ctx, IWineJSDispatchHost *host_iface, IWi
 
 IWineJSDispatchHost *get_host_dispatch(IDispatch *disp)
 {
+    IWineJSDispatchHost *ret;
     HostObject *host_obj;
     jsdisp_t *jsdisp;
 
@@ -3524,6 +3525,6 @@ IWineJSDispatchHost *get_host_dispatch(IDispatch *disp)
         return NULL;
 
     host_obj = HostObject_from_jsdisp(jsdisp);
-    IWineJSDispatchHost_AddRef(host_obj->host_iface);
-    return host_obj->host_iface;
+    IWineJSDispatchHost_GetOuterDispatch(host_obj->host_iface, &ret);
+    return ret;
 }
diff --git a/dlls/jscript/jsdisp.idl b/dlls/jscript/jsdisp.idl
index a2b8762b2c0..518edabba9d 100644
--- a/dlls/jscript/jsdisp.idl
+++ b/dlls/jscript/jsdisp.idl
@@ -64,6 +64,7 @@ interface IWineJSDispatchHost : IDispatchEx
     HRESULT DeleteProperty(DISPID id);
     HRESULT ConfigureProperty(DISPID id, UINT32 flags);
     HRESULT CallFunction(DISPID id, UINT32 iid, DISPPARAMS *dp, VARIANT *ret, EXCEPINFO *ei, IServiceProvider *caller);
+    HRESULT GetOuterDispatch(IWineJSDispatchHost **ret);
     HRESULT ToString(BSTR *str);
 }
 
diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 61c86ec47df..4a0e6a68403 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -2475,6 +2475,14 @@ static HRESULT WINAPI JSDispatchHost_CallFunction(IWineJSDispatchHost *iface, DI
     return call_builtin_function(This, func, dp, ret, ei, caller);
 }
 
+static HRESULT WINAPI JSDispatchHost_GetOuterDispatch(IWineJSDispatchHost *iface, IWineJSDispatchHost **ret)
+{
+    DispatchEx *This = impl_from_IWineJSDispatchHost(iface);
+
+    *ret = dispex_outer_iface(This);
+    return S_OK;
+}
+
 static HRESULT WINAPI JSDispatchHost_ToString(IWineJSDispatchHost *iface, BSTR *str)
 {
     DispatchEx *This = impl_from_IWineJSDispatchHost(iface);
@@ -2508,6 +2516,7 @@ static IWineJSDispatchHostVtbl JSDispatchHostVtbl = {
     JSDispatchHost_DeleteProperty,
     JSDispatchHost_ConfigureProperty,
     JSDispatchHost_CallFunction,
+    JSDispatchHost_GetOuterDispatch,
     JSDispatchHost_ToString,
 };
 
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index 534a0bae9d2..588d10a1e56 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -3508,6 +3508,15 @@ static HRESULT WINAPI WindowDispEx_CallFunction(IWineJSDispatchHost *iface, DISP
                                         id, iid, dp, ret, ei, caller);
 }
 
+static HRESULT WINAPI WindowDispEx_GetOuterDispatch(IWineJSDispatchHost *iface, IWineJSDispatchHost **ret)
+{
+    HTMLOuterWindow *This = impl_from_IWineJSDispatchHost(iface);
+
+    *ret = &This->IWineJSDispatchHost_iface;
+    IWineJSDispatchHost_AddRef(*ret);
+    return S_OK;
+}
+
 static HRESULT WINAPI WindowDispEx_ToString(IWineJSDispatchHost *iface, BSTR *str)
 {
     HTMLOuterWindow *This = impl_from_IWineJSDispatchHost(iface);
@@ -3539,6 +3548,7 @@ static const IWineJSDispatchHostVtbl WindowDispExVtbl = {
     WindowDispEx_DeleteProperty,
     WindowDispEx_ConfigureProperty,
     WindowDispEx_CallFunction,
+    WindowDispEx_GetOuterDispatch,
     WindowDispEx_ToString,
 };
 
-- 
2.48.1


From d9d816b6109da6d58369172edfb6266928e56c06 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:21 +0200
Subject: [PATCH 10/98] mshtml: Return E_UNEXPECTED for unknown ids in
 JSDispatchHost_CallFunction.

---
 dlls/mshtml/dispex.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 4a0e6a68403..57c9cf8bcf5 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -2468,9 +2468,7 @@ static HRESULT WINAPI JSDispatchHost_CallFunction(IWineJSDispatchHost *iface, DI
     TRACE("%s (%p)->(%lx %x %p %p %p %p)\n", This->info->desc->name, This, id, iid, dp, ret, ei, caller);
 
     hres = get_builtin_func(This->info, id, &func);
-    if(FAILED(hres))
-        return hres;
-    if(func->tid != iid || func->func_disp_idx < 0)
+    if(FAILED(hres) || func->tid != iid || func->func_disp_idx < 0)
         return E_UNEXPECTED;
     return call_builtin_function(This, func, dp, ret, ei, caller);
 }
-- 
2.48.1


From 121b7f106bed5660de2b982576975eba59bbcee3 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:21 +0200
Subject: [PATCH 11/98] mshtml: Use get_prop_descs for window object.

---
 dlls/mshtml/htmlwindow.c | 15 ++-------------
 1 file changed, 2 insertions(+), 13 deletions(-)

diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index 588d10a1e56..27d99f19ff6 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -3789,17 +3789,6 @@ static void HTMLWindow_last_release(DispatchEx *dispex)
     remove_target_tasks(This->task_magic);
 }
 
-static HRESULT HTMLWindow_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-
-    if(idx >= This->global_prop_cnt)
-        return DISP_E_MEMBERNOTFOUND;
-
-    return (*name = SysAllocString(This->global_props[idx].name)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLWindow_lookup_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *dispid)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
@@ -3905,7 +3894,7 @@ HRESULT HTMLWindow_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags,
 
             prop->type = GLOBAL_DISPEXVAR;
             prop->id = dispex_id;
-            return IWineJSDispatchHost_InvokeEx(&This->event_target.dispex.IWineJSDispatchHost_iface, dispex_id, 0, flags, params, res, ei, caller);
+            return dispex_prop_put(&This->event_target.dispex, dispex_id, 0, params->rgvarg, ei, caller);
         }
         default:
             FIXME("Not supported flags: %x\n", flags);
@@ -4163,11 +4152,11 @@ static const event_target_vtbl_t HTMLWindow_event_target_vtbl = {
         .traverse            = HTMLWindow_traverse,
         .unlink              = HTMLWindow_unlink,
         .last_release        = HTMLWindow_last_release,
-        .get_name            = HTMLWindow_get_name,
         .lookup_dispid       = HTMLWindow_lookup_dispid,
         .find_dispid         = HTMLWindow_find_dispid,
         .invoke              = HTMLWindow_invoke,
         .next_dispid         = HTMLWindow_next_dispid,
+        .get_prop_desc       = HTMLWindow_get_prop_desc,
         .get_compat_mode     = HTMLWindow_get_compat_mode,
         .get_outer_iface     = HTMLWindow_get_outer_iface,
     },
-- 
2.48.1


From e58cbec2dff9ad6a2890c780e29d3874286ce4c2 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:21 +0200
Subject: [PATCH 12/98] mshtml: Use host object script bindings for Window
 object.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on patch by Gabriel IvÄƒncescu.
---
 dlls/jscript/dispex.c             |  3 ++-
 dlls/mshtml/dispex.c              |  2 +-
 dlls/mshtml/htmlwindow.c          | 22 ++++++++---------
 dlls/mshtml/script.c              | 41 ++++++++++++++++++++-----------
 dlls/mshtml/tests/documentmode.js |  2 +-
 dlls/mshtml/tests/es5.js          |  2 --
 6 files changed, 41 insertions(+), 31 deletions(-)

diff --git a/dlls/jscript/dispex.c b/dlls/jscript/dispex.c
index bd509a2e6f2..95954866345 100644
--- a/dlls/jscript/dispex.c
+++ b/dlls/jscript/dispex.c
@@ -2362,7 +2362,8 @@ static HRESULT WINAPI WineJSDispatch_GetScriptGlobal(IWineJSDispatch *iface, IWi
    if(!(disp = lookup_global_host(This->ctx)))
        return E_NOINTERFACE;
 
-   return IDispatch_QueryInterface(disp, &IID_IWineJSDispatchHost, (void **)ret);
+   *ret = get_host_dispatch(disp);
+   return S_OK;
 }
 
 static IWineJSDispatchVtbl DispatchExVtbl = {
diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 57c9cf8bcf5..f26789f49e7 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -1730,7 +1730,7 @@ static dispex_data_t *ensure_dispex_info(DispatchEx *dispex, dispex_static_data_
     if(compat_mode >= COMPAT_MODE_IE9 && script_global) {
         if(!script_global->jscript)
             initialize_script_global(script_global);
-        if(script_global->jscript) {
+        if(script_global->jscript && !dispex->jsdisp) {
             hres = IWineJScript_InitHostObject(script_global->jscript, &dispex->IWineJSDispatchHost_iface,
                                                &dispex->jsdisp);
             if(FAILED(hres))
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index 27d99f19ff6..a428158f4ac 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -2151,17 +2151,14 @@ static IHTMLWindow2 *get_source_window(IServiceProvider *caller, compat_mode_t c
     if(hres != S_OK)
         cmdtarget = NULL;
 
-    if(compat_mode < COMPAT_MODE_IE9) {
-        /* Legacy modes query caller unconditionally, and use it instead, if it has a command target */
-        hres = IServiceProvider_QueryService(caller, &SID_GetCaller, &IID_IServiceProvider, (void**)&parent);
-        if(hres == S_OK && parent) {
-            hres = IServiceProvider_QueryService(parent, &IID_IActiveScriptSite, &IID_IOleCommandTarget, (void**)&parent_cmdtarget);
-            IServiceProvider_Release(parent);
-            if(hres == S_OK && parent_cmdtarget) {
-                if(cmdtarget)
-                    IOleCommandTarget_Release(cmdtarget);
-                cmdtarget = parent_cmdtarget;
-            }
+    hres = IServiceProvider_QueryService(caller, &SID_GetCaller, &IID_IServiceProvider, (void**)&parent);
+    if(hres == S_OK && parent) {
+        hres = IServiceProvider_QueryService(parent, &IID_IActiveScriptSite, &IID_IOleCommandTarget, (void**)&parent_cmdtarget);
+        IServiceProvider_Release(parent);
+        if(hres == S_OK && parent_cmdtarget) {
+            if(cmdtarget)
+                IOleCommandTarget_Release(cmdtarget);
+            cmdtarget = parent_cmdtarget;
         }
     }
 
@@ -3966,6 +3963,7 @@ HRESULT HTMLWindow_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_
 static compat_mode_t HTMLWindow_get_compat_mode(DispatchEx *dispex, HTMLInnerWindow **script_global)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
+    *script_global = This;
     return lock_document_mode(This->doc);
 }
 
@@ -4310,7 +4308,7 @@ static HRESULT create_inner_window(HTMLOuterWindow *outer_window, IMoniker *mon,
     window->base.outer_window = outer_window;
     window->base.inner_window = window;
 
-    EventTarget_Init(&window->event_target, &HTMLWindow_dispex, COMPAT_MODE_NONE);
+    init_event_target(&window->event_target, &HTMLWindow_dispex, NULL);
 
     window->task_magic = get_task_target_magic();
 
diff --git a/dlls/mshtml/script.c b/dlls/mshtml/script.c
index 295c8a0dc15..e985912c526 100644
--- a/dlls/mshtml/script.c
+++ b/dlls/mshtml/script.c
@@ -199,6 +199,27 @@ static BOOL init_script_engine(ScriptHost *script_host, IActiveScript *script)
         return FALSE;
     }
 
+    if(compat_mode >= COMPAT_MODE_IE9 && IsEqualGUID(&CLSID_JScript, &script_host->guid)) {
+        IWineJScript *jscript;
+        hres = IActiveScript_QueryInterface(script, &IID_IWineJScript, (void **)&jscript);
+        if(SUCCEEDED(hres)) {
+            assert(!script_host->window->jscript);
+            assert(!script_host->window->event_target.dispex.jsdisp);
+            script_host->window->jscript = jscript;
+
+            hres = IWineJScript_InitHostObject(jscript,
+                                               &script_host->window->event_target.dispex.IWineJSDispatchHost_iface,
+                                               &script_host->window->event_target.dispex.jsdisp);
+            if(FAILED(hres))
+                ERR("Could not initialize script global: %08lx\n", hres);
+
+            /* make sure that script global is fully initialized */
+            dispex_compat_mode(&script_host->window->event_target.dispex);
+        }else {
+            ERR("Could not get IWineJScript, don't use native jscript.dll\n");
+        }
+    }
+
     hres = IActiveScript_AddNamedItem(script, L"window",
             SCRIPTITEM_ISVISIBLE|SCRIPTITEM_ISSOURCE|SCRIPTITEM_GLOBALMEMBERS);
     if(SUCCEEDED(hres)) {
@@ -381,8 +402,10 @@ static HRESULT WINAPI ActiveScriptSite_GetItemInfo(IActiveScriptSite *iface, LPC
     if(!This->window || !This->window->base.outer_window)
         return E_FAIL;
 
-    /* FIXME: Return proxy object */
-    *ppiunkItem = (IUnknown*)&This->window->base.outer_window->base.IHTMLWindow2_iface;
+    if(dispex_compat_mode(&This->window->event_target.dispex) >= COMPAT_MODE_IE9)
+        *ppiunkItem = (IUnknown*)This->window->event_target.dispex.jsdisp;
+    else
+        *ppiunkItem = (IUnknown*)&This->window->base.outer_window->base.IHTMLWindow2_iface;
     IUnknown_AddRef(*ppiunkItem);
 
     return S_OK;
@@ -1390,19 +1413,9 @@ static ScriptHost *get_script_host(HTMLInnerWindow *window, const GUID *guid)
 
 void initialize_script_global(HTMLInnerWindow *script_global)
 {
-    ScriptHost *script_host;
-    HRESULT hres;
-
-    if(script_global->jscript)
+    if(!script_global->base.outer_window)
         return;
-
-    script_host = get_script_host(script_global, &CLSID_JScript);
-    if(!script_host)
-        return;
-
-    hres = IActiveScript_QueryInterface(script_host->script, &IID_IWineJScript, (void **)&script_global->jscript);
-    if(FAILED(hres))
-        ERR("Could not get IWineJScript, don't use native jscript.dll\n");
+    get_script_host(script_global, &CLSID_JScript);
 }
 
 static ScriptHost *get_elem_script_host(HTMLInnerWindow *window, HTMLScriptElement *script_elem)
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index ff4fbdf306b..ec670ec0756 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -317,7 +317,7 @@ sync_test("builtin_toString", function() {
     test("styleSheets", document.styleSheets, "StyleSheetList", null, true);
     test("textNode", document.createTextNode("testNode"), "Text", v < 9 ? "testNode" : null);
     test("textRange", txtRange, "TextRange");
-    test("window", window, "Window", "[object Window]", true);
+    test("window", window, "Window", "[object Window]");
     test("xmlHttpRequest", new XMLHttpRequest(), "XMLHttpRequest");
     if(v < 10) {
         test("namespaces", document.namespaces, "MSNamespaceInfoCollection");
diff --git a/dlls/mshtml/tests/es5.js b/dlls/mshtml/tests/es5.js
index ddffea263a6..0b22861fb34 100644
--- a/dlls/mshtml/tests/es5.js
+++ b/dlls/mshtml/tests/es5.js
@@ -1151,7 +1151,6 @@ sync_test("toString", function() {
     todo_wine.
     ok(tmp === "[object Arguments]", "toString.call(arguments) = " + tmp);
     tmp = Object.prototype.toString.call(this);
-    todo_wine.
     ok(tmp === "[object Window]", "toString.call(null) = " + tmp);
     tmp = Object.prototype.toString.call(null);
     ok(tmp === "[object Null]", "toString.call(null) = " + tmp);
@@ -2297,7 +2296,6 @@ sync_test("substituted this", function() {
     ok(r === "[object Undefined]", "detached scope Object.toString returned " + r);
 
     var r = (function() { this.f = Object.prototype.toString; return this.f(); })();
-    todo_wine.
     ok(r === "[object Window]", "Object.toString returned " + r);
 
     var r = (function() { var f = Object.prototype.toString; return f(); })();
-- 
2.48.1


From 3f23efd67f2fc8d1a0114f5d0f942b96c13df6cb Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jul 2024 16:55:21 +0200
Subject: [PATCH 13/98] mshtml: Introduce get_script_global and use it instead
 of get_compat_mode.

---
 dlls/mshtml/dispex.c         | 10 +++++-----
 dlls/mshtml/htmldoc.c        | 10 +++++-----
 dlls/mshtml/htmlwindow.c     |  8 ++++----
 dlls/mshtml/mshtml_private.h |  2 +-
 4 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index f26789f49e7..24cba0a9be7 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -1743,14 +1743,14 @@ static dispex_data_t *ensure_dispex_info(DispatchEx *dispex, dispex_static_data_
 
 static BOOL ensure_real_info(DispatchEx *dispex)
 {
-    HTMLInnerWindow *script_global = NULL;
-    compat_mode_t compat_mode;
+    HTMLInnerWindow *script_global;
 
     if(dispex->info != dispex->info->desc->delayed_init_info)
         return TRUE;
 
-    compat_mode = dispex->info->desc->vtbl->get_compat_mode(dispex, &script_global);
-    dispex->info = ensure_dispex_info(dispex, dispex->info->desc, compat_mode, script_global);
+    script_global = dispex->info->desc->vtbl->get_script_global(dispex);
+    dispex->info = ensure_dispex_info(dispex, dispex->info->desc,
+                                      script_global->doc->document_mode, script_global);
     return dispex->info != NULL;
 }
 
@@ -2652,7 +2652,7 @@ void init_dispatch(DispatchEx *dispex, dispex_static_data_t *data, HTMLInnerWind
     dispex->jsdisp = NULL;
     ccref_init(&dispex->ccref, 1);
 
-    if(data->vtbl->get_compat_mode) {
+    if(data->vtbl->get_script_global) {
         /* delayed init */
         if(!data->delayed_init_info) {
             EnterCriticalSection(&cs_dispex_static_data);
diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 0eb2bc3bcda..eaf3b352006 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -5535,14 +5535,14 @@ static HRESULT HTMLDocumentNode_get_prop_desc(DispatchEx *dispex, DISPID id, str
     return S_OK;
 }
 
-static compat_mode_t HTMLDocumentNode_get_compat_mode(DispatchEx *dispex, HTMLInnerWindow **script_global)
+static HTMLInnerWindow *HTMLDocumentNode_get_script_global(DispatchEx *dispex)
 {
     HTMLDocumentNode *This = impl_from_DispatchEx(dispex);
 
-    TRACE("(%p) returning %u\n", This, This->document_mode);
+    TRACE("(%p) using %u compat mode\n", This, This->document_mode);
 
-    *script_global = This->script_global;
-    return lock_document_mode(This);
+    lock_document_mode(This);
+    return This->script_global;
 }
 
 static nsISupports *HTMLDocumentNode_get_gecko_target(DispatchEx *dispex)
@@ -5639,7 +5639,7 @@ static const event_target_vtbl_t HTMLDocumentNode_event_target_vtbl = {
         .invoke              = HTMLDocumentNode_invoke,
         .disp_invoke         = HTMLDocumentNode_disp_invoke,
         .next_dispid         = HTMLDocumentNode_next_dispid,
-        .get_compat_mode     = HTMLDocumentNode_get_compat_mode,
+        .get_script_global   = HTMLDocumentNode_get_script_global,
     },
     .get_gecko_target        = HTMLDocumentNode_get_gecko_target,
     .bind_event              = HTMLDocumentNode_bind_event,
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index a428158f4ac..445be60fba8 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -3960,11 +3960,11 @@ HRESULT HTMLWindow_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_
     return S_OK;
 }
 
-static compat_mode_t HTMLWindow_get_compat_mode(DispatchEx *dispex, HTMLInnerWindow **script_global)
+static HTMLInnerWindow *HTMLWindow_get_script_global(DispatchEx *dispex)
 {
     HTMLInnerWindow *This = impl_from_DispatchEx(dispex);
-    *script_global = This;
-    return lock_document_mode(This->doc);
+    lock_document_mode(This->doc);
+    return This;
 }
 
 static IWineJSDispatchHost *HTMLWindow_get_outer_iface(DispatchEx *dispex)
@@ -4155,7 +4155,7 @@ static const event_target_vtbl_t HTMLWindow_event_target_vtbl = {
         .invoke              = HTMLWindow_invoke,
         .next_dispid         = HTMLWindow_next_dispid,
         .get_prop_desc       = HTMLWindow_get_prop_desc,
-        .get_compat_mode     = HTMLWindow_get_compat_mode,
+        .get_script_global   = HTMLWindow_get_script_global,
         .get_outer_iface     = HTMLWindow_get_outer_iface,
     },
     .get_gecko_target        = HTMLWindow_get_gecko_target,
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 2952149d881..35cb705d0a5 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -401,7 +401,7 @@ typedef struct {
     HRESULT (*disp_invoke)(DispatchEx*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
 
     /* Used by objects that want to delay their compat mode initialization until actually needed */
-    compat_mode_t (*get_compat_mode)(DispatchEx*,HTMLInnerWindow**);
+    HTMLInnerWindow *(*get_script_global)(DispatchEx*);
 
     /* Used by objects that want to populate some dynamic props on initialization */
     HRESULT (*populate_props)(DispatchEx*);
-- 
2.48.1


From c7fbc54f3ef5967f2742c4b40fa6175dcd6e4d66 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Mon, 29 Jul 2024 20:25:43 +0200
Subject: [PATCH 14/98] kernel32: Add SetFirmwareEnvironmentVariableA stub.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57012
---
 dlls/kernel32/kernel32.spec |  2 +-
 dlls/kernel32/process.c     | 10 ++++++++++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 179d49ba7cb..c7fe7d7724e 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1437,7 +1437,7 @@
 # @ stub SetFileShortNameW
 @ stdcall -import SetFileTime(long ptr ptr ptr)
 @ stdcall -import SetFileValidData(ptr int64)
-# @ stub SetFirmwareEnvironmentVariableA
+@ stdcall SetFirmwareEnvironmentVariableA(str str ptr long)
 @ stdcall SetFirmwareEnvironmentVariableW(wstr wstr ptr long)
 @ stdcall SetHandleContext(long long)
 @ stdcall SetHandleCount(long)
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index d56118a0fe3..2a4ddc68f02 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -738,6 +738,16 @@ DWORD WINAPI GetFirmwareEnvironmentVariableW(LPCWSTR name, LPCWSTR guid, PVOID b
     return 0;
 }
 
+/***********************************************************************
+ *           SetFirmwareEnvironmentVariableA     (KERNEL32.@)
+ */
+BOOL WINAPI SetFirmwareEnvironmentVariableA(const char *name, const char *guid, void *buffer, DWORD size)
+{
+    FIXME("stub: %s %s %p %lu\n", debugstr_a(name), debugstr_a(guid), buffer, size);
+    SetLastError(ERROR_INVALID_FUNCTION);
+    return FALSE;
+}
+
 /***********************************************************************
  *           SetFirmwareEnvironmentVariableW     (KERNEL32.@)
  */
-- 
2.48.1


From 5c395ff13850fbf2724ff1d0ebd3d53f192680bb Mon Sep 17 00:00:00 2001
From: Matteo Bruni <mbruni@codeweavers.com>
Date: Sat, 27 Jul 2024 02:34:37 +0200
Subject: [PATCH 15/98] d3dx9: Don't silently ignore
 d3dx_calculate_pixel_size() errors.

---
 dlls/d3dx9_36/surface.c       | 15 ++++++++++++---
 dlls/d3dx9_36/tests/surface.c | 15 ++++++++-------
 2 files changed, 20 insertions(+), 10 deletions(-)

diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index 344a491765e..b35a2726d23 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -484,7 +484,8 @@ static uint32_t d3dx_calculate_layer_pixels_size(D3DFORMAT format, uint32_t widt
     layer_size = 0;
     for (i = 0; i < mip_levels; ++i)
     {
-        d3dx_calculate_pixels_size(format, dims.width, dims.height, &row_pitch, &slice_pitch);
+        if (FAILED(d3dx_calculate_pixels_size(format, dims.width, dims.height, &row_pitch, &slice_pitch)))
+            return 0;
         layer_size += slice_pitch * dims.depth;
         d3dx_get_next_mip_level_size(&dims);
     }
@@ -500,7 +501,8 @@ static UINT calculate_dds_file_size(D3DFORMAT format, UINT width, UINT height, U
     for (i = 0; i < miplevels; i++)
     {
         UINT pitch, size = 0;
-        d3dx_calculate_pixels_size(format, width, height, &pitch, &size);
+        if (FAILED(d3dx_calculate_pixels_size(format, width, height, &pitch, &size)))
+            return 0;
         size *= depth;
         file_size += size;
         width = max(1, width / 2);
@@ -539,6 +541,8 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
 
     file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, 1, 1, 1);
+    if (!file_size)
+        return D3DERR_INVALIDCALL;
 
     hr = d3dx_calculate_pixels_size(src_desc.Format, src_desc.Width, src_desc.Height, &dst_pitch, &surface_size);
     if (FAILED(hr)) return hr;
@@ -588,6 +592,7 @@ static HRESULT d3dx_initialize_image_from_dds(const void *src_data, uint32_t src
 {
     const struct dds_header *header = src_data;
     uint32_t expected_src_data_size;
+    HRESULT hr;
 
     if (src_data_size < sizeof(*header) || header->pixel_format.size != sizeof(header->pixel_format))
         return D3DXERR_INVALIDDATA;
@@ -623,6 +628,8 @@ static HRESULT d3dx_initialize_image_from_dds(const void *src_data, uint32_t src
 
     image->layer_pitch = d3dx_calculate_layer_pixels_size(image->format, image->size.width, image->size.height,
             image->size.depth, image->mip_levels);
+    if (!image->layer_pitch)
+        return D3DXERR_INVALIDDATA;
     expected_src_data_size = (image->layer_pitch * image->layer_count) + sizeof(*header);
     if (src_data_size < expected_src_data_size)
     {
@@ -640,7 +647,9 @@ static HRESULT d3dx_initialize_image_from_dds(const void *src_data, uint32_t src
         initial_mip_levels = image->mip_levels;
         for (i = 0; i < starting_mip_level; i++)
         {
-            d3dx_calculate_pixels_size(image->format, image->size.width, image->size.height, &row_pitch, &slice_pitch);
+            hr = d3dx_calculate_pixels_size(image->format, image->size.width, image->size.height, &row_pitch, &slice_pitch);
+            if (FAILED(hr))
+                return hr;
 
             image->pixels += slice_pitch * image->size.depth;
             d3dx_get_next_mip_level_size(&image->size);
diff --git a/dlls/d3dx9_36/tests/surface.c b/dlls/d3dx9_36/tests/surface.c
index 1d60f9c46aa..e22799c5e16 100644
--- a/dlls/d3dx9_36/tests/surface.c
+++ b/dlls/d3dx9_36/tests/surface.c
@@ -433,6 +433,7 @@ static void test_dds_header_handling(void)
         dds->header.pixel_format = tests[i].pixel_format;
 
         hr = D3DXGetImageInfoFromFileInMemory(dds, file_size, &info);
+        todo_wine_if(i == 16)
         ok(hr == tests[i].expected.hr, "%d: D3DXGetImageInfoFromFileInMemory returned %#lx, expected %#lx\n",
                 i, hr, tests[i].expected.hr);
         if (SUCCEEDED(hr))
@@ -687,10 +688,10 @@ static void test_D3DXGetImageInfo(void)
     check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_DXT3, 0, 0, 0, 0, 0, D3DFMT_DXT3);
     check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_DXT4, 0, 0, 0, 0, 0, D3DFMT_DXT4);
     check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_DXT5, 0, 0, 0, 0, 0, D3DFMT_DXT5);
-    check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_R8G8_B8G8, 0, 0, 0, 0, 0, D3DFMT_R8G8_B8G8);
-    check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_G8R8_G8B8, 0, 0, 0, 0, 0, D3DFMT_G8R8_G8B8);
-    check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_UYVY, 0, 0, 0, 0, 0, D3DFMT_UYVY);
-    check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_YUY2, 0, 0, 0, 0, 0, D3DFMT_YUY2);
+    todo_wine check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_R8G8_B8G8, 0, 0, 0, 0, 0, D3DFMT_R8G8_B8G8);
+    todo_wine check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_G8R8_G8B8, 0, 0, 0, 0, 0, D3DFMT_G8R8_G8B8);
+    todo_wine check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_UYVY, 0, 0, 0, 0, 0, D3DFMT_UYVY);
+    todo_wine check_dds_pixel_format(DDS_PF_FOURCC, D3DFMT_YUY2, 0, 0, 0, 0, 0, D3DFMT_YUY2);
     check_dds_pixel_format(DDS_PF_RGB, 0, 16, 0xf800, 0x07e0, 0x001f, 0, D3DFMT_R5G6B5);
     check_dds_pixel_format(DDS_PF_RGB | DDS_PF_ALPHA, 0, 16, 0x7c00, 0x03e0, 0x001f, 0x8000, D3DFMT_A1R5G5B5);
     check_dds_pixel_format(DDS_PF_RGB | DDS_PF_ALPHA, 0, 16, 0x0f00, 0x00f0, 0x000f, 0xf000, D3DFMT_A4R4G4B4);
@@ -710,9 +711,9 @@ static void test_D3DXGetImageInfo(void)
     check_dds_pixel_format(DDS_PF_LUMINANCE, 0, 16, 0xffff, 0, 0, 0, D3DFMT_L16);
     check_dds_pixel_format(DDS_PF_LUMINANCE | DDS_PF_ALPHA, 0, 16, 0x00ff, 0, 0, 0xff00, D3DFMT_A8L8);
     check_dds_pixel_format(DDS_PF_LUMINANCE | DDS_PF_ALPHA, 0, 8, 0x0f, 0, 0, 0xf0, D3DFMT_A4L4);
-    check_dds_pixel_format(DDS_PF_BUMPDUDV, 0, 16, 0x00ff, 0xff00, 0, 0, D3DFMT_V8U8);
-    check_dds_pixel_format(DDS_PF_BUMPDUDV, 0, 32, 0x0000ffff, 0xffff0000, 0, 0, D3DFMT_V16U16);
-    check_dds_pixel_format(DDS_PF_BUMPLUMINANCE, 0, 32, 0x0000ff, 0x00ff00, 0xff0000, 0, D3DFMT_X8L8V8U8);
+    todo_wine check_dds_pixel_format(DDS_PF_BUMPDUDV, 0, 16, 0x00ff, 0xff00, 0, 0, D3DFMT_V8U8);
+    todo_wine check_dds_pixel_format(DDS_PF_BUMPDUDV, 0, 32, 0x0000ffff, 0xffff0000, 0, 0, D3DFMT_V16U16);
+    todo_wine check_dds_pixel_format(DDS_PF_BUMPLUMINANCE, 0, 32, 0x0000ff, 0x00ff00, 0xff0000, 0, D3DFMT_X8L8V8U8);
 
     test_dds_header_handling();
 
-- 
2.48.1


From b421bcec9c5e04cfa0a3c3810be76b103110ec72 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 11 Jul 2024 14:20:34 +0200
Subject: [PATCH 16/98] d3dx9/effect: Document one remaining header field.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/d3dx9_36/effect.c | 20 +++++---------------
 1 file changed, 5 insertions(+), 15 deletions(-)

diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index d84ad749f30..5a73da531ef 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -441,19 +441,6 @@ static inline uint32_t read_u32(const char **ptr)
     return u;
 }
 
-static void skip_u32_unknown(const char **ptr, unsigned int count)
-{
-    unsigned int i;
-    uint32_t u;
-
-    WARN("Skipping %u unknown DWORDs:\n", count);
-    for (i = 0; i < count; ++i)
-    {
-        u = read_u32(ptr);
-        WARN("\t0x%08x\n", u);
-    }
-}
-
 static inline D3DXHANDLE get_parameter_handle(struct d3dx_parameter *parameter)
 {
     return (D3DXHANDLE)parameter;
@@ -6292,7 +6279,7 @@ static BOOL param_set_top_level_param(void *top_level_param, struct d3dx_paramet
 static HRESULT d3dx_parse_effect(struct d3dx_effect *effect, const char *data, UINT data_size,
         uint32_t start, const char **skip_constants, unsigned int skip_constants_count)
 {
-    unsigned int string_count, resource_count, params_count;
+    unsigned int string_count, resource_count, params_count, shader_count;
     const char *ptr = data + start;
     unsigned int i;
     HRESULT hr;
@@ -6303,7 +6290,10 @@ static HRESULT d3dx_parse_effect(struct d3dx_effect *effect, const char *data, U
     effect->technique_count = read_u32(&ptr);
     TRACE("Technique count: %u.\n", effect->technique_count);
 
-    skip_u32_unknown(&ptr, 1);
+    /* This value appears to be equal to a number of shader variables, with each pass contributing
+       one additional slot. */
+    shader_count = read_u32(&ptr);
+    TRACE("Shader count: %u.\n", shader_count);
 
     effect->object_count = read_u32(&ptr);
     TRACE("Object count: %u.\n", effect->object_count);
-- 
2.48.1


From cab64ec829fce372dcd5a33db1fc98f3262e47e3 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Mon, 29 Jul 2024 17:59:11 +0300
Subject: [PATCH 17/98] sechost: Check both lpServiceName and lpServiceProc for
 NULL in StartServiceCtrlDispatcher().

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/sechost/service.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/sechost/service.c b/dlls/sechost/service.c
index 446031e4043..915b0b4ebe0 100644
--- a/dlls/sechost/service.c
+++ b/dlls/sechost/service.c
@@ -1910,7 +1910,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH StartServiceCtrlDispatcherA( const SERVICE_TABLE_E
         SetLastError( ERROR_SERVICE_ALREADY_RUNNING );
         return FALSE;
     }
-    while (servent[nb_services].lpServiceName) nb_services++;
+    while (servent[nb_services].lpServiceName && servent[nb_services].lpServiceProc)
+        nb_services++;
     if (!nb_services)
     {
         SetLastError( ERROR_INVALID_PARAMETER );
@@ -1948,7 +1949,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH StartServiceCtrlDispatcherW( const SERVICE_TABLE_E
         SetLastError( ERROR_SERVICE_ALREADY_RUNNING );
         return FALSE;
     }
-    while (servent[nb_services].lpServiceName) nb_services++;
+    while (servent[nb_services].lpServiceName && servent[nb_services].lpServiceProc)
+        nb_services++;
     if (!nb_services)
     {
         SetLastError( ERROR_INVALID_PARAMETER );
-- 
2.48.1


From f297e4e5d2980e0e490c2d438d30a318008533ef Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 18/98] mshtml: Use HTMLPluginContainer for DispatchEx
 functions in object element.

---
 dlls/mshtml/htmlobject.c | 35 +++--------------------------------
 dlls/mshtml/pluginhost.c | 28 +++++++++++++++++++++++++---
 dlls/mshtml/pluginhost.h |  7 +++++--
 3 files changed, 33 insertions(+), 37 deletions(-)

diff --git a/dlls/mshtml/htmlobject.c b/dlls/mshtml/htmlobject.c
index 7c9892ce999..8d47dc9306d 100644
--- a/dlls/mshtml/htmlobject.c
+++ b/dlls/mshtml/htmlobject.c
@@ -653,25 +653,6 @@ static void HTMLObjectElement_unlink(DispatchEx *dispex)
     unlink_ref(&This->nsobject);
 }
 
-static void HTMLObjectElement_destructor(DispatchEx *dispex)
-{
-    HTMLObjectElement *This = impl_from_DispatchEx(dispex);
-
-    if(This->plugin_container.plugin_host)
-        detach_plugin_host(This->plugin_container.plugin_host);
-
-    HTMLElement_destructor(&This->plugin_container.element.node.event_target.dispex);
-}
-
-static HRESULT HTMLObjectElement_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *dispid)
-{
-    HTMLObjectElement *This = impl_from_DispatchEx(dispex);
-
-    TRACE("(%p)->(%s %lx %p)\n", This, debugstr_w(name), grfdex, dispid);
-
-    return get_plugin_dispid(&This->plugin_container, name, dispid);
-}
-
 static HRESULT HTMLObjectElement_dispex_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
 {
     HTMLObjectElement *This = impl_from_DispatchEx(dispex);
@@ -681,16 +662,6 @@ static HRESULT HTMLObjectElement_dispex_get_name(DispatchEx *dispex, DISPID id,
     return E_NOTIMPL;
 }
 
-static HRESULT HTMLObjectElement_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
-{
-    HTMLObjectElement *This = impl_from_DispatchEx(dispex);
-
-    TRACE("(%p)->(%ld)\n", This, id);
-
-    return invoke_plugin_prop(&This->plugin_container, id, lcid, flags, params, res, ei);
-}
-
 static const NodeImplVtbl HTMLObjectElementImplVtbl = {
     .clsid                 = &CLSID_HTMLObjectElement,
     .cpc_entries           = HTMLElement_cpc,
@@ -703,12 +674,12 @@ static const event_target_vtbl_t HTMLObjectElement_event_target_vtbl = {
     {
         HTMLELEMENT_DISPEX_VTBL_ENTRIES,
         .query_interface= HTMLObjectElement_query_interface,
-        .destructor     = HTMLObjectElement_destructor,
+        .destructor     = HTMLPluginContainer_destructor,
         .traverse       = HTMLObjectElement_traverse,
         .unlink         = HTMLObjectElement_unlink,
-        .get_dispid     = HTMLObjectElement_get_dispid,
+        .get_dispid     = HTMLPluginContainer_get_dispid,
         .get_name       = HTMLObjectElement_dispex_get_name,
-        .invoke         = HTMLObjectElement_invoke
+        .invoke         = HTMLPluginContainer_invoke
     },
     HTMLELEMENT_EVENT_TARGET_VTBL_ENTRIES,
     .handle_event       = HTMLElement_handle_event
diff --git a/dlls/mshtml/pluginhost.c b/dlls/mshtml/pluginhost.c
index ce184315127..49e3c66a3e1 100644
--- a/dlls/mshtml/pluginhost.c
+++ b/dlls/mshtml/pluginhost.c
@@ -704,13 +704,32 @@ HRESULT get_plugin_disp(HTMLPluginContainer *plugin_container, IDispatch **ret)
     return S_OK;
 }
 
-HRESULT get_plugin_dispid(HTMLPluginContainer *plugin_container, const WCHAR *name, DISPID *ret)
+static inline HTMLPluginContainer *impl_from_DispatchEx(DispatchEx *iface)
 {
+    return CONTAINING_RECORD(iface, HTMLPluginContainer, element.node.event_target.dispex);
+}
+
+void HTMLPluginContainer_destructor(DispatchEx *dispex)
+{
+    HTMLPluginContainer *This = impl_from_DispatchEx(dispex);
+
+    if(This->plugin_host)
+        detach_plugin_host(This->plugin_host);
+    free(This->props);
+
+    HTMLElement_destructor(&This->element.node.event_target.dispex);
+}
+
+HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *ret)
+{
+    HTMLPluginContainer *plugin_container = impl_from_DispatchEx(dispex);
     IDispatch *disp;
     DISPID id;
     DWORD i;
     HRESULT hres;
 
+    TRACE("(%p)->(%s %lx %p)\n", plugin_container, debugstr_w(name), grfdex, ret);
+
     if(!plugin_container->plugin_host) {
         WARN("no plugin host\n");
         return DISP_E_UNKNOWNNAME;
@@ -755,11 +774,14 @@ HRESULT get_plugin_dispid(HTMLPluginContainer *plugin_container, const WCHAR *na
     return S_OK;
 }
 
-HRESULT invoke_plugin_prop(HTMLPluginContainer *plugin_container, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
-        VARIANT *res, EXCEPINFO *ei)
+HRESULT HTMLPluginContainer_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
+                                   VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
+    HTMLPluginContainer *plugin_container = impl_from_DispatchEx(dispex);
     PluginHost *host;
 
+    TRACE("(%p)->(%ld)\n", plugin_container, id);
+
     host = plugin_container->plugin_host;
     if(!host || !host->disp) {
         FIXME("Called with no disp\n");
diff --git a/dlls/mshtml/pluginhost.h b/dlls/mshtml/pluginhost.h
index bdef901bc80..f76aa5b10ca 100644
--- a/dlls/mshtml/pluginhost.h
+++ b/dlls/mshtml/pluginhost.h
@@ -67,7 +67,10 @@ void update_plugin_window(PluginHost*,HWND,const RECT*);
 void detach_plugin_host(PluginHost*);
 
 HRESULT get_plugin_disp(HTMLPluginContainer*,IDispatch**);
-HRESULT get_plugin_dispid(HTMLPluginContainer*,const WCHAR*,DISPID*);
-HRESULT invoke_plugin_prop(HTMLPluginContainer*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*);
 void notif_container_change(HTMLPluginContainer*,DISPID);
 void bind_activex_event(HTMLDocumentNode*,HTMLPluginContainer*,WCHAR*,IDispatch*);
+
+void HTMLPluginContainer_destructor(DispatchEx *dispex);
+HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *dispid);
+HRESULT HTMLPluginContainer_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
+                                   VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller);
-- 
2.48.1


From 33831494dfc72259cdc8ad397c473c716e2d328f Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 19/98] mshtml: Store property name in HTMLPluginContainer.

---
 dlls/mshtml/pluginhost.c | 25 ++++++++++++++++++-------
 dlls/mshtml/pluginhost.h |  8 +++++++-
 2 files changed, 25 insertions(+), 8 deletions(-)

diff --git a/dlls/mshtml/pluginhost.c b/dlls/mshtml/pluginhost.c
index 49e3c66a3e1..bbf93c2b713 100644
--- a/dlls/mshtml/pluginhost.c
+++ b/dlls/mshtml/pluginhost.c
@@ -712,9 +712,13 @@ static inline HTMLPluginContainer *impl_from_DispatchEx(DispatchEx *iface)
 void HTMLPluginContainer_destructor(DispatchEx *dispex)
 {
     HTMLPluginContainer *This = impl_from_DispatchEx(dispex);
+    unsigned int i;
 
     if(This->plugin_host)
         detach_plugin_host(This->plugin_host);
+
+    for(i = 0; i < This->props_len; i++)
+        free(This->props[i]);
     free(This->props);
 
     HTMLElement_destructor(&This->element.node.event_target.dispex);
@@ -723,9 +727,10 @@ void HTMLPluginContainer_destructor(DispatchEx *dispex)
 HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *ret)
 {
     HTMLPluginContainer *plugin_container = impl_from_DispatchEx(dispex);
+    struct plugin_prop *prop;
     IDispatch *disp;
     DISPID id;
-    DWORD i;
+    DWORD i, len;
     HRESULT hres;
 
     TRACE("(%p)->(%s %lx %p)\n", plugin_container, debugstr_w(name), grfdex, ret);
@@ -746,21 +751,21 @@ HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DW
     }
 
     for(i=0; i < plugin_container->props_len; i++) {
-        if(id == plugin_container->props[i]) {
+        if(id == plugin_container->props[i]->id) {
             *ret = MSHTML_DISPID_CUSTOM_MIN+i;
             return S_OK;
         }
     }
 
     if(!plugin_container->props) {
-        plugin_container->props = malloc(8 * sizeof(DISPID));
+        plugin_container->props = malloc(8 * sizeof(*plugin_container->props));
         if(!plugin_container->props)
             return E_OUTOFMEMORY;
         plugin_container->props_size = 8;
     }else if(plugin_container->props_len == plugin_container->props_size) {
-        DISPID *new_props;
+        struct plugin_prop **new_props;
 
-        new_props = realloc(plugin_container->props, plugin_container->props_size * 2 * sizeof(DISPID));
+        new_props = realloc(plugin_container->props, plugin_container->props_size * 2 * sizeof(*new_props));
         if(!new_props)
             return E_OUTOFMEMORY;
 
@@ -768,7 +773,13 @@ HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DW
         plugin_container->props_size *= 2;
     }
 
-    plugin_container->props[plugin_container->props_len] = id;
+    len = wcslen(name);
+    if(!(prop = malloc(FIELD_OFFSET(struct plugin_prop, name[len + 1]))))
+        return E_OUTOFMEMORY;
+
+    prop->id = id;
+    wcscpy(prop->name, name);
+    plugin_container->props[plugin_container->props_len] = prop;
     *ret = MSHTML_DISPID_CUSTOM_MIN+plugin_container->props_len;
     plugin_container->props_len++;
     return S_OK;
@@ -798,7 +809,7 @@ HRESULT HTMLPluginContainer_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WOR
         return E_FAIL;
     }
 
-    return IDispatch_Invoke(host->disp, plugin_container->props[id-MSHTML_DISPID_CUSTOM_MIN], &IID_NULL,
+    return IDispatch_Invoke(host->disp, plugin_container->props[id-MSHTML_DISPID_CUSTOM_MIN]->id, &IID_NULL,
             lcid, flags, params, res, ei, NULL);
 }
 
diff --git a/dlls/mshtml/pluginhost.h b/dlls/mshtml/pluginhost.h
index f76aa5b10ca..afbbc40e657 100644
--- a/dlls/mshtml/pluginhost.h
+++ b/dlls/mshtml/pluginhost.h
@@ -48,12 +48,18 @@ typedef struct {
     HTMLPluginContainer *element;
 } PluginHost;
 
+struct plugin_prop
+{
+    DISPID id;
+    WCHAR name[1];
+};
+
 struct HTMLPluginContainer {
     HTMLElement element;
 
     PluginHost *plugin_host;
 
-    DISPID *props;
+    struct plugin_prop **props;
     DWORD props_size;
     DWORD props_len;
 };
-- 
2.48.1


From 71a57dd6ee0b6ab9843ca8a29a262dd81773a2a5 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 20/98] mshtml: Use host object script bindings for object
 elements.

---
 dlls/mshtml/htmlobject.c          | 11 +----------
 dlls/mshtml/pluginhost.c          | 26 ++++++++++++++++++++++++++
 dlls/mshtml/pluginhost.h          |  1 +
 dlls/mshtml/tests/documentmode.js |  2 +-
 4 files changed, 29 insertions(+), 11 deletions(-)

diff --git a/dlls/mshtml/htmlobject.c b/dlls/mshtml/htmlobject.c
index 8d47dc9306d..b75dea24272 100644
--- a/dlls/mshtml/htmlobject.c
+++ b/dlls/mshtml/htmlobject.c
@@ -653,15 +653,6 @@ static void HTMLObjectElement_unlink(DispatchEx *dispex)
     unlink_ref(&This->nsobject);
 }
 
-static HRESULT HTMLObjectElement_dispex_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLObjectElement *This = impl_from_DispatchEx(dispex);
-
-    FIXME("(%p)->(%lx %p)\n", This, id, name);
-
-    return E_NOTIMPL;
-}
-
 static const NodeImplVtbl HTMLObjectElementImplVtbl = {
     .clsid                 = &CLSID_HTMLObjectElement,
     .cpc_entries           = HTMLElement_cpc,
@@ -678,7 +669,7 @@ static const event_target_vtbl_t HTMLObjectElement_event_target_vtbl = {
         .traverse       = HTMLObjectElement_traverse,
         .unlink         = HTMLObjectElement_unlink,
         .get_dispid     = HTMLPluginContainer_get_dispid,
-        .get_name       = HTMLObjectElement_dispex_get_name,
+        .get_prop_desc  = HTMLPluginContainer_get_prop_desc,
         .invoke         = HTMLPluginContainer_invoke
     },
     HTMLELEMENT_EVENT_TARGET_VTBL_ENTRIES,
diff --git a/dlls/mshtml/pluginhost.c b/dlls/mshtml/pluginhost.c
index bbf93c2b713..5479e25b0b8 100644
--- a/dlls/mshtml/pluginhost.c
+++ b/dlls/mshtml/pluginhost.c
@@ -813,6 +813,32 @@ HRESULT HTMLPluginContainer_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WOR
             lcid, flags, params, res, ei, NULL);
 }
 
+HRESULT HTMLPluginContainer_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
+{
+    HTMLPluginContainer *plugin_container = impl_from_DispatchEx(dispex);
+    PluginHost *host;
+
+    if(id >= MSHTML_DISPID_CUSTOM_MIN + plugin_container->props_len)
+        return DISP_E_MEMBERNOTFOUND;
+
+    host = plugin_container->plugin_host;
+    if(!host || !host->disp) {
+        WARN("Called with no disp\n");
+        return E_UNEXPECTED;
+    }
+
+    if(!check_script_safety(host)) {
+        FIXME("Insecure object\n");
+        return E_FAIL;
+    }
+
+    desc->id = id;
+    desc->flags = 0;
+    desc->name = plugin_container->props[id - MSHTML_DISPID_CUSTOM_MIN]->name;
+    desc->func_iid = 0;
+    return S_OK;
+}
+
 typedef struct {
     DISPID id;
     IDispatch *disp;
diff --git a/dlls/mshtml/pluginhost.h b/dlls/mshtml/pluginhost.h
index afbbc40e657..96490f8652e 100644
--- a/dlls/mshtml/pluginhost.h
+++ b/dlls/mshtml/pluginhost.h
@@ -80,3 +80,4 @@ void HTMLPluginContainer_destructor(DispatchEx *dispex);
 HRESULT HTMLPluginContainer_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD grfdex, DISPID *dispid);
 HRESULT HTMLPluginContainer_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
                                    VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller);
+HRESULT HTMLPluginContainer_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index ec670ec0756..0a9be1204e4 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -181,7 +181,7 @@ sync_test("builtin_toString", function() {
         [ "nav",             "" ],
         [ "noframes",        "" ],
         [ "noscript",        "" ],
-        [ "object",          "Object", -1 ],
+        [ "object",          "Object" ],
         [ "ol",              "OList", -1 ],
         [ "optgroup",        "OptGroup", -1 ],
         [ "option",          "Option" ],
-- 
2.48.1


From 4094957f590a6a52c6f0a758d4d8de76401d70d5 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 21/98] mshtml: Use host object script bindings for select
 elements.

---
 dlls/mshtml/htmlevent.c           |  7 -------
 dlls/mshtml/htmlnode.c            |  6 +-----
 dlls/mshtml/htmlselect.c          | 15 +--------------
 dlls/mshtml/mshtml_private.h      |  1 -
 dlls/mshtml/tests/documentmode.js |  2 +-
 5 files changed, 3 insertions(+), 28 deletions(-)

diff --git a/dlls/mshtml/htmlevent.c b/dlls/mshtml/htmlevent.c
index 8125a3eebc8..ba30eb41f53 100644
--- a/dlls/mshtml/htmlevent.c
+++ b/dlls/mshtml/htmlevent.c
@@ -5140,13 +5140,6 @@ static int event_id_cmp(const void *key, const struct wine_rb_entry *entry)
     return wcscmp(key, WINE_RB_ENTRY_VALUE(entry, listener_container_t, entry)->type);
 }
 
-void EventTarget_Init(EventTarget *event_target, dispex_static_data_t *dispex_data, compat_mode_t compat_mode)
-{
-    init_dispatch(&event_target->dispex, dispex_data, NULL, compat_mode);
-    event_target->IEventTarget_iface.lpVtbl = &EventTargetVtbl;
-    wine_rb_init(&event_target->handler_map, event_id_cmp);
-}
-
 void init_event_target(EventTarget *event_target, dispex_static_data_t *dispex_data, HTMLInnerWindow *script_global)
 {
     compat_mode_t compat_mode = script_global && script_global->doc ? script_global->doc->document_mode : COMPAT_MODE_NONE;
diff --git a/dlls/mshtml/htmlnode.c b/dlls/mshtml/htmlnode.c
index f752d2595d0..3123e9dd72e 100644
--- a/dlls/mshtml/htmlnode.c
+++ b/dlls/mshtml/htmlnode.c
@@ -1288,11 +1288,7 @@ void HTMLDOMNode_Init(HTMLDocumentNode *doc, HTMLDOMNode *node, nsIDOMNode *nsno
     node->IHTMLDOMNode2_iface.lpVtbl = &HTMLDOMNode2Vtbl;
     node->IHTMLDOMNode3_iface.lpVtbl = &HTMLDOMNode3Vtbl;
 
-    /* FIXME: We can't use new bindings for nodes with custom properties yet */
-    if(dispex_data->vtbl->get_name)
-        EventTarget_Init(&node->event_target, dispex_data, doc->document_mode);
-    else
-        init_event_target(&node->event_target, dispex_data, doc->script_global);
+    init_event_target(&node->event_target, dispex_data, doc->script_global);
 
     if(&doc->node != node)
         IHTMLDOMNode_AddRef(&doc->node.IHTMLDOMNode_iface);
diff --git a/dlls/mshtml/htmlselect.c b/dlls/mshtml/htmlselect.c
index 8cfbbe58c45..4fb0b05f85f 100644
--- a/dlls/mshtml/htmlselect.c
+++ b/dlls/mshtml/htmlselect.c
@@ -1234,19 +1234,6 @@ static HRESULT HTMLSelectElement_get_dispid(DispatchEx *dispex, const WCHAR *nam
     return S_OK;
 }
 
-static HRESULT HTMLSelectElement_dispex_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    DWORD idx = id - DISPID_OPTIONCOL_0;
-    WCHAR buf[11];
-    UINT len;
-
-    if(idx > MSHTML_CUSTOM_DISPID_CNT)
-        return DISP_E_MEMBERNOTFOUND;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLSelectElement_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -1297,7 +1284,7 @@ static const event_target_vtbl_t HTMLSelectElement_event_target_vtbl = {
         .traverse       = HTMLSelectElement_traverse,
         .unlink         = HTMLSelectElement_unlink,
         .get_dispid     = HTMLSelectElement_get_dispid,
-        .get_name       = HTMLSelectElement_dispex_get_name,
+        .get_prop_desc  = dispex_index_prop_desc,
         .invoke         = HTMLSelectElement_invoke
     },
     HTMLELEMENT_EVENT_TARGET_VTBL_ENTRIES,
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 35cb705d0a5..d48ba2f32ac 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1263,7 +1263,6 @@ HRESULT create_svg_element(HTMLDocumentNode*,nsIDOMSVGElement*,const WCHAR*,HTML
 void HTMLDOMNode_Init(HTMLDocumentNode*,HTMLDOMNode*,nsIDOMNode*,dispex_static_data_t*);
 void HTMLElement_Init(HTMLElement*,HTMLDocumentNode*,nsIDOMElement*,dispex_static_data_t*);
 
-void EventTarget_Init(EventTarget*,dispex_static_data_t*,compat_mode_t);
 void init_event_target(EventTarget*,dispex_static_data_t*,HTMLInnerWindow*);
 void *EventTarget_query_interface(EventTarget*,REFIID);
 void EventTarget_init_dispex_info(dispex_data_t*,compat_mode_t);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 0a9be1204e4..6be48816645 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -199,7 +199,7 @@ sync_test("builtin_toString", function() {
         [ "samp",            "Phrase", -1 ],
         [ "script",          "Script" ],
         [ "section",         "" ],
-        [ "select",          "Select", -1 ],
+        [ "select",          "Select" ],
         [ "small",           "Phrase", -1 ],
         [ "source",          "Source", -1 ],
         [ "span",            "Span", -1 ],
-- 
2.48.1


From 82ba225d97884513a6fefb48197e4620d64e248f Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 22/98] mshtml: Use host object script bindings for HTMLRect.

---
 dlls/mshtml/htmlelem.c            | 10 +++++-----
 dlls/mshtml/tests/documentmode.js |  2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 7fea9065659..4939e11ac2a 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -769,7 +769,7 @@ static dispex_static_data_t HTMLRect_dispex = {
     HTMLRect_init_dispex_info
 };
 
-static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_mode, IHTMLRect **ret)
+static HRESULT create_html_rect(nsIDOMClientRect *nsrect, DispatchEx *owner, IHTMLRect **ret)
 {
     HTMLRect *rect;
 
@@ -780,7 +780,7 @@ static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_m
     rect->IHTMLRect_iface.lpVtbl = &HTMLRectVtbl;
     rect->IHTMLRect2_iface.lpVtbl = &HTMLRect2Vtbl;
 
-    init_dispatch(&rect->dispex, &HTMLRect_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&rect->dispex, &HTMLRect_dispex, owner);
 
     nsIDOMClientRect_AddRef(nsrect);
     rect->nsrect = nsrect;
@@ -995,7 +995,7 @@ static HRESULT WINAPI HTMLRectCollection_item(IHTMLRectCollection *iface, VARIAN
         return S_OK;
     }
 
-    hres = create_html_rect(nsrect, dispex_compat_mode(&This->dispex), &rect);
+    hres = create_html_rect(nsrect, &This->dispex, &rect);
     nsIDOMClientRect_Release(nsrect);
     if(FAILED(hres))
         return hres;
@@ -1093,7 +1093,7 @@ static HRESULT HTMLRectCollection_invoke(DispatchEx *dispex, DISPID id, LCID lci
             return DISP_E_MEMBERNOTFOUND;
         }
 
-        hres = create_html_rect(rect, dispex_compat_mode(&This->dispex), &html_rect);
+        hres = create_html_rect(rect, &This->dispex, &html_rect);
         nsIDOMClientRect_Release(rect);
         if(FAILED(hres))
             return hres;
@@ -3065,7 +3065,7 @@ static HRESULT WINAPI HTMLElement2_getBoundingClientRect(IHTMLElement2 *iface, I
         return E_FAIL;
     }
 
-    hres = create_html_rect(nsrect, dispex_compat_mode(&This->node.event_target.dispex), pRect);
+    hres = create_html_rect(nsrect, &This->node.event_target.dispex, pRect);
 
     nsIDOMClientRect_Release(nsrect);
     return hres;
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 6be48816645..f6dafd8e300 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -293,7 +293,7 @@ sync_test("builtin_toString", function() {
     test("attribute", document.createAttribute("class"), "Attr");
     if(false /* todo_wine */) test("attributes", e.attributes, "NamedNodeMap");
     test("childNodes", document.body.childNodes, "NodeList", null, true);
-    if(clientRects) test("clientRect", clientRects[0], "ClientRect", null, true);
+    if(clientRects) test("clientRect", clientRects[0], "ClientRect");
     if(clientRects) test("clientRects", clientRects, "ClientRectList");
     if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties", null, true);
     if(v >= 11 /* todo_wine */) test("document", document, v < 11 ? "Document" : "HTMLDocument");
-- 
2.48.1


From 3728713e833d49b5c959778daf863cebd74abb4a Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 23/98] mshtml: Use host object script bindings for
 DOMTokenList.

---
 dlls/mshtml/htmlelem.c            | 22 ++++++----------------
 dlls/mshtml/tests/documentmode.js |  2 +-
 2 files changed, 7 insertions(+), 17 deletions(-)

diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 4939e11ac2a..0b0981a454d 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -7085,16 +7085,6 @@ static HRESULT token_list_get_dispid(DispatchEx *dispex, const WCHAR *name, DWOR
     return S_OK;
 }
 
-static HRESULT token_list_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    LONG idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    WCHAR buf[12];
-    UINT len;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%d", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT token_list_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -7127,7 +7117,7 @@ static const dispex_static_data_vtbl_t token_list_dispex_vtbl = {
     .unlink           = token_list_unlink,
     .value            = token_list_value,
     .get_dispid       = token_list_get_dispid,
-    .get_name         = token_list_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = token_list_invoke
 };
 
@@ -7142,7 +7132,7 @@ static dispex_static_data_t token_list_dispex = {
     token_list_iface_tids
 };
 
-static HRESULT create_token_list(compat_mode_t compat_mode, IHTMLElement *element, IWineDOMTokenList **ret)
+static HRESULT create_token_list(compat_mode_t compat_mode, HTMLElement *element, IWineDOMTokenList **ret)
 {
     struct token_list *obj;
 
@@ -7154,9 +7144,9 @@ static HRESULT create_token_list(compat_mode_t compat_mode, IHTMLElement *elemen
     }
 
     obj->IWineDOMTokenList_iface.lpVtbl = &WineDOMTokenListVtbl;
-    init_dispatch(&obj->dispex, &token_list_dispex, NULL, compat_mode);
-    IHTMLElement_AddRef(element);
-    obj->element = element;
+    init_dispatch_with_owner(&obj->dispex, &token_list_dispex, &element->node.event_target.dispex);
+    obj->element = &element->IHTMLElement_iface;
+    IHTMLElement_AddRef(obj->element);
 
     *ret = &obj->IWineDOMTokenList_iface;
     return S_OK;
@@ -7230,7 +7220,7 @@ static HRESULT WINAPI htmlelement_private_get_classList(IWineHTMLElementPrivate
 
     TRACE("iface %p, class_list %p.\n", iface, class_list);
 
-    return create_token_list(dispex_compat_mode(&This->node.event_target.dispex), &This->IHTMLElement_iface,
+    return create_token_list(dispex_compat_mode(&This->node.event_target.dispex), This,
             (IWineDOMTokenList **)class_list);
 }
 
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index f6dafd8e300..1586a7d5a4f 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -337,7 +337,7 @@ sync_test("builtin_toString", function() {
         test("UIEvent", document.createEvent("UIEvent"), "UIEvent");
     }
     if(v >= 10) {
-        test("classList", e.classList, "DOMTokenList", "testclass    another ", true);
+        test("classList", e.classList, "DOMTokenList", "testclass    another ");
         test("console", window.console, "Console");
         test("mediaQueryList", window.matchMedia("(hover:hover)"), "MediaQueryList");
     }
-- 
2.48.1


From 4daf3943cc765cbbd4b0e57e45666034351ec840 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 24/98] mshtml: Use dispex_index_prop_desc for
 HTMLFiltersCollection.

---
 dlls/mshtml/htmlelem.c | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 0b0981a454d..05f4cfd1177 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -7450,16 +7450,6 @@ static HRESULT HTMLFiltersCollection_get_dispid(DispatchEx *dispex, const WCHAR
     return S_OK;
 }
 
-static HRESULT HTMLFiltersCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    WCHAR buf[11];
-    UINT len;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLFiltersCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -7477,7 +7467,7 @@ static const dispex_static_data_vtbl_t HTMLFiltersCollection_dispex_vtbl = {
     .query_interface  = HTMLFiltersCollection_query_interface,
     .destructor       = HTMLFiltersCollection_destructor,
     .get_dispid       = HTMLFiltersCollection_get_dispid,
-    .get_name         = HTMLFiltersCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLFiltersCollection_invoke,
 };
 
-- 
2.48.1


From 1a0b353158f953eea9a37b9e744271fa850dff75 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Tue, 30 Jul 2024 14:14:15 +0200
Subject: [PATCH 25/98] mshtml: Use host object script bindings for
 HTMLAttributeCollection.

---
 dlls/mshtml/htmlelem.c | 15 +++------------
 1 file changed, 3 insertions(+), 12 deletions(-)

diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 05f4cfd1177..bc140b14984 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -8033,15 +8033,6 @@ static HRESULT HTMLAttributeCollection_get_dispid(DispatchEx *dispex, const WCHA
     return S_OK;
 }
 
-static HRESULT HTMLAttributeCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLAttributeCollection *This = HTMLAttributeCollection_from_DispatchEx(dispex);
-
-    FIXME("(%p)->(%lx %p)\n", This, id, name);
-
-    return E_NOTIMPL;
-}
-
 static HRESULT HTMLAttributeCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid,
         WORD flags, DISPPARAMS *params, VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -8082,7 +8073,7 @@ static const dispex_static_data_vtbl_t HTMLAttributeCollection_dispex_vtbl = {
     .traverse         = HTMLAttributeCollection_traverse,
     .unlink           = HTMLAttributeCollection_unlink,
     .get_dispid       = HTMLAttributeCollection_get_dispid,
-    .get_name         = HTMLAttributeCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLAttributeCollection_invoke,
 };
 
@@ -8121,8 +8112,8 @@ HRESULT HTMLElement_get_attr_col(HTMLDOMNode *iface, HTMLAttributeCollection **a
     IHTMLDOMNode_AddRef(&This->node.IHTMLDOMNode_iface);
     This->attrs->elem = This;
     list_init(&This->attrs->attrs);
-    init_dispatch(&This->attrs->dispex, &HTMLAttributeCollection_dispex, NULL,
-                  dispex_compat_mode(&iface->event_target.dispex));
+    init_dispatch(&This->attrs->dispex, &HTMLAttributeCollection_dispex, This->node.doc->script_global,
+                  dispex_compat_mode(&This->node.event_target.dispex));
 
     *ac = This->attrs;
     IHTMLAttributeCollection_AddRef(&This->attrs->IHTMLAttributeCollection_iface);
-- 
2.48.1


From a0b39cb05046cd7c45f0d47a13083608a51585a8 Mon Sep 17 00:00:00 2001
From: Spencer Wallace <spencerwallace@esri.com>
Date: Tue, 23 Jul 2024 16:38:02 -0700
Subject: [PATCH 26/98] shell32/tests: Add tests for moving dir(s) to
 destination(s) with conflicting dir.

---
 dlls/shell32/tests/shlfileop.c | 191 +++++++++++++++++++++++++++++++++
 1 file changed, 191 insertions(+)

diff --git a/dlls/shell32/tests/shlfileop.c b/dlls/shell32/tests/shlfileop.c
index 097e99fd113..1f7c390b295 100644
--- a/dlls/shell32/tests/shlfileop.c
+++ b/dlls/shell32/tests/shlfileop.c
@@ -129,6 +129,15 @@ static void init_shfo_tests(void)
     CreateDirectoryA("testdir2\\nested", NULL);
     createTestFile("testdir2\\one.txt");
     createTestFile("testdir2\\nested\\two.txt");
+    CreateDirectoryA("testdir4", NULL);
+    CreateDirectoryA("testdir4\\nested", NULL);
+    CreateDirectoryA("testdir4\\nested\\subnested", NULL);
+    createTestFile("testdir4\\nested\\2.txt");
+    createTestFile("testdir4\\nested\\subnested\\3.txt");
+    CreateDirectoryA("testdir6", NULL);
+    CreateDirectoryA("testdir6\\nested", NULL);
+    CreateDirectoryA("testdir8", NULL);
+    CreateDirectoryA("testdir8\\nested", NULL);
 }
 
 /* cleans after tests */
@@ -155,6 +164,38 @@ static void clean_after_shfo_tests(void)
     RemoveDirectoryA("testdir2\\test4.txt");
     RemoveDirectoryA("testdir2\\nested");
     RemoveDirectoryA("testdir2");
+    DeleteFileA("testdir4\\nested\\subnested\\3.txt");
+    DeleteFileA("testdir4\\nested\\two.txt");
+    DeleteFileA("testdir4\\nested\\2.txt");
+    RemoveDirectoryA("testdir4\\nested\\subnested");
+    RemoveDirectoryA("testdir4\\nested");
+    RemoveDirectoryA("testdir4");
+    DeleteFileA("testdir6\\testdir2\\nested\\two.txt");
+    DeleteFileA("testdir6\\testdir2\\one.txt");
+    DeleteFileA("testdir6\\nested\\subnested\\3.txt");
+    DeleteFileA("testdir6\\nested\\nested\\two.txt");
+    DeleteFileA("testdir6\\nested\\two.txt");
+    DeleteFileA("testdir6\\nested\\2.txt");
+    DeleteFileA("testdir6\\two.txt");
+    RemoveDirectoryA("testdir6\\testdir2\\nested");
+    RemoveDirectoryA("testdir6\\nested\\subnested");
+    RemoveDirectoryA("testdir6\\nested\\nested");
+    RemoveDirectoryA("testdir6\\testdir2");
+    RemoveDirectoryA("testdir6\\subnested");
+    RemoveDirectoryA("testdir6\\nested");
+    RemoveDirectoryA("testdir6");
+    DeleteFileA("testdir8\\nested\\subnested\\3.txt");
+    DeleteFileA("testdir8\\nested\\nested\\subnested\\3.txt");
+    DeleteFileA("testdir8\\nested\\nested\\2.txt");
+    DeleteFileA("testdir8\\subnested\\3.txt");
+    DeleteFileA("testdir8\\nested\\2.txt");
+    DeleteFileA("testdir8\\2.txt");
+    RemoveDirectoryA("testdir8\\nested\\nested\\subnested");
+    RemoveDirectoryA("testdir8\\nested\\nested");
+    RemoveDirectoryA("testdir8\\nested\\subnested");
+    RemoveDirectoryA("testdir8\\subnested");
+    RemoveDirectoryA("testdir8\\nested");
+    RemoveDirectoryA("testdir8");
     RemoveDirectoryA("c:\\testdir3");
     DeleteFileA("nonexistent\\notreal\\test2.txt");
     RemoveDirectoryA("nonexistent\\notreal");
@@ -1993,9 +2034,159 @@ static void test_move(void)
     clean_after_shfo_tests();
     init_shfo_tests();
 
+    /* test moving dir to destination containing dir of the same name */
+    set_curr_dir_path(from, "testdir2\\nested\0");
+    set_curr_dir_path(to, "testdir4\0");
+    retval = SHFileOperationA(&shfo);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    ok(dir_exists("testdir4\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir4\\nested\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir4\\nested\\2.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
+    /* test moving empty dir to destination containing dir of the same name */
+    DeleteFileA("testdir2\\nested\\two.txt");
+    set_curr_dir_path(from, "testdir2\\nested\0");
+    set_curr_dir_path(to, "testdir4\0");
+    retval = SHFileOperationA(&shfo);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+
+    ok(dir_exists("testdir4\\nested"), "dir should exist\n");
+    ok(file_exists("testdir4\\nested\\2.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
+    /* test moving multiple dirs to destination containing dir of the same name */
+    set_curr_dir_path(from, "testdir2\\nested\0testdir4\\nested\0");
+    set_curr_dir_path(to, "testdir6\0");
+    retval = SHFileOperationA(&shfo);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    todo_wine ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
+    todo_wine ok(!dir_exists("testdir4\\nested\\subnested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir4\\nested\\subnested\\3.txt"), "file should be moved\n");
+
+    ok(dir_exists("testdir6\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+    todo_wine ok(file_exists("testdir6\\nested\\2.txt"), "file should exist\n");
+    todo_wine ok(dir_exists("testdir6\\nested\\subnested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\nested\\subnested\\3.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
     memcpy(&shfo2, &shfo, sizeof(SHFILEOPSTRUCTA));
     shfo2.fFlags |= FOF_MULTIDESTFILES;
 
+    /* test moving dir to destination containing dir of the same name with FOF_MULTIDESTFILES set */
+    set_curr_dir_path(from, "testdir2\\nested\0");
+    set_curr_dir_path(to, "testdir6\0");
+    retval = SHFileOperationA(&shfo2);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    ok(!file_exists("testdir6\\nested\\two.txt"), "file should not exist\n");
+    ok(dir_exists("testdir6\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\two.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
+    /* same as above, without 'nested' in from path */
+    set_curr_dir_path(from, "testdir2\0");
+    set_curr_dir_path(to, "testdir6\0");
+    retval = SHFileOperationA(&shfo2);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    ok(!file_exists("testdir6\\two.txt"), "file should not exist\n");
+    ok(dir_exists("testdir6\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
+    /* test moving multiple dirs to multiple destinations containing dir of the same name */
+    set_curr_dir_path(from, "testdir2\\nested\0testdir4\\nested\0");
+    set_curr_dir_path(to, "testdir6\0testdir8\0");
+    retval = SHFileOperationA(&shfo2);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    todo_wine ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
+    todo_wine ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
+
+    ok(!file_exists("testdir6\\nested\\two.txt"), "file should not exist\n");
+    ok(!file_exists("testdir6\\nested\\2.txt"), "file should not exist\n");
+    ok(dir_exists("testdir6\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\two.txt"), "file should exist\n");
+
+    ok(!dir_exists("testdir8\\nested\\subnested"), "dir should not exist\n");
+    ok(!file_exists("testdir8\\nested\\subnested\\3.txt"), "file should not exist\n");
+    ok(!file_exists("testdir8\\nested\\two.txt"), "file should not exist\n");
+    ok(!file_exists("testdir8\\nested\\2.txt"), "file should not exist\n");
+    ok(dir_exists("testdir8\\nested"), "dir should exist\n");
+    todo_wine ok(dir_exists("testdir8\\subnested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir8\\subnested\\3.txt"), "file should exist\n");
+    todo_wine ok(file_exists("testdir8\\2.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
+    /* same as above, but include subdir in destinations */
+    set_curr_dir_path(from, "testdir2\\nested\0testdir4\\nested\0");
+    set_curr_dir_path(to, "testdir6\\nested\0testdir8\\nested\0");
+    retval = SHFileOperationA(&shfo2);
+    ok(!retval, "got %ld\n", retval);
+    ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
+
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+
+    ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
+
+    ok(dir_exists("testdir6\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+    ok(!file_exists("testdir6\\nested\\2.txt"), "file should not exist\n");
+    ok(!file_exists("testdir6\\two.txt"), "file should not exist\n");
+
+    ok(!dir_exists("testdir8\\subnested"), "dir should not exist\n");
+    ok(!file_exists("testdir8\\2.txt"), "file should not exist\n");
+    ok(!file_exists("testdir8\\nested\\two.txt"), "file should not exist\n");
+    ok(dir_exists("testdir8\\nested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir8\\nested\\2.txt"), "file should exist\n");
+    todo_wine ok(dir_exists("testdir8\\nested\\subnested"), "dir should exist\n");
+    todo_wine ok(file_exists("testdir8\\nested\\subnested\\3.txt"), "file should exist\n");
+
+    clean_after_shfo_tests();
+    init_shfo_tests();
+
     set_curr_dir_path(from, "test1.txt\0test2.txt\0test4.txt\0");
     set_curr_dir_path(to, "test6.txt\0test7.txt\0test8.txt\0");
     ok(!SHFileOperationA(&shfo2), "Move many files\n");
-- 
2.48.1


From 776c65acb14b2cb1bbecff6c585219609acc6065 Mon Sep 17 00:00:00 2001
From: Spencer Wallace <spencerwallace@esri.com>
Date: Tue, 23 Jul 2024 17:03:54 -0700
Subject: [PATCH 27/98] shell32: Fix FO_MOVE when destination has conflicting
 directory.

---
 dlls/shell32/shlfileop.c       | 60 ++++++++++++++++++++++++++---
 dlls/shell32/tests/shlfileop.c | 70 +++++++++++++++-------------------
 2 files changed, 84 insertions(+), 46 deletions(-)

diff --git a/dlls/shell32/shlfileop.c b/dlls/shell32/shlfileop.c
index a7e88c813d2..305cbe26e9a 100644
--- a/dlls/shell32/shlfileop.c
+++ b/dlls/shell32/shlfileop.c
@@ -1382,13 +1382,56 @@ static int delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
     return ERROR_SUCCESS;
 }
 
-/* moves a file or directory to another directory */
-static void move_to_dir(LPSHFILEOPSTRUCTW lpFileOp, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
+/* move a directory to another directory */
+static void move_dir_to_dir(LPSHFILEOPSTRUCTW lpFileOp, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
 {
-    WCHAR szDestPath[MAX_PATH];
+    WCHAR from[MAX_PATH], to[MAX_PATH];
 
-    PathCombineW(szDestPath, feTo->szFullPath, feFrom->szFilename);
-    SHNotifyMoveFileW(feFrom->szFullPath, szDestPath);
+    /* Windows doesn't combine path when FOF_MULTIDESTFILES is set */
+    if (lpFileOp->fFlags & FOF_MULTIDESTFILES)
+        lstrcpyW(to, feTo->szFullPath);
+    else
+        PathCombineW(to, feTo->szFullPath, feFrom->szFilename);
+
+    to[lstrlenW(to) + 1] = '\0';
+
+    /* If destination directory already exists, append source directory
+       with wildcard and restart SHFileOperationW */
+    if (PathFileExistsW(to))
+    {
+        SHFILEOPSTRUCTW fileOp;
+
+        PathCombineW(from, feFrom->szFullPath, L"*.*");
+        from[lstrlenW(from) + 1] = '\0';
+
+        fileOp = *lpFileOp;
+        fileOp.pFrom = from;
+        fileOp.pTo = to;
+        fileOp.fFlags &= ~FOF_MULTIDESTFILES; /* we know we're moving to one dir */
+
+        /* Don't ask the user about overwriting files when he accepted to overwrite the
+           folder. FIXME: this is not exactly what Windows does - e.g. there would be
+           an additional confirmation for a nested folder */
+        fileOp.fFlags |= FOF_NOCONFIRMATION;
+
+        if (!SHFileOperationW(&fileOp))
+            RemoveDirectoryW(feFrom->szFullPath);
+        return;
+    }
+    else
+    {
+        SHNotifyMoveFileW(feFrom->szFullPath, to);
+    }
+}
+
+/* move a file to another directory */
+static void move_file_to_dir(LPSHFILEOPSTRUCTW lpFileOp, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
+{
+    WCHAR to[MAX_PATH];
+
+    PathCombineW(to, feTo->szFullPath, feFrom->szFilename);
+    to[lstrlenW(to) + 1] = '\0';
+    SHNotifyMoveFileW(feFrom->szFullPath, to);
 }
 
 /* the FO_MOVE operation */
@@ -1448,7 +1491,12 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
         }
 
         if (fileDest->bExists && IsAttribDir(fileDest->attributes))
-            move_to_dir(lpFileOp, entryToMove, fileDest);
+        {
+            if (IsAttribDir(entryToMove->attributes))
+                move_dir_to_dir(lpFileOp, entryToMove, fileDest);
+            else
+                move_file_to_dir(lpFileOp, entryToMove, fileDest);
+        }
         else
             SHNotifyMoveFileW(entryToMove->szFullPath, fileDest->szFullPath);
     }
diff --git a/dlls/shell32/tests/shlfileop.c b/dlls/shell32/tests/shlfileop.c
index 1f7c390b295..f191a3016c0 100644
--- a/dlls/shell32/tests/shlfileop.c
+++ b/dlls/shell32/tests/shlfileop.c
@@ -170,28 +170,18 @@ static void clean_after_shfo_tests(void)
     RemoveDirectoryA("testdir4\\nested\\subnested");
     RemoveDirectoryA("testdir4\\nested");
     RemoveDirectoryA("testdir4");
-    DeleteFileA("testdir6\\testdir2\\nested\\two.txt");
-    DeleteFileA("testdir6\\testdir2\\one.txt");
     DeleteFileA("testdir6\\nested\\subnested\\3.txt");
-    DeleteFileA("testdir6\\nested\\nested\\two.txt");
     DeleteFileA("testdir6\\nested\\two.txt");
     DeleteFileA("testdir6\\nested\\2.txt");
     DeleteFileA("testdir6\\two.txt");
-    RemoveDirectoryA("testdir6\\testdir2\\nested");
     RemoveDirectoryA("testdir6\\nested\\subnested");
-    RemoveDirectoryA("testdir6\\nested\\nested");
-    RemoveDirectoryA("testdir6\\testdir2");
     RemoveDirectoryA("testdir6\\subnested");
     RemoveDirectoryA("testdir6\\nested");
     RemoveDirectoryA("testdir6");
     DeleteFileA("testdir8\\nested\\subnested\\3.txt");
-    DeleteFileA("testdir8\\nested\\nested\\subnested\\3.txt");
-    DeleteFileA("testdir8\\nested\\nested\\2.txt");
     DeleteFileA("testdir8\\subnested\\3.txt");
     DeleteFileA("testdir8\\nested\\2.txt");
     DeleteFileA("testdir8\\2.txt");
-    RemoveDirectoryA("testdir8\\nested\\nested\\subnested");
-    RemoveDirectoryA("testdir8\\nested\\nested");
     RemoveDirectoryA("testdir8\\nested\\subnested");
     RemoveDirectoryA("testdir8\\subnested");
     RemoveDirectoryA("testdir8\\nested");
@@ -2041,11 +2031,11 @@ static void test_move(void)
     ok(!retval, "got %ld\n", retval);
     ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
 
-    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
 
     ok(dir_exists("testdir4\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir4\\nested\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir4\\nested\\two.txt"), "file should exist\n");
     ok(file_exists("testdir4\\nested\\2.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
@@ -2059,7 +2049,7 @@ static void test_move(void)
     ok(!retval, "got %ld\n", retval);
     ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
 
-    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
 
     ok(dir_exists("testdir4\\nested"), "dir should exist\n");
     ok(file_exists("testdir4\\nested\\2.txt"), "file should exist\n");
@@ -2074,19 +2064,19 @@ static void test_move(void)
     ok(!retval, "got %ld\n", retval);
     ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
 
-    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
 
-    todo_wine ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
-    todo_wine ok(!dir_exists("testdir4\\nested\\subnested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir4\\nested\\subnested\\3.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir4\\nested\\subnested"), "dir should be moved\n");
+    ok(!file_exists("testdir4\\nested\\subnested\\3.txt"), "file should be moved\n");
 
     ok(dir_exists("testdir6\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
-    todo_wine ok(file_exists("testdir6\\nested\\2.txt"), "file should exist\n");
-    todo_wine ok(dir_exists("testdir6\\nested\\subnested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\nested\\subnested\\3.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\nested\\2.txt"), "file should exist\n");
+    ok(dir_exists("testdir6\\nested\\subnested"), "dir should exist\n");
+    ok(file_exists("testdir6\\nested\\subnested\\3.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
     init_shfo_tests();
@@ -2101,12 +2091,12 @@ static void test_move(void)
     ok(!retval, "got %ld\n", retval);
     ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
 
-    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
 
     ok(!file_exists("testdir6\\nested\\two.txt"), "file should not exist\n");
     ok(dir_exists("testdir6\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\two.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
     init_shfo_tests();
@@ -2123,7 +2113,7 @@ static void test_move(void)
 
     ok(!file_exists("testdir6\\two.txt"), "file should not exist\n");
     ok(dir_exists("testdir6\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
     init_shfo_tests();
@@ -2135,25 +2125,25 @@ static void test_move(void)
     ok(!retval, "got %ld\n", retval);
     ok(!shfo.fAnyOperationsAborted, "fAnyOperationsAborted %d\n", shfo.fAnyOperationsAborted);
 
-    todo_wine ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir2\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir2\\nested\\two.txt"), "file should be moved\n");
 
-    todo_wine ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
-    todo_wine ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
+    ok(!dir_exists("testdir4\\nested"), "dir should be moved\n");
+    ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
 
     ok(!file_exists("testdir6\\nested\\two.txt"), "file should not exist\n");
     ok(!file_exists("testdir6\\nested\\2.txt"), "file should not exist\n");
     ok(dir_exists("testdir6\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\two.txt"), "file should exist\n");
 
     ok(!dir_exists("testdir8\\nested\\subnested"), "dir should not exist\n");
     ok(!file_exists("testdir8\\nested\\subnested\\3.txt"), "file should not exist\n");
     ok(!file_exists("testdir8\\nested\\two.txt"), "file should not exist\n");
     ok(!file_exists("testdir8\\nested\\2.txt"), "file should not exist\n");
     ok(dir_exists("testdir8\\nested"), "dir should exist\n");
-    todo_wine ok(dir_exists("testdir8\\subnested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir8\\subnested\\3.txt"), "file should exist\n");
-    todo_wine ok(file_exists("testdir8\\2.txt"), "file should exist\n");
+    ok(dir_exists("testdir8\\subnested"), "dir should exist\n");
+    ok(file_exists("testdir8\\subnested\\3.txt"), "file should exist\n");
+    ok(file_exists("testdir8\\2.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
     init_shfo_tests();
@@ -2172,7 +2162,7 @@ static void test_move(void)
     ok(!file_exists("testdir4\\nested\\2.txt"), "file should be moved\n");
 
     ok(dir_exists("testdir6\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
+    ok(file_exists("testdir6\\nested\\two.txt"), "file should exist\n");
     ok(!file_exists("testdir6\\nested\\2.txt"), "file should not exist\n");
     ok(!file_exists("testdir6\\two.txt"), "file should not exist\n");
 
@@ -2180,9 +2170,9 @@ static void test_move(void)
     ok(!file_exists("testdir8\\2.txt"), "file should not exist\n");
     ok(!file_exists("testdir8\\nested\\two.txt"), "file should not exist\n");
     ok(dir_exists("testdir8\\nested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir8\\nested\\2.txt"), "file should exist\n");
-    todo_wine ok(dir_exists("testdir8\\nested\\subnested"), "dir should exist\n");
-    todo_wine ok(file_exists("testdir8\\nested\\subnested\\3.txt"), "file should exist\n");
+    ok(file_exists("testdir8\\nested\\2.txt"), "file should exist\n");
+    ok(dir_exists("testdir8\\nested\\subnested"), "dir should exist\n");
+    ok(file_exists("testdir8\\nested\\subnested\\3.txt"), "file should exist\n");
 
     clean_after_shfo_tests();
     init_shfo_tests();
-- 
2.48.1


From 1d961140b7e576997728d040180511ad5b54ce7c Mon Sep 17 00:00:00 2001
From: Vijay Kiran Kamuju <infyquest@gmail.com>
Date: Sat, 17 Feb 2024 18:14:53 +0100
Subject: [PATCH 28/98] include: Add more Task Scheduler Trigger interface
 definitions.

---
 include/taskschd.idl | 129 ++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 116 insertions(+), 13 deletions(-)

diff --git a/include/taskschd.idl b/include/taskschd.idl
index 6c5e5533934..52f870a7245 100644
--- a/include/taskschd.idl
+++ b/include/taskschd.idl
@@ -72,7 +72,8 @@ typedef enum _TASK_TRIGGER_TYPE2
     TASK_TRIGGER_REGISTRATION,
     TASK_TRIGGER_BOOT,
     TASK_TRIGGER_LOGON,
-    TASK_TRIGGER_SESSION_STATE_CHANGE = 11
+    TASK_TRIGGER_SESSION_STATE_CHANGE = 11,
+    TASK_TRIGGER_CUSTOM_TRIGGER_01
 } TASK_TRIGGER_TYPE2;
 
 typedef enum _TASK_ACTION_TYPE
@@ -96,7 +97,10 @@ typedef enum _TASK_COMPATIBILITY
     TASK_COMPATIBILITY_AT,
     TASK_COMPATIBILITY_V1,
     TASK_COMPATIBILITY_V2,
-    TASK_COMPATIBILITY_V2_1
+    TASK_COMPATIBILITY_V2_1,
+    TASK_COMPATIBILITY_V2_2,
+    TASK_COMPATIBILITY_V2_3,
+    TASK_COMPATIBILITY_V2_4
 } TASK_COMPATIBILITY;
 
 typedef enum _TASK_CREATION
@@ -123,7 +127,15 @@ interface IRunningTask;
 interface IRunningTaskCollection;
 interface ITrigger;
 interface ITriggerCollection;
+interface IIdleTrigger;
+interface ILogonTrigger;
 interface ITimeTrigger;
+interface IDailyTrigger;
+interface IWeeklyTrigger;
+interface IMonthlyTrigger;
+interface IMonthlyDOWTrigger;
+interface IBootTrigger;
+interface IRegistrationTrigger;
 interface IRepetitionPattern;
 interface IAction;
 interface IActionCollection;
@@ -392,6 +404,42 @@ interface ITrigger : IDispatch
     [propput] HRESULT Enabled([in] VARIANT_BOOL enabled);
 }
 
+[
+    uuid(d537d2b0-9fb3-4d34-9739-1ff5ce7b1ef3),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IIdleTrigger : ITrigger
+{
+}
+
+[
+    uuid(72dade38-fae4-4b3e-baf4-5d009af02b1c),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface ILogonTrigger : ITrigger
+{
+    [propget] HRESULT Delay([out, retval] BSTR *pDelay);
+    [propput] HRESULT Delay([in] BSTR delay);
+    [propget] HRESULT UserId([out, retval] BSTR *pUser);
+    [propput] HRESULT UserId([in] BSTR user);
+}
+
+[
+    uuid(b45747e0-eba7-4276-9f29-85c5bb300006),
+    object,
+    oleautomation,
+    nonextensible
+]
+interface ITimeTrigger : ITrigger
+{
+    [propget] HRESULT RandomDelay([out, retval] BSTR *delay);
+    [propput] HRESULT RandomDelay([in] BSTR delay);
+}
+
 [
     odl,
     uuid(126c5cd8-b288-41d5-8dbf-e491446adc5c),
@@ -407,6 +455,72 @@ interface IDailyTrigger : ITrigger
     [propput] HRESULT RandomDelay([in] BSTR randomDelay);
 }
 
+[
+    uuid(5038fc98-82ff-436d-8728-a512a57c9dc1),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IWeeklyTrigger : ITrigger
+{
+    [propget] HRESULT DaysOfWeek([out, retval] short *pDays);
+    [propput] HRESULT DaysOfWeek([in] short days);
+    [propget] HRESULT WeeksInterval([out, retval] short *pWeeks);
+    [propput] HRESULT WeeksInterval([in] short weeks);
+    [propget] HRESULT RandomDelay([out, retval] BSTR *pRandomDelay);
+    [propput] HRESULT RandomDelay([in] BSTR randomDelay);
+}
+
+[
+    uuid(97c45ef1-6b02-4a1a-9c0e-1ebfba1500ac),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IMonthlyTrigger : ITrigger
+{
+    [propget] HRESULT DaysOfMonth([out, retval] short *pDays);
+    [propput] HRESULT DaysOfMonth([in] short days);
+    [propget] HRESULT MonthsOfYear([out, retval] short *pMonths);
+    [propput] HRESULT MonthsOfYear([in] short months);
+    [propget] HRESULT RunOnLastDayOfMonth([out, retval] VARIANT_BOOL *pLastDay);
+    [propput] HRESULT RunOnLastDayOfMonth([in] VARIANT_BOOL lastDay);
+    [propget] HRESULT RandomDelay([out, retval] BSTR *pRandomDelay);
+    [propput] HRESULT RandomDelay([in] BSTR randomDelay);
+}
+
+[
+    uuid(77d025a3-90fa-43aa-b52e-cda5499b946a),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IMonthlyDOWTrigger : ITrigger
+{
+    [propget] HRESULT DaysOfWeek([out, retval] short *pDays);
+    [propput] HRESULT DaysOfWeek([in] short days);
+    [propget] HRESULT WeeksOfMonth([out, retval] short *pWeeks);
+    [propput] HRESULT WeeksOfMonth([in] short weeks);
+    [propget] HRESULT MonthsOfYear([out, retval] short *pMonths);
+    [propput] HRESULT MonthsOfYear([in] short months);
+    [propget] HRESULT RunOnLastWeekOfMonth([out, retval] VARIANT_BOOL *pLastWeek);
+    [propput] HRESULT RunOnLastWeekOfMonth([in] VARIANT_BOOL lastWeek);
+    [propget] HRESULT RandomDelay([out, retval] BSTR *pRandomDelay);
+    [propput] HRESULT RandomDelay([in] BSTR randomDelay);
+}
+
+[
+    uuid(2a9c35da-d357-41f4-bbc1-207ac1b1f3cb),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IBootTrigger : ITrigger
+{
+    [propget] HRESULT Delay([out, retval] BSTR *pDelay);
+    [propput] HRESULT Delay([in] BSTR delay);
+}
+
 [
     uuid(4c8fec3a-c218-4e0c-b23d-629024db91a2),
     oleautomation,
@@ -434,17 +548,6 @@ interface ITriggerCollection : IDispatch
     HRESULT Clear();
 }
 
-[
-    object,
-    oleautomation,
-    uuid(b45747e0-eba7-4276-9f29-85c5bb300006)
-]
-interface ITimeTrigger : ITrigger
-{
-    [propget] HRESULT RandomDelay([out, retval] BSTR *delay);
-    [propput] HRESULT RandomDelay([in] BSTR delay);
-}
-
 [
     object,
     oleautomation,
-- 
2.48.1


From d7f07c3983b759af556bc611cb4bd4521425d247 Mon Sep 17 00:00:00 2001
From: Vijay Kiran Kamuju <infyquest@gmail.com>
Date: Sat, 17 Feb 2024 18:37:00 +0100
Subject: [PATCH 29/98] include: Add ISessionStateChangeTrigger declaration.

---
 include/taskschd.idl | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/include/taskschd.idl b/include/taskschd.idl
index 52f870a7245..c9e6a604ec2 100644
--- a/include/taskschd.idl
+++ b/include/taskschd.idl
@@ -76,6 +76,16 @@ typedef enum _TASK_TRIGGER_TYPE2
     TASK_TRIGGER_CUSTOM_TRIGGER_01
 } TASK_TRIGGER_TYPE2;
 
+typedef enum _TASK_SESSION_STATE_CHANGE_TYPE
+{
+    TASK_CONSOLE_CONNECT = 1,
+    TASK_CONSOLE_DISCONNECT,
+    TASK_REMOTE_CONNECT,
+    TASK_REMOTE_DISCONNECT,
+    TASK_SESSION_LOCK = 7,
+    TASK_SESSION_UNLOCK
+} TASK_SESSION_STATE_CHANGE_TYPE;
+
 typedef enum _TASK_ACTION_TYPE
 {
     TASK_ACTION_EXEC = 0,
@@ -129,6 +139,7 @@ interface ITrigger;
 interface ITriggerCollection;
 interface IIdleTrigger;
 interface ILogonTrigger;
+interface ISessionStateChangeTrigger;
 interface ITimeTrigger;
 interface IDailyTrigger;
 interface IWeeklyTrigger;
@@ -428,6 +439,22 @@ interface ILogonTrigger : ITrigger
     [propput] HRESULT UserId([in] BSTR user);
 }
 
+[
+    uuid(754da71b-4385-4475-9dd9-598294fa3641),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface ISessionStateChangeTrigger : ITrigger
+{
+    [propget] HRESULT Delay([out, retval] BSTR *pDelay);
+    [propput] HRESULT Delay([in] BSTR delay);
+    [propget] HRESULT UserId([out, retval] BSTR *pUser);
+    [propput] HRESULT UserId([in] BSTR user);
+    [propget] HRESULT StateChange([out, retval] TASK_SESSION_STATE_CHANGE_TYPE *pType);
+    [propput] HRESULT StateChange([in] TASK_SESSION_STATE_CHANGE_TYPE type);
+}
+
 [
     uuid(b45747e0-eba7-4276-9f29-85c5bb300006),
     object,
-- 
2.48.1


From 1dfac2a252d0036c3bae08bf47f00582343a80fb Mon Sep 17 00:00:00 2001
From: Vijay Kiran Kamuju <infyquest@gmail.com>
Date: Sat, 17 Feb 2024 19:05:21 +0100
Subject: [PATCH 30/98] include: Added IEventTrigger declaration.

---
 include/taskschd.idl | 51 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/include/taskschd.idl b/include/taskschd.idl
index c9e6a604ec2..eaa71da4d45 100644
--- a/include/taskschd.idl
+++ b/include/taskschd.idl
@@ -135,11 +135,14 @@ interface ITaskSettings;
 interface IIdleSettings;
 interface IRunningTask;
 interface IRunningTaskCollection;
+interface ITaskNamedValuePair;
+interface ITaskNamedValueCollection;
 interface ITrigger;
 interface ITriggerCollection;
 interface IIdleTrigger;
 interface ILogonTrigger;
 interface ISessionStateChangeTrigger;
+interface IEventTrigger;
 interface ITimeTrigger;
 interface IDailyTrigger;
 interface IWeeklyTrigger;
@@ -393,6 +396,38 @@ interface IRunningTaskCollection : IDispatch
     [propget] HRESULT _NewEnum([out, retval] IUnknown **penum);
 }
 
+[
+    object,
+    oleautomation,
+    dual,
+    nonextensible,
+    uuid(39038068-2b46-4afd-8662-7bb6f868d221)
+]
+interface ITaskNamedValuePair : IDispatch
+{
+    [propget] HRESULT Name([out, retval] BSTR *pName);
+    [propput] HRESULT Name([in] BSTR name);
+    [propget] HRESULT Value([out, retval] BSTR *pValue);
+    [propput] HRESULT Value([in] BSTR value);
+}
+
+[
+    object,
+    oleautomation,
+    dual,
+    nonextensible,
+    uuid(b4ef826b-63c3-46e4-a504-ef69e4f7ea4d)
+]
+interface ITaskNamedValueCollection : IDispatch
+{
+    [propget] HRESULT Count([out, retval] LONG *count);
+    [propget] HRESULT Item([in] VARIANT index, [out, retval] ITaskNamedValuePair **pair);
+    [propget] HRESULT _NewEnum([out, retval] IUnknown **penum);
+    HRESULT Create([in] BSTR name, [in] BSTR value, [out, retval] ITaskNamedValuePair **pair);
+    HRESULT Remove([in] LONG index);
+    HRESULT Clear();
+}
+
 [
     object,
     oleautomation,
@@ -455,6 +490,22 @@ interface ISessionStateChangeTrigger : ITrigger
     [propput] HRESULT StateChange([in] TASK_SESSION_STATE_CHANGE_TYPE type);
 }
 
+[
+    uuid(d45b0167-9653-4eef-b94f-0732ca7af251),
+    oleautomation,
+    dual,
+    nonextensible
+]
+interface IEventTrigger : ITrigger
+{
+    [propget] HRESULT Subscription([out, retval] BSTR *pQuery);
+    [propput] HRESULT Subscription([in] BSTR query);
+    [propget] HRESULT Delay([out, retval] BSTR *pDelay);
+    [propput] HRESULT Delay([in] BSTR delay);
+    [propget] HRESULT ValueQueries([out, retval] ITaskNamedValueCollection **ppNamedXPaths);
+    [propput] HRESULT ValueQueries([in] ITaskNamedValueCollection *pNamedXPaths);
+}
+
 [
     uuid(b45747e0-eba7-4276-9f29-85c5bb300006),
     object,
-- 
2.48.1


From 81dbeba08c3d0dc3f5167dfd6786885a8c5e5b0a Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 21 Jul 2024 21:46:59 -0500
Subject: [PATCH 31/98] wined3d: Invalidate push constant flags only for the
 primary stateblock.

---
 dlls/wined3d/stateblock.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 0d5d62359f7..67c696fa4f5 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -2266,7 +2266,8 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock, const stru
     stateblock->changed.store_stream_offset = 1;
     list_init(&stateblock->changed.changed_lights);
 
-    wined3d_stateblock_invalidate_push_constants(stateblock);
+    if (type == WINED3D_SBT_PRIMARY)
+        wined3d_stateblock_invalidate_push_constants(stateblock);
 
     if (type == WINED3D_SBT_RECORDED || type == WINED3D_SBT_PRIMARY)
         return WINED3D_OK;
-- 
2.48.1


From 9b8a99a8e025af0715a17767911483ce09396c66 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 9 Jun 2024 12:50:26 -0500
Subject: [PATCH 32/98] wined3d: Feed the material through a push constant
 buffer.

---
 dlls/wined3d/cs.c              | 29 -----------------------------
 dlls/wined3d/ffp_gl.c          |  1 -
 dlls/wined3d/glsl_shader.c     | 23 ++++++++++-------------
 dlls/wined3d/shader_spirv.c    |  1 -
 dlls/wined3d/stateblock.c      | 15 +++++----------
 dlls/wined3d/utils.c           |  2 --
 dlls/wined3d/wined3d_private.h |  9 ++-------
 7 files changed, 17 insertions(+), 63 deletions(-)

diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index f7f8021e8ba..d35c33f678c 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -121,7 +121,6 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_TRANSFORM,
     WINED3D_CS_OP_SET_CLIP_PLANE,
     WINED3D_CS_OP_SET_COLOR_KEY,
-    WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_SET_LIGHT,
     WINED3D_CS_OP_SET_LIGHT_ENABLE,
     WINED3D_CS_OP_SET_FEATURE_LEVEL,
@@ -383,12 +382,6 @@ struct wined3d_cs_set_clip_plane
     struct wined3d_vec4 plane;
 };
 
-struct wined3d_cs_set_material
-{
-    enum wined3d_cs_op opcode;
-    struct wined3d_material material;
-};
-
 struct wined3d_cs_set_light
 {
     enum wined3d_cs_op opcode;
@@ -604,7 +597,6 @@ static const char *debug_cs_op(enum wined3d_cs_op op)
         WINED3D_TO_STR(WINED3D_CS_OP_SET_TRANSFORM);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_CLIP_PLANE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_COLOR_KEY);
-        WINED3D_TO_STR(WINED3D_CS_OP_SET_MATERIAL);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_LIGHT);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_LIGHT_ENABLE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_FEATURE_LEVEL);
@@ -2015,26 +2007,6 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
     wined3d_device_context_submit(&cs->c, WINED3D_CS_QUEUE_DEFAULT);
 }
 
-static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
-{
-    const struct wined3d_cs_set_material *op = data;
-
-    cs->state.material = op->material;
-    device_invalidate_state(cs->c.device, STATE_MATERIAL);
-}
-
-void wined3d_device_context_emit_set_material(struct wined3d_device_context *context,
-        const struct wined3d_material *material)
-{
-    struct wined3d_cs_set_material *op;
-
-    op = wined3d_device_context_require_space(context, sizeof(*op), WINED3D_CS_QUEUE_DEFAULT);
-    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
-    op->material = *material;
-
-    wined3d_device_context_submit(context, WINED3D_CS_QUEUE_DEFAULT);
-}
-
 static void wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
 {
     const struct wined3d_cs_set_light *op = data;
@@ -2957,7 +2929,6 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_SET_TRANSFORM               */ wined3d_cs_exec_set_transform,
     /* WINED3D_CS_OP_SET_CLIP_PLANE              */ wined3d_cs_exec_set_clip_plane,
     /* WINED3D_CS_OP_SET_COLOR_KEY               */ wined3d_cs_exec_set_color_key,
-    /* WINED3D_CS_OP_SET_MATERIAL                */ wined3d_cs_exec_set_material,
     /* WINED3D_CS_OP_SET_LIGHT                   */ wined3d_cs_exec_set_light,
     /* WINED3D_CS_OP_SET_LIGHT_ENABLE            */ wined3d_cs_exec_set_light_enable,
     /* WINED3D_CS_OP_SET_FEATURE_LEVEL           */ wined3d_cs_exec_set_feature_level,
diff --git a/dlls/wined3d/ffp_gl.c b/dlls/wined3d/ffp_gl.c
index f1f995f6e4c..a518521b101 100644
--- a/dlls/wined3d/ffp_gl.c
+++ b/dlls/wined3d/ffp_gl.c
@@ -1684,7 +1684,6 @@ static void validate_state_table(struct wined3d_state_entry *state_table)
     };
     static const unsigned int simple_states[] =
     {
-        STATE_MATERIAL,
         STATE_VDECL,
         STATE_STREAMSRC,
         STATE_INDEXBUFFER,
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 3fe7640106f..b4973c71343 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1509,16 +1509,20 @@ static void shader_glsl_ffp_vertex_texmatrix_uniform(const struct wined3d_contex
     checkGLcall("glUniformMatrix4fv");
 }
 
-static void shader_glsl_ffp_vertex_material_uniform(const struct wined3d_context_gl *context_gl,
+static void shader_glsl_ffp_vertex_material_uniform(struct wined3d_context_gl *context_gl,
         const struct wined3d_state *state, struct glsl_shader_prog_link *prog)
 {
     const struct wined3d_gl_info *gl_info = context_gl->gl_info;
+    const struct wined3d_ffp_vs_constants *constants;
 
-    GL_EXTCALL(glUniform4fv(prog->vs.material_specular_location, 1, &state->material.specular.r));
-    GL_EXTCALL(glUniform1f(prog->vs.material_shininess_location, state->material.power));
-    GL_EXTCALL(glUniform4fv(prog->vs.material_ambient_location, 1, &state->material.ambient.r));
-    GL_EXTCALL(glUniform4fv(prog->vs.material_diffuse_location, 1, &state->material.diffuse.r));
-    GL_EXTCALL(glUniform4fv(prog->vs.material_emissive_location, 1, &state->material.emissive.r));
+    constants = wined3d_buffer_load_sysmem(
+            context_gl->c.device->push_constants[WINED3D_PUSH_CONSTANTS_VS_FFP], &context_gl->c);
+
+    GL_EXTCALL(glUniform4fv(prog->vs.material_specular_location, 1, &constants->material.specular.r));
+    GL_EXTCALL(glUniform1f(prog->vs.material_shininess_location, constants->material.power));
+    GL_EXTCALL(glUniform4fv(prog->vs.material_ambient_location, 1, &constants->material.ambient.r));
+    GL_EXTCALL(glUniform4fv(prog->vs.material_diffuse_location, 1, &constants->material.diffuse.r));
+    GL_EXTCALL(glUniform4fv(prog->vs.material_emissive_location, 1, &constants->material.emissive.r));
     checkGLcall("setting FFP material uniforms");
 }
 
@@ -11847,12 +11851,6 @@ static void glsl_vertex_pipe_viewport(struct wined3d_context *context,
     context->constant_update_mask |= WINED3D_SHADER_CONST_POS_FIXUP;
 }
 
-static void glsl_vertex_pipe_material(struct wined3d_context *context,
-        const struct wined3d_state *state, DWORD state_id)
-{
-    context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_MATERIAL;
-}
-
 static void glsl_vertex_pipe_pointsize(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
@@ -11902,7 +11900,6 @@ static const struct wined3d_state_entry_template glsl_vertex_pipe_vp_states[] =
     {STATE_SHADER(WINED3D_SHADER_TYPE_HULL),                     {STATE_SHADER(WINED3D_SHADER_TYPE_HULL),                     glsl_vertex_pipe_hs    }, WINED3D_GL_EXT_NONE          },
     {STATE_SHADER(WINED3D_SHADER_TYPE_GEOMETRY),                 {STATE_SHADER(WINED3D_SHADER_TYPE_GEOMETRY),                 glsl_vertex_pipe_geometry_shader}, WINED3D_GL_EXT_NONE },
     {STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL),                    {STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL),                    glsl_vertex_pipe_pixel_shader}, WINED3D_GL_EXT_NONE    },
-    {STATE_MATERIAL,                                             {STATE_MATERIAL,                                             glsl_vertex_pipe_material}, WINED3D_GL_EXT_NONE        },
     /* Clip planes */
     {STATE_CLIPPLANE(0),                                         {STATE_CLIPPLANE(0),                                         glsl_vertex_pipe_clip_plane}, WINED3D_GLSL_130         },
     {STATE_CLIPPLANE(0),                                         {STATE_CLIPPLANE(0),                                         clipplane              }, WINED3D_GL_EXT_NONE          },
diff --git a/dlls/wined3d/shader_spirv.c b/dlls/wined3d/shader_spirv.c
index a4b311ae8d2..a5461d3d998 100644
--- a/dlls/wined3d/shader_spirv.c
+++ b/dlls/wined3d/shader_spirv.c
@@ -1176,7 +1176,6 @@ static const struct wined3d_state_entry_template spirv_vertex_pipe_vk_vp_states[
     {STATE_RENDER(WINED3D_RS_POINTSCALE_B),             {STATE_RENDER(WINED3D_RS_POINTSCALE_B),             state_nop}},
     {STATE_RENDER(WINED3D_RS_POINTSCALE_C),             {STATE_RENDER(WINED3D_RS_POINTSCALE_C),             state_nop}},
     {STATE_RENDER(WINED3D_RS_POINTSIZE_MAX),            {STATE_RENDER(WINED3D_RS_POINTSIZE_MAX),            state_nop}},
-    {STATE_MATERIAL,                                    {STATE_MATERIAL,                                    state_nop}},
     {STATE_SHADER(WINED3D_SHADER_TYPE_VERTEX),          {STATE_SHADER(WINED3D_SHADER_TYPE_VERTEX),          state_nop}},
     {STATE_LIGHT_TYPE,                                  {STATE_LIGHT_TYPE,                                  state_nop}},
     {0}, /* Terminate */
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 67c696fa4f5..0618f982315 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -2250,6 +2250,7 @@ static void wined3d_stateblock_invalidate_push_constants(struct wined3d_stateblo
     stateblock->changed.ffp_ps_constants = 1;
     stateblock->changed.lights = 1;
     stateblock->changed.texture_matrices = 1;
+    stateblock->changed.material = 1;
 }
 
 static HRESULT stateblock_init(struct wined3d_stateblock *stateblock, const struct wined3d_stateblock *device_state,
@@ -2610,14 +2611,6 @@ static void wined3d_device_set_texture(struct wined3d_device *device,
     return;
 }
 
-static void wined3d_device_set_material(struct wined3d_device *device, const struct wined3d_material *material)
-{
-    TRACE("device %p, material %p.\n", device, material);
-
-    device->cs->c.state->material = *material;
-    wined3d_device_context_emit_set_material(&device->cs->c, material);
-}
-
 static void wined3d_device_set_transform(struct wined3d_device *device,
         enum wined3d_transform_state state, const struct wined3d_matrix *matrix)
 {
@@ -3355,8 +3348,6 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
     wined3d_device_set_base_vertex_index(device, state->base_vertex_index);
     if (changed->vertexDecl)
         wined3d_device_context_set_vertex_declaration(context, state->vertex_declaration);
-    if (changed->material)
-        wined3d_device_set_material(device, &state->material);
     if (changed->viewport)
         wined3d_device_context_set_viewports(context, 1, &state->viewport);
     if (changed->scissorRect)
@@ -3426,6 +3417,10 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
         }
     }
 
+    if (changed->material)
+        wined3d_device_context_push_constants(context, WINED3D_PUSH_CONSTANTS_VS_FFP, WINED3D_SHADER_CONST_FFP_MATERIAL,
+                offsetof(struct wined3d_ffp_vs_constants, material), sizeof(state->material), &state->material);
+
     if (changed->lights)
     {
         unsigned int point_idx, spot_idx, directional_idx, parallel_point_idx;
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index cd3458770aa..495831c40e5 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -5369,8 +5369,6 @@ const char *debug_d3dstate(uint32_t state)
         return "STATE_SCISSORRECT";
     if (STATE_IS_CLIPPLANE(state))
         return wine_dbg_sprintf("STATE_CLIPPLANE(%#x)", state - STATE_CLIPPLANE(0));
-    if (STATE_IS_MATERIAL(state))
-        return "STATE_MATERIAL";
     if (STATE_IS_RASTERIZER(state))
         return "STATE_RASTERIZER";
     if (STATE_IS_DEPTH_BOUNDS(state))
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index a2db15d6c9e..7d36979b8da 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -1757,10 +1757,7 @@ void dispatch_compute(struct wined3d_device *device, const struct wined3d_state
 #define STATE_CLIPPLANE(a) (STATE_SCISSORRECT + 1 + (a))
 #define STATE_IS_CLIPPLANE(a) ((a) >= STATE_CLIPPLANE(0) && (a) <= STATE_CLIPPLANE(WINED3D_MAX_CLIP_DISTANCES - 1))
 
-#define STATE_MATERIAL (STATE_CLIPPLANE(WINED3D_MAX_CLIP_DISTANCES))
-#define STATE_IS_MATERIAL(a) ((a) == STATE_MATERIAL)
-
-#define STATE_RASTERIZER (STATE_MATERIAL + 1)
+#define STATE_RASTERIZER (STATE_CLIPPLANE(WINED3D_MAX_CLIP_DISTANCES))
 #define STATE_IS_RASTERIZER(a) ((a) == STATE_RASTERIZER)
 
 #define STATE_DEPTH_BOUNDS (STATE_RASTERIZER + 1)
@@ -2772,6 +2769,7 @@ BOOL wined3d_get_app_name(char *app_name, unsigned int app_name_size);
 struct wined3d_ffp_vs_constants
 {
     struct wined3d_matrix texture_matrices[WINED3D_MAX_FFP_TEXTURES];
+    struct wined3d_material material;
     struct wined3d_ffp_light_constants
     {
         struct wined3d_color ambient;
@@ -2889,7 +2887,6 @@ struct wined3d_state
 
     struct wined3d_matrix transforms[WINED3D_HIGHEST_TRANSFORM_STATE + 1];
     struct wined3d_vec4 clip_planes[WINED3D_MAX_CLIP_DISTANCES];
-    struct wined3d_material material;
     struct wined3d_viewport viewports[WINED3D_MAX_VIEWPORTS];
     unsigned int viewport_count;
     RECT scissor_rects[WINED3D_MAX_VIEWPORTS];
@@ -3702,8 +3699,6 @@ void wined3d_device_context_emit_set_light(struct wined3d_device_context *contex
         const struct wined3d_light_info *light);
 void wined3d_device_context_emit_set_light_enable(struct wined3d_device_context *context, unsigned int idx,
         BOOL enable);
-void wined3d_device_context_emit_set_material(struct wined3d_device_context *context,
-        const struct wined3d_material *material);
 void wined3d_device_context_emit_set_predication(struct wined3d_device_context *context,
         struct wined3d_query *predicate, BOOL value);
 void wined3d_device_context_emit_set_rasterizer_state(struct wined3d_device_context *context,
-- 
2.48.1


From 283ef7f926c4d81dc2bf9c2aa3ca85e2fe8312b5 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 9 Jun 2024 12:50:26 -0500
Subject: [PATCH 33/98] wined3d: Move get_projection_matrix() to glsl_shader.c.

---
 dlls/wined3d/ffp_gl.c          |  2 +-
 dlls/wined3d/glsl_shader.c     | 85 ++++++++++++++++++++++++++++++++++
 dlls/wined3d/utils.c           | 85 ----------------------------------
 dlls/wined3d/wined3d_private.h |  4 +-
 4 files changed, 87 insertions(+), 89 deletions(-)

diff --git a/dlls/wined3d/ffp_gl.c b/dlls/wined3d/ffp_gl.c
index a518521b101..447de1b68b0 100644
--- a/dlls/wined3d/ffp_gl.c
+++ b/dlls/wined3d/ffp_gl.c
@@ -1139,7 +1139,7 @@ static void viewport_miscpart_cc(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
-    /* See get_projection_matrix() in utils.c for a discussion about those values. */
+    /* See get_projection_matrix() in glsl_shader.c for a discussion about those values. */
     float pixel_center_offset = context->d3d_info->wined3d_creation_flags
             & WINED3D_PIXEL_CENTER_INTEGER ? 0.5f : 0.0f;
     GLdouble depth_ranges[2 * WINED3D_MAX_VIEWPORTS];
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index b4973c71343..e055e88103e 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1477,6 +1477,91 @@ static void reset_program_constant_version(struct wine_rb_entry *entry, void *co
     WINE_RB_ENTRY_VALUE(entry, struct glsl_shader_prog_link, program_lookup_entry)->constant_version = 0;
 }
 
+static void get_projection_matrix(const struct wined3d_context *context,
+        const struct wined3d_state *state, struct wined3d_matrix *mat)
+{
+    const struct wined3d_d3d_info *d3d_info = context->d3d_info;
+    bool clip_control, flip;
+    float center_offset;
+
+    /* There are a couple of additional things we have to take into account
+     * here besides the projection transformation itself:
+     *   - We need to flip along the y-axis in case of offscreen rendering.
+     *   - OpenGL Z range is {-Wc,...,Wc} while D3D Z range is {0,...,Wc}.
+     *   - <= D3D9 coordinates refer to pixel centers while GL coordinates
+     *     refer to pixel corners. D3D10 fixed this particular oddity.
+     *   - D3D has a top-left filling convention while GL does not specify
+     *     a particular behavior, other than that that the GL implementation
+     *     needs to be consistent.
+     *
+     * In order to handle the pixel center, we translate by 0.5 / VPw and
+     * 0.5 / VPh. We test the filling convention during adapter init and
+     * add a small offset to correct it if necessary. See
+     * wined3d_caps_gl_ctx_test_filling_convention() for more details on how
+     * we test GL and considerations regarding the added offset value.
+     *
+     * If we have GL_ARB_clip_control we take care of all this through
+     * viewport properties and don't have to translate geometry. */
+
+    /* Projection matrices are <= d3d9, which all have integer pixel centers. */
+    if (!(d3d_info->wined3d_creation_flags & WINED3D_PIXEL_CENTER_INTEGER))
+        ERR("Did not expect to enter this codepath without WINED3D_PIXEL_CENTER_INTEGER.\n");
+
+    clip_control = d3d_info->clip_control;
+    flip = !clip_control;
+    if (!clip_control)
+        center_offset = 1.0f + d3d_info->filling_convention_offset;
+    else
+        center_offset = 0.0f;
+
+    if (context->stream_info.position_transformed)
+    {
+        /* Transform D3D RHW coordinates to OpenGL clip coordinates. */
+        float x = state->viewports[0].x;
+        float y = state->viewports[0].y;
+        float w = state->viewports[0].width;
+        float h = state->viewports[0].height;
+        float x_scale = 2.0f / w;
+        float x_offset = (center_offset - (2.0f * x) - w) / w;
+        float y_scale = flip ? 2.0f / h : 2.0f / -h;
+        float y_offset = flip
+                ? (center_offset - (2.0f * y) - h) / h
+                : (center_offset - (2.0f * y) - h) / -h;
+        bool zenable = state->fb.depth_stencil ?
+                (state->depth_stencil_state ? state->depth_stencil_state->desc.depth : true) : false;
+        float z_scale = zenable ? clip_control ? 1.0f : 2.0f : 0.0f;
+        float z_offset = zenable ? clip_control ? 0.0f : -1.0f : 0.0f;
+        const struct wined3d_matrix projection =
+        {
+             x_scale,     0.0f,      0.0f, 0.0f,
+                0.0f,  y_scale,      0.0f, 0.0f,
+                0.0f,     0.0f,   z_scale, 0.0f,
+            x_offset, y_offset,  z_offset, 1.0f,
+        };
+
+        *mat = projection;
+    }
+    else
+    {
+        float y_scale = flip ? -1.0f : 1.0f;
+        float x_offset = center_offset / state->viewports[0].width;
+        float y_offset = flip
+                ? center_offset / state->viewports[0].height
+                : -center_offset / state->viewports[0].height;
+        float z_scale = clip_control ? 1.0f : 2.0f;
+        float z_offset = clip_control ? 0.0f : -1.0f;
+        const struct wined3d_matrix projection =
+        {
+                1.0f,     0.0f,     0.0f, 0.0f,
+                0.0f,  y_scale,     0.0f, 0.0f,
+                0.0f,     0.0f,  z_scale, 0.0f,
+            x_offset, y_offset, z_offset, 1.0f,
+        };
+
+        multiply_matrix(mat, &projection, &state->transforms[WINED3D_TS_PROJECTION]);
+    }
+}
+
 static void shader_glsl_ffp_vertex_normalmatrix_uniform(const struct wined3d_context_gl *context_gl,
         const struct wined3d_state *state, struct glsl_shader_prog_link *prog)
 {
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 495831c40e5..fb663abcb8f 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -5598,91 +5598,6 @@ void get_modelview_matrix(const struct wined3d_context *context, const struct wi
         multiply_matrix(mat, &state->transforms[WINED3D_TS_VIEW], &state->transforms[WINED3D_TS_WORLD_MATRIX(index)]);
 }
 
-void get_projection_matrix(const struct wined3d_context *context, const struct wined3d_state *state,
-        struct wined3d_matrix *mat)
-{
-    const struct wined3d_d3d_info *d3d_info = context->d3d_info;
-    BOOL clip_control, flip;
-    float center_offset;
-
-    /* There are a couple of additional things we have to take into account
-     * here besides the projection transformation itself:
-     *   - We need to flip along the y-axis in case of offscreen rendering.
-     *   - OpenGL Z range is {-Wc,...,Wc} while D3D Z range is {0,...,Wc}.
-     *   - <= D3D9 coordinates refer to pixel centers while GL coordinates
-     *     refer to pixel corners. D3D10 fixed this particular oddity.
-     *   - D3D has a top-left filling convention while GL does not specify
-     *     a particular behavior, other than that that the GL implementation
-     *     needs to be consistent.
-     *
-     * In order to handle the pixel center, we translate by 0.5 / VPw and
-     * 0.5 / VPh. We test the filling convention during adapter init and
-     * add a small offset to correct it if necessary. See
-     * wined3d_caps_gl_ctx_test_filling_convention() for more details on how
-     * we test GL and considerations regarding the added offset value.
-     *
-     * If we have GL_ARB_clip_control we take care of all this through
-     * viewport properties and don't have to translate geometry. */
-
-    /* Projection matrices are <= d3d9, which all have integer pixel centers. */
-    if (!(d3d_info->wined3d_creation_flags & WINED3D_PIXEL_CENTER_INTEGER))
-        ERR("Did not expect to enter this codepath without WINED3D_PIXEL_CENTER_INTEGER.\n");
-
-    clip_control = d3d_info->clip_control;
-    flip = !clip_control;
-    if (!clip_control)
-        center_offset = 1.0f + d3d_info->filling_convention_offset;
-    else
-        center_offset = 0.0f;
-
-    if (context->stream_info.position_transformed)
-    {
-        /* Transform D3D RHW coordinates to OpenGL clip coordinates. */
-        float x = state->viewports[0].x;
-        float y = state->viewports[0].y;
-        float w = state->viewports[0].width;
-        float h = state->viewports[0].height;
-        float x_scale = 2.0f / w;
-        float x_offset = (center_offset - (2.0f * x) - w) / w;
-        float y_scale = flip ? 2.0f / h : 2.0f / -h;
-        float y_offset = flip
-                ? (center_offset - (2.0f * y) - h) / h
-                : (center_offset - (2.0f * y) - h) / -h;
-        bool zenable = state->fb.depth_stencil ?
-                (state->depth_stencil_state ? state->depth_stencil_state->desc.depth : true) : false;
-        float z_scale = zenable ? clip_control ? 1.0f : 2.0f : 0.0f;
-        float z_offset = zenable ? clip_control ? 0.0f : -1.0f : 0.0f;
-        const struct wined3d_matrix projection =
-        {
-             x_scale,     0.0f,      0.0f, 0.0f,
-                0.0f,  y_scale,      0.0f, 0.0f,
-                0.0f,     0.0f,   z_scale, 0.0f,
-            x_offset, y_offset,  z_offset, 1.0f,
-        };
-
-        *mat = projection;
-    }
-    else
-    {
-        float y_scale = flip ? -1.0f : 1.0f;
-        float x_offset = center_offset / state->viewports[0].width;
-        float y_offset = flip
-                ? center_offset / state->viewports[0].height
-                : -center_offset / state->viewports[0].height;
-        float z_scale = clip_control ? 1.0f : 2.0f;
-        float z_offset = clip_control ? 0.0f : -1.0f;
-        const struct wined3d_matrix projection =
-        {
-                1.0f,     0.0f,     0.0f, 0.0f,
-                0.0f,  y_scale,     0.0f, 0.0f,
-                0.0f,     0.0f,  z_scale, 0.0f,
-            x_offset, y_offset, z_offset, 1.0f,
-        };
-
-        multiply_matrix(mat, &projection, &state->transforms[WINED3D_TS_PROJECTION]);
-    }
-}
-
 /* Setup this textures matrix according to the texture flags. */
 static void compute_texture_matrix(const struct wined3d_matrix *matrix, uint32_t flags, BOOL calculated_coords,
         enum wined3d_format_id format_id, struct wined3d_matrix *out_matrix)
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 7d36979b8da..693aa9efeee 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -4321,7 +4321,7 @@ static inline void shader_get_position_fixup(const struct wined3d_context *conte
     float center_offset, x = 0.0f, y = 0.0f;
     unsigned int i;
 
-    /* See get_projection_matrix() in utils.c for a discussion of the position fixup.
+    /* See get_projection_matrix() in glsl_shader.c for a discussion of the position fixup.
      * This function here also applies to d3d10+ which does not need adjustment for
      * integer pixel centers, but it may need the filling convention offset. */
     if (context->d3d_info->wined3d_creation_flags & WINED3D_PIXEL_CENTER_INTEGER)
@@ -4376,8 +4376,6 @@ static inline BOOL shader_sampler_is_shadow(const struct wined3d_shader *shader,
 void get_identity_matrix(struct wined3d_matrix *mat);
 void get_modelview_matrix(const struct wined3d_context *context, const struct wined3d_state *state,
         unsigned int index, struct wined3d_matrix *mat);
-void get_projection_matrix(const struct wined3d_context *context, const struct wined3d_state *state,
-        struct wined3d_matrix *mat);
 void get_texture_matrix(const struct wined3d_stream_info *si,
         const struct wined3d_stateblock_state *state, const unsigned int tex, struct wined3d_matrix *mat);
 void get_pointsize_minmax(const struct wined3d_context *context, const struct wined3d_state *state,
-- 
2.48.1


From a44bf43f813863ac52133d7534467735798c606e Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 9 Jun 2024 12:50:26 -0500
Subject: [PATCH 34/98] wined3d: Feed the projection matrix through a push
 constant buffer.

We cannot get rid of the WINED3D_TS_PROJECTION state handler yet, because table
fog still depends on it.
---
 dlls/wined3d/ffp_gl.c          |  4 ++--
 dlls/wined3d/glsl_shader.c     | 14 +++++++-------
 dlls/wined3d/stateblock.c      | 12 ++++++++++++
 dlls/wined3d/wined3d_private.h |  1 +
 4 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/dlls/wined3d/ffp_gl.c b/dlls/wined3d/ffp_gl.c
index 447de1b68b0..3bcd67f9c02 100644
--- a/dlls/wined3d/ffp_gl.c
+++ b/dlls/wined3d/ffp_gl.c
@@ -759,8 +759,8 @@ static void depth(struct wined3d_context *context, const struct wined3d_state *s
         }
     }
 
-    if (context->stream_info.position_transformed && !isStateDirty(context, STATE_TRANSFORM(WINED3D_TS_PROJECTION)))
-        context_apply_state(context, state, STATE_TRANSFORM(WINED3D_TS_PROJECTION));
+    if (context->stream_info.position_transformed)
+        context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_PROJ;
 }
 
 static void depth_stencil(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index e055e88103e..977e5f1ae07 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1478,7 +1478,7 @@ static void reset_program_constant_version(struct wine_rb_entry *entry, void *co
 }
 
 static void get_projection_matrix(const struct wined3d_context *context,
-        const struct wined3d_state *state, struct wined3d_matrix *mat)
+        const struct wined3d_ffp_vs_constants *constants, const struct wined3d_state *state, struct wined3d_matrix *mat)
 {
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
     bool clip_control, flip;
@@ -1558,7 +1558,7 @@ static void get_projection_matrix(const struct wined3d_context *context,
             x_offset, y_offset, z_offset, 1.0f,
         };
 
-        multiply_matrix(mat, &projection, &state->transforms[WINED3D_TS_PROJECTION]);
+        multiply_matrix(mat, &projection, &constants->projection_matrix);
     }
 }
 
@@ -1814,9 +1814,12 @@ static void shader_glsl_load_constants(struct shader_glsl_priv *priv,
 
     if (update_mask & WINED3D_SHADER_CONST_FFP_PROJ)
     {
+        const struct wined3d_ffp_vs_constants *constants;
         struct wined3d_matrix projection;
 
-        get_projection_matrix(context, state, &projection);
+        constants = wined3d_buffer_load_sysmem(context->device->push_constants[WINED3D_PUSH_CONSTANTS_VS_FFP], context);
+
+        get_projection_matrix(context, constants, state, &projection);
         GL_EXTCALL(glUniformMatrix4fv(prog->vs.projection_matrix_location, 1, FALSE, &projection._11));
         checkGLcall("glUniformMatrix4fv");
     }
@@ -11922,18 +11925,15 @@ static void glsl_vertex_pipe_projection(struct wined3d_context *context,
     if (state->render_states[WINED3D_RS_FOGENABLE]
             && state->render_states[WINED3D_RS_FOGTABLEMODE] != WINED3D_FOG_NONE)
         context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_VERTEX;
-    context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_PROJ;
 }
 
 static void glsl_vertex_pipe_viewport(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
-    if (!isStateDirty(context, STATE_TRANSFORM(WINED3D_TS_PROJECTION)))
-        glsl_vertex_pipe_projection(context, state, STATE_TRANSFORM(WINED3D_TS_PROJECTION));
     if (!isStateDirty(context, STATE_RENDER(WINED3D_RS_POINTSCALEENABLE))
             && state->render_states[WINED3D_RS_POINTSCALEENABLE])
         context->constant_update_mask |= WINED3D_SHADER_CONST_VS_POINTSIZE;
-    context->constant_update_mask |= WINED3D_SHADER_CONST_POS_FIXUP;
+    context->constant_update_mask |= WINED3D_SHADER_CONST_POS_FIXUP | WINED3D_SHADER_CONST_FFP_PROJ;
 }
 
 static void glsl_vertex_pipe_pointsize(struct wined3d_context *context,
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 0618f982315..8e638033eb0 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -2251,6 +2251,8 @@ static void wined3d_stateblock_invalidate_push_constants(struct wined3d_stateblo
     stateblock->changed.lights = 1;
     stateblock->changed.texture_matrices = 1;
     stateblock->changed.material = 1;
+    stateblock->changed.transforms = 1;
+    wined3d_bitmap_set(stateblock->changed.transform, WINED3D_TS_PROJECTION);
 }
 
 static HRESULT stateblock_init(struct wined3d_stateblock *stateblock, const struct wined3d_stateblock *device_state,
@@ -3334,6 +3336,16 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
                     changed->clipplane = wined3d_mask_from_size(WINED3D_MAX_CLIP_DISTANCES);
                 }
 
+                if (idx == WINED3D_TS_PROJECTION)
+                {
+                    wined3d_device_context_push_constants(context,
+                            WINED3D_PUSH_CONSTANTS_VS_FFP, WINED3D_SHADER_CONST_FFP_PROJ,
+                            offsetof(struct wined3d_ffp_vs_constants, projection_matrix),
+                            sizeof(state->transforms[idx]), &state->transforms[idx]);
+                    /* wined3d_ffp_vs_settings.ortho_fog still needs the
+                     * device state to be set. */
+                }
+
                 if (!(idx >= WINED3D_TS_TEXTURE0 && idx <= WINED3D_TS_TEXTURE7))
                     wined3d_device_set_transform(device, idx, &state->transforms[idx]);
             }
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 693aa9efeee..30f836f901f 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2768,6 +2768,7 @@ BOOL wined3d_get_app_name(char *app_name, unsigned int app_name_size);
 
 struct wined3d_ffp_vs_constants
 {
+    struct wined3d_matrix projection_matrix;
     struct wined3d_matrix texture_matrices[WINED3D_MAX_FFP_TEXTURES];
     struct wined3d_material material;
     struct wined3d_ffp_light_constants
-- 
2.48.1


From 6305c5abc04428387ba503775fd173af708675c3 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 9 Jun 2024 12:50:26 -0500
Subject: [PATCH 35/98] wined3d: Do not use the normal or modelview matrices
 when drawing pretransformed vertices.

---
 dlls/wined3d/glsl_shader.c     | 18 +++++++++++++-----
 dlls/wined3d/utils.c           |  8 ++------
 dlls/wined3d/wined3d_private.h |  3 +--
 3 files changed, 16 insertions(+), 13 deletions(-)

diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 977e5f1ae07..7d14ba7580d 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1572,7 +1572,7 @@ static void shader_glsl_ffp_vertex_normalmatrix_uniform(const struct wined3d_con
     if (prog->vs.normal_matrix_location == -1)
         return;
 
-    get_modelview_matrix(&context_gl->c, state, 0, &mv);
+    get_modelview_matrix(state, 0, &mv);
     compute_normal_matrix(mat, context_gl->c.d3d_info->wined3d_creation_flags & WINED3D_LEGACY_FFP_LIGHTING, &mv);
 
     GL_EXTCALL(glUniformMatrix3fv(prog->vs.normal_matrix_location, 1, FALSE, mat));
@@ -1790,7 +1790,7 @@ static void shader_glsl_load_constants(struct shader_glsl_priv *priv,
     {
         struct wined3d_matrix mat;
 
-        get_modelview_matrix(context, state, 0, &mat);
+        get_modelview_matrix(state, 0, &mat);
         GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[0], 1, FALSE, &mat._11));
         checkGLcall("glUniformMatrix4fv");
 
@@ -1806,7 +1806,7 @@ static void shader_glsl_load_constants(struct shader_glsl_priv *priv,
             if (prog->vs.modelview_matrix_location[i] == -1)
                 break;
 
-            get_modelview_matrix(context, state, i, &mat);
+            get_modelview_matrix(state, i, &mat);
             GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[i], 1, FALSE, &mat._11));
             checkGLcall("glUniformMatrix4fv");
         }
@@ -9258,12 +9258,20 @@ static GLuint shader_glsl_generate_ffp_vertex_shader(struct shader_glsl_priv *pr
     {
         if (!settings->vertexblends)
         {
-            shader_addline(buffer, "normal = ffp_normal_matrix * ffp_attrib_normal;\n");
+            if (settings->transformed)
+                shader_addline(buffer, "normal = ffp_attrib_normal;\n");
+            else
+                shader_addline(buffer, "normal = ffp_normal_matrix * ffp_attrib_normal;\n");
         }
         else
         {
             for (i = 0; i < settings->vertexblends + 1; ++i)
-                shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * (mat3(ffp_modelview_matrix[%u]) * ffp_attrib_normal);\n", i, i);
+            {
+                if (settings->transformed)
+                    shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * ffp_attrib_normal;\n", i);
+                else
+                    shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * (mat3(ffp_modelview_matrix[%u]) * ffp_attrib_normal);\n", i, i);
+            }
         }
 
         if (settings->normalize)
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index fb663abcb8f..c7f2f6dcd90 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -5589,13 +5589,9 @@ void get_identity_matrix(struct wined3d_matrix *mat)
     *mat = identity;
 }
 
-void get_modelview_matrix(const struct wined3d_context *context, const struct wined3d_state *state,
-        unsigned int index, struct wined3d_matrix *mat)
+void get_modelview_matrix(const struct wined3d_state *state, unsigned int index, struct wined3d_matrix *mat)
 {
-    if (context->stream_info.position_transformed)
-        get_identity_matrix(mat);
-    else
-        multiply_matrix(mat, &state->transforms[WINED3D_TS_VIEW], &state->transforms[WINED3D_TS_WORLD_MATRIX(index)]);
+    multiply_matrix(mat, &state->transforms[WINED3D_TS_VIEW], &state->transforms[WINED3D_TS_WORLD_MATRIX(index)]);
 }
 
 /* Setup this textures matrix according to the texture flags. */
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 30f836f901f..7979c144a6a 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -4375,8 +4375,7 @@ static inline BOOL shader_sampler_is_shadow(const struct wined3d_shader *shader,
 }
 
 void get_identity_matrix(struct wined3d_matrix *mat);
-void get_modelview_matrix(const struct wined3d_context *context, const struct wined3d_state *state,
-        unsigned int index, struct wined3d_matrix *mat);
+void get_modelview_matrix(const struct wined3d_state *state, unsigned int index, struct wined3d_matrix *mat);
 void get_texture_matrix(const struct wined3d_stream_info *si,
         const struct wined3d_stateblock_state *state, const unsigned int tex, struct wined3d_matrix *mat);
 void get_pointsize_minmax(const struct wined3d_context *context, const struct wined3d_state *state,
-- 
2.48.1


From 870d9d3e8a7a1bdb2820d0dc922eed0a668d8a96 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 9 Jun 2024 12:50:27 -0500
Subject: [PATCH 36/98] wined3d: Feed modelview matrices through a push
 constant buffer.

---
 dlls/wined3d/glsl_shader.c     | 48 ++++++++++------------------------
 dlls/wined3d/stateblock.c      | 34 +++++++++++++++++++++---
 dlls/wined3d/utils.c           |  2 +-
 dlls/wined3d/wined3d_private.h |  3 ++-
 4 files changed, 47 insertions(+), 40 deletions(-)

diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 7d14ba7580d..78926739310 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1563,17 +1563,16 @@ static void get_projection_matrix(const struct wined3d_context *context,
 }
 
 static void shader_glsl_ffp_vertex_normalmatrix_uniform(const struct wined3d_context_gl *context_gl,
-        const struct wined3d_state *state, struct glsl_shader_prog_link *prog)
+        const struct wined3d_ffp_vs_constants *constants, struct glsl_shader_prog_link *prog)
 {
     const struct wined3d_gl_info *gl_info = context_gl->gl_info;
-    struct wined3d_matrix mv;
     float mat[3 * 3];
 
     if (prog->vs.normal_matrix_location == -1)
         return;
 
-    get_modelview_matrix(state, 0, &mv);
-    compute_normal_matrix(mat, context_gl->c.d3d_info->wined3d_creation_flags & WINED3D_LEGACY_FFP_LIGHTING, &mv);
+    compute_normal_matrix(mat, context_gl->c.d3d_info->wined3d_creation_flags & WINED3D_LEGACY_FFP_LIGHTING,
+            &constants->modelview_matrices[0]);
 
     GL_EXTCALL(glUniformMatrix3fv(prog->vs.normal_matrix_location, 1, FALSE, mat));
     checkGLcall("glUniformMatrix3fv");
@@ -1788,26 +1787,30 @@ static void shader_glsl_load_constants(struct shader_glsl_priv *priv,
 
     if (update_mask & WINED3D_SHADER_CONST_FFP_MODELVIEW)
     {
-        struct wined3d_matrix mat;
+        const struct wined3d_ffp_vs_constants *constants;
 
-        get_modelview_matrix(state, 0, &mat);
-        GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[0], 1, FALSE, &mat._11));
+        constants = wined3d_buffer_load_sysmem(context->device->push_constants[WINED3D_PUSH_CONSTANTS_VS_FFP], context);
+
+        GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[0], 1,
+                FALSE, &constants->modelview_matrices[0]._11));
         checkGLcall("glUniformMatrix4fv");
 
-        shader_glsl_ffp_vertex_normalmatrix_uniform(context_gl, state, prog);
+        shader_glsl_ffp_vertex_normalmatrix_uniform(context_gl, constants, prog);
     }
 
     if (update_mask & WINED3D_SHADER_CONST_FFP_VERTEXBLEND)
     {
-        struct wined3d_matrix mat;
+        const struct wined3d_ffp_vs_constants *constants;
+
+        constants = wined3d_buffer_load_sysmem(context->device->push_constants[WINED3D_PUSH_CONSTANTS_VS_FFP], context);
 
         for (i = 1; i < MAX_VERTEX_BLENDS; ++i)
         {
             if (prog->vs.modelview_matrix_location[i] == -1)
                 break;
 
-            get_modelview_matrix(state, i, &mat);
-            GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[i], 1, FALSE, &mat._11));
+            GL_EXTCALL(glUniformMatrix4fv(prog->vs.modelview_matrix_location[i],
+                    1, FALSE, &constants->modelview_matrices[i]._11));
             checkGLcall("glUniformMatrix4fv");
         }
     }
@@ -11908,24 +11911,6 @@ static void glsl_vertex_pipe_pixel_shader(struct wined3d_context *context,
         context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_VERTEX;
 }
 
-static void glsl_vertex_pipe_world(struct wined3d_context *context,
-        const struct wined3d_state *state, DWORD state_id)
-{
-    context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_MODELVIEW;
-}
-
-static void glsl_vertex_pipe_vertexblend(struct wined3d_context *context,
-        const struct wined3d_state *state, DWORD state_id)
-{
-    context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_VERTEXBLEND;
-}
-
-static void glsl_vertex_pipe_view(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    context->constant_update_mask |= WINED3D_SHADER_CONST_FFP_MODELVIEW
-            | WINED3D_SHADER_CONST_FFP_VERTEXBLEND;
-}
-
 static void glsl_vertex_pipe_projection(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
@@ -12015,12 +12000,7 @@ static const struct wined3d_state_entry_template glsl_vertex_pipe_vp_states[] =
     /* Viewport */
     {STATE_VIEWPORT,                                             {STATE_VIEWPORT,                                             glsl_vertex_pipe_viewport}, WINED3D_GL_EXT_NONE        },
     /* Transform states */
-    {STATE_TRANSFORM(WINED3D_TS_VIEW),                           {STATE_TRANSFORM(WINED3D_TS_VIEW),                           glsl_vertex_pipe_view  }, WINED3D_GL_EXT_NONE          },
     {STATE_TRANSFORM(WINED3D_TS_PROJECTION),                     {STATE_TRANSFORM(WINED3D_TS_PROJECTION),                     glsl_vertex_pipe_projection}, WINED3D_GL_EXT_NONE      },
-    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(0)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(0)),                glsl_vertex_pipe_world }, WINED3D_GL_EXT_NONE          },
-    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(1)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(1)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
-    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(2)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(2)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
-    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(3)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(3)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
     {STATE_TEXTURESTAGE(0, WINED3D_TSS_TEXCOORD_INDEX),          {STATE_SHADER(WINED3D_SHADER_TYPE_VERTEX),                   NULL                   }, WINED3D_GL_EXT_NONE          },
     {STATE_TEXTURESTAGE(1, WINED3D_TSS_TEXCOORD_INDEX),          {STATE_SHADER(WINED3D_SHADER_TYPE_VERTEX),                   NULL                   }, WINED3D_GL_EXT_NONE          },
     {STATE_TEXTURESTAGE(2, WINED3D_TSS_TEXCOORD_INDEX),          {STATE_SHADER(WINED3D_SHADER_TYPE_VERTEX),                   NULL                   }, WINED3D_GL_EXT_NONE          },
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 8e638033eb0..d32e95e98fa 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -62,6 +62,7 @@ struct wined3d_saved_states
      * translation from stateblock formats to wined3d_state formats. */
     uint32_t ffp_ps_constants : 1;
     uint32_t texture_matrices : 1;
+    uint32_t modelview_matrices : 1;
 };
 
 struct stage_state
@@ -1580,6 +1581,10 @@ void CDECL wined3d_stateblock_set_render_state(struct wined3d_stateblock *stateb
             stateblock->changed.ffp_ps_constants = 1;
             break;
 
+        case WINED3D_RS_VERTEXBLEND:
+            stateblock->changed.modelview_matrices = 1;
+            break;
+
         default:
             break;
     }
@@ -1673,6 +1678,8 @@ void CDECL wined3d_stateblock_set_transform(struct wined3d_stateblock *statebloc
 
     if (d3dts >= WINED3D_TS_TEXTURE0 && d3dts <= WINED3D_TS_TEXTURE7)
         stateblock->changed.texture_matrices = 1;
+    else if (d3dts == WINED3D_TS_VIEW || d3dts >= WINED3D_TS_WORLD)
+        stateblock->changed.modelview_matrices = 1;
 }
 
 void CDECL wined3d_stateblock_multiply_transform(struct wined3d_stateblock *stateblock,
@@ -2252,7 +2259,8 @@ static void wined3d_stateblock_invalidate_push_constants(struct wined3d_stateblo
     stateblock->changed.texture_matrices = 1;
     stateblock->changed.material = 1;
     stateblock->changed.transforms = 1;
-    wined3d_bitmap_set(stateblock->changed.transform, WINED3D_TS_PROJECTION);
+    memset(stateblock->changed.transform, 0xff, sizeof(stateblock->changed.transform));
+    stateblock->changed.modelview_matrices = 1;
 }
 
 static HRESULT stateblock_init(struct wined3d_stateblock *stateblock, const struct wined3d_stateblock *device_state,
@@ -3344,10 +3352,8 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
                             sizeof(state->transforms[idx]), &state->transforms[idx]);
                     /* wined3d_ffp_vs_settings.ortho_fog still needs the
                      * device state to be set. */
-                }
-
-                if (!(idx >= WINED3D_TS_TEXTURE0 && idx <= WINED3D_TS_TEXTURE7))
                     wined3d_device_set_transform(device, idx, &state->transforms[idx]);
+                }
             }
         }
 
@@ -3522,6 +3528,26 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
                 offsetof(struct wined3d_ffp_vs_constants, light), sizeof(constants), &constants);
     }
 
+    if (changed->modelview_matrices)
+    {
+        struct wined3d_matrix matrices[MAX_VERTEX_BLENDS];
+
+        get_modelview_matrix(state, 0, &matrices[0]);
+        wined3d_device_context_push_constants(context,
+                WINED3D_PUSH_CONSTANTS_VS_FFP, WINED3D_SHADER_CONST_FFP_MODELVIEW,
+                offsetof(struct wined3d_ffp_vs_constants, modelview_matrices[0]), sizeof(matrices[0]), &matrices[0]);
+
+        if (state->rs[WINED3D_RS_VERTEXBLEND])
+        {
+            for (i = 1; i < MAX_VERTEX_BLENDS; ++i)
+                get_modelview_matrix(state, i, &matrices[i]);
+            wined3d_device_context_push_constants(context,
+                    WINED3D_PUSH_CONSTANTS_VS_FFP, WINED3D_SHADER_CONST_FFP_VERTEXBLEND,
+                    offsetof(struct wined3d_ffp_vs_constants, modelview_matrices[1]),
+                    sizeof(matrices) - sizeof(matrices[0]), &matrices[1]);
+        }
+    }
+
     if (changed->texture_matrices)
     {
         struct wined3d_ffp_vs_constants constants;
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index c7f2f6dcd90..20e7fd05e2c 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -5589,7 +5589,7 @@ void get_identity_matrix(struct wined3d_matrix *mat)
     *mat = identity;
 }
 
-void get_modelview_matrix(const struct wined3d_state *state, unsigned int index, struct wined3d_matrix *mat)
+void get_modelview_matrix(const struct wined3d_stateblock_state *state, unsigned int index, struct wined3d_matrix *mat)
 {
     multiply_matrix(mat, &state->transforms[WINED3D_TS_VIEW], &state->transforms[WINED3D_TS_WORLD_MATRIX(index)]);
 }
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 7979c144a6a..191894bf95a 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -2768,6 +2768,7 @@ BOOL wined3d_get_app_name(char *app_name, unsigned int app_name_size);
 
 struct wined3d_ffp_vs_constants
 {
+    struct wined3d_matrix modelview_matrices[MAX_VERTEX_BLENDS];
     struct wined3d_matrix projection_matrix;
     struct wined3d_matrix texture_matrices[WINED3D_MAX_FFP_TEXTURES];
     struct wined3d_material material;
@@ -4375,7 +4376,7 @@ static inline BOOL shader_sampler_is_shadow(const struct wined3d_shader *shader,
 }
 
 void get_identity_matrix(struct wined3d_matrix *mat);
-void get_modelview_matrix(const struct wined3d_state *state, unsigned int index, struct wined3d_matrix *mat);
+void get_modelview_matrix(const struct wined3d_stateblock_state *state, unsigned int index, struct wined3d_matrix *mat);
 void get_texture_matrix(const struct wined3d_stream_info *si,
         const struct wined3d_stateblock_state *state, const unsigned int tex, struct wined3d_matrix *mat);
 void get_pointsize_minmax(const struct wined3d_context *context, const struct wined3d_state *state,
-- 
2.48.1


From 8b1e784fa5b672633087840ff1606a7b2f68cf16 Mon Sep 17 00:00:00 2001
From: Esme Povirk <esme@codeweavers.com>
Date: Wed, 24 Jul 2024 21:03:16 +0000
Subject: [PATCH 37/98] comctl32: Handle WM_GETOBJECT in tab control.

---
 dlls/comctl32/tab.c       |  5 +++++
 dlls/comctl32/tests/tab.c | 15 +++++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/dlls/comctl32/tab.c b/dlls/comctl32/tab.c
index b0d645bddd4..887682196bc 100644
--- a/dlls/comctl32/tab.c
+++ b/dlls/comctl32/tab.c
@@ -3368,6 +3368,11 @@ TAB_WindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     case TCM_SETEXTENDEDSTYLE:
       return TAB_SetExtendedStyle (infoPtr, wParam, lParam);
 
+    case WM_GETOBJECT:
+      if ((LONG)lParam == OBJID_QUERYCLASSNAMEIDX)
+        return 0x1000f;
+      break;
+
     case WM_GETFONT:
       return TAB_GetFont (infoPtr);
 
diff --git a/dlls/comctl32/tests/tab.c b/dlls/comctl32/tests/tab.c
index 6d38baae8a6..2e6767a06d5 100644
--- a/dlls/comctl32/tests/tab.c
+++ b/dlls/comctl32/tests/tab.c
@@ -1621,6 +1621,20 @@ static void test_TCM_GETROWCOUNT(void)
     DestroyWindow(hTab);
 }
 
+static void test_WM_GETOBJECT(void)
+{
+    HWND hTab;
+    DWORD objid;
+
+    hTab = createFilledTabControl(parent_wnd, TCS_FIXEDWIDTH, TCIF_TEXT|TCIF_IMAGE, 2);
+    ok(hTab != NULL, "Failed to create tab control\n");
+
+    objid = SendMessageA(hTab, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX);
+    ok(objid == 0x1000f, "Unexpected objid %lu.\n", objid);
+
+    DestroyWindow(hTab);
+}
+
 START_TEST(tab)
 {
     LOGFONTA logfont;
@@ -1660,6 +1674,7 @@ START_TEST(tab)
     test_create();
     test_TCN_SELCHANGING();
     test_TCM_GETROWCOUNT();
+    test_WM_GETOBJECT();
 
     uninit_winevent_hook();
 
-- 
2.48.1


From 6136e9b3ed813446d36d14ba0cc24ffc05b2e314 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 38/98] mshtml: Use dispex_index_prop_desc for
 HTMLElementCollection.

---
 dlls/mshtml/htmldoc.c             | 18 +++++++-------
 dlls/mshtml/htmlelem.c            |  8 +++----
 dlls/mshtml/htmlelemcol.c         | 39 +++++++++----------------------
 dlls/mshtml/htmlform.c            |  2 +-
 dlls/mshtml/htmltable.c           |  6 ++---
 dlls/mshtml/mshtml_private.h      |  4 ++--
 dlls/mshtml/tests/documentmode.js |  2 +-
 7 files changed, 31 insertions(+), 48 deletions(-)

diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index eaf3b352006..57851f20b52 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -491,7 +491,7 @@ static HRESULT WINAPI HTMLDocument_get_images(IHTMLDocument2 *iface, IHTMLElemen
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -528,7 +528,7 @@ static HRESULT WINAPI HTMLDocument_get_applets(IHTMLDocument2 *iface, IHTMLEleme
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -565,7 +565,7 @@ static HRESULT WINAPI HTMLDocument_get_links(IHTMLDocument2 *iface, IHTMLElement
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -602,7 +602,7 @@ static HRESULT WINAPI HTMLDocument_get_forms(IHTMLDocument2 *iface, IHTMLElement
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -639,7 +639,7 @@ static HRESULT WINAPI HTMLDocument_get_anchors(IHTMLDocument2 *iface, IHTMLEleme
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -729,7 +729,7 @@ static HRESULT WINAPI HTMLDocument_get_scripts(IHTMLDocument2 *iface, IHTMLEleme
     }
 
     if(nscoll) {
-        *p = create_collection_from_htmlcol(nscoll, This->document_mode);
+        *p = create_collection_from_htmlcol(nscoll, &This->node.event_target.dispex);
         nsIDOMHTMLCollection_Release(nscoll);
     }
 
@@ -2601,7 +2601,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByName(IHTMLDocument3 *iface, BST
         return E_FAIL;
     }
 
-    *ppelColl = create_collection_from_nodelist(node_list, This->document_mode);
+    *ppelColl = create_collection_from_nodelist(node_list, &This->node.event_target.dispex);
     nsIDOMNodeList_Release(node_list);
     return S_OK;
 }
@@ -2678,7 +2678,7 @@ static HRESULT WINAPI HTMLDocument3_getElementsByTagName(IHTMLDocument3 *iface,
     }
 
 
-    *pelColl = create_collection_from_nodelist(nslist, This->document_mode);
+    *pelColl = create_collection_from_nodelist(nslist, &This->node.event_target.dispex);
     nsIDOMNodeList_Release(nslist);
 
     return S_OK;
@@ -3487,7 +3487,7 @@ static HRESULT WINAPI HTMLDocument7_getElementsByClassName(IHTMLDocument7 *iface
     }
 
 
-    *pel = create_collection_from_nodelist(nslist, This->document_mode);
+    *pel = create_collection_from_nodelist(nslist, &This->node.event_target.dispex);
     nsIDOMNodeList_Release(nslist);
     return S_OK;
 }
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index bc140b14984..24ecf145752 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -2611,7 +2611,7 @@ static HRESULT WINAPI HTMLElement_get_children(IHTMLElement *iface, IDispatch **
         return E_FAIL;
     }
 
-    *p = (IDispatch*)create_collection_from_nodelist(nsnode_list, This->node.doc->document_mode);
+    *p = (IDispatch*)create_collection_from_nodelist(nsnode_list, &This->node.event_target.dispex);
 
     nsIDOMNodeList_Release(nsnode_list);
     return S_OK;
@@ -3792,7 +3792,7 @@ static HRESULT WINAPI HTMLElement2_getElementsByTagName(IHTMLElement2 *iface, BS
     TRACE("(%p)->(%s %p)\n", This, debugstr_w(v), pelColl);
 
     if(!This->dom_element) {
-        *pelColl = create_collection_from_htmlcol(NULL, This->node.doc->document_mode);
+        *pelColl = create_collection_from_htmlcol(NULL, &This->node.event_target.dispex);
         return S_OK;
     }
 
@@ -3804,7 +3804,7 @@ static HRESULT WINAPI HTMLElement2_getElementsByTagName(IHTMLElement2 *iface, BS
         return E_FAIL;
     }
 
-    *pelColl = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->node.event_target.dispex));
+    *pelColl = create_collection_from_htmlcol(nscol, &This->node.event_target.dispex);
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
 }
@@ -4820,7 +4820,7 @@ static HRESULT WINAPI HTMLElement6_getElementsByClassName(IHTMLElement6 *iface,
         }
     }
 
-    *pel = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->node.event_target.dispex));
+    *pel = create_collection_from_htmlcol(nscol, &This->node.event_target.dispex);
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
 }
diff --git a/dlls/mshtml/htmlelemcol.c b/dlls/mshtml/htmlelemcol.c
index a264813f9bb..625af9781b8 100644
--- a/dlls/mshtml/htmlelemcol.c
+++ b/dlls/mshtml/htmlelemcol.c
@@ -60,7 +60,7 @@ static inline HTMLElement *elem_from_HTMLDOMNode(HTMLDOMNode *iface)
     return CONTAINING_RECORD(iface, HTMLElement, node);
 }
 
-static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement**,DWORD,compat_mode_t);
+static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement**,DWORD,DispatchEx*);
 
 static void elem_vector_add(elem_vector_t *buf, HTMLElement *elem)
 {
@@ -377,8 +377,7 @@ static HRESULT WINAPI HTMLElementCollection_item(IHTMLElementCollection *iface,
 
             if(buf.len > 1) {
                 elem_vector_normalize(&buf);
-                *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len,
-                                                                  dispex_compat_mode(&This->dispex));
+                *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len, &This->dispex);
             }else {
                 if(buf.len == 1) {
                     /* Already AddRef-ed */
@@ -440,8 +439,7 @@ static HRESULT WINAPI HTMLElementCollection_tags(IHTMLElementCollection *iface,
 
     TRACE("found %ld tags\n", buf.len);
 
-    *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len,
-                                                      dispex_compat_mode(&This->dispex));
+    *pdisp = (IDispatch*)HTMLElementCollection_Create(buf.buf, buf.len, &This->dispex);
     return S_OK;
 }
 
@@ -535,20 +533,6 @@ static HRESULT HTMLElementCollection_get_dispid(DispatchEx *dispex, const WCHAR
     return S_OK;
 }
 
-static HRESULT HTMLElementCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLElementCollection *This = impl_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    WCHAR buf[11];
-    UINT len;
-
-    if(idx >= This->len)
-        return DISP_E_MEMBERNOTFOUND;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLElementCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -581,7 +565,7 @@ static const dispex_static_data_vtbl_t HTMLElementColection_dispex_vtbl = {
     .traverse         = HTMLElementCollection_traverse,
     .unlink           = HTMLElementCollection_unlink,
     .get_dispid       = HTMLElementCollection_get_dispid,
-    .get_name         = HTMLElementCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLElementCollection_invoke,
 };
 
@@ -653,11 +637,10 @@ IHTMLElementCollection *create_all_collection(HTMLDOMNode *node, BOOL include_ro
     create_all_list(node, &buf);
     elem_vector_normalize(&buf);
 
-    return HTMLElementCollection_Create(buf.buf, buf.len,
-                                        dispex_compat_mode(&node->event_target.dispex));
+    return HTMLElementCollection_Create(buf.buf, buf.len, &node->event_target.dispex);
 }
 
-IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist, compat_mode_t compat_mode)
+IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist, DispatchEx *owner)
 {
     UINT32 length = 0, i;
     HTMLDOMNode *node;
@@ -689,10 +672,10 @@ IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList *nslist,
         buf.buf = NULL;
     }
 
-    return HTMLElementCollection_Create(buf.buf, buf.len, compat_mode);
+    return HTMLElementCollection_Create(buf.buf, buf.len, owner);
 }
 
-IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nscol, compat_mode_t compat_mode)
+IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nscol, DispatchEx *owner)
 {
     UINT32 length = 0, i;
     elem_vector_t buf;
@@ -725,7 +708,7 @@ IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection *nsc
         return NULL;
     }
 
-    return HTMLElementCollection_Create(buf.buf, buf.len, compat_mode);
+    return HTMLElementCollection_Create(buf.buf, buf.len, owner);
 }
 
 HRESULT get_elem_source_index(HTMLElement *elem, LONG *ret)
@@ -801,7 +784,7 @@ HRESULT get_elem_source_index(HTMLElement *elem, LONG *ret)
 }
 
 static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement **elems, DWORD len,
-                                                            compat_mode_t compat_mode)
+                                                            DispatchEx *owner)
 {
     HTMLElementCollection *ret = calloc(1, sizeof(HTMLElementCollection));
 
@@ -812,7 +795,7 @@ static IHTMLElementCollection *HTMLElementCollection_Create(HTMLElement **elems,
     ret->elems = elems;
     ret->len = len;
 
-    init_dispatch(&ret->dispex, &HTMLElementCollection_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&ret->dispex, &HTMLElementCollection_dispex, owner);
 
     TRACE("ret=%p len=%ld\n", ret, len);
 
diff --git a/dlls/mshtml/htmlform.c b/dlls/mshtml/htmlform.c
index a6a4bc0bce9..80a8d706054 100644
--- a/dlls/mshtml/htmlform.c
+++ b/dlls/mshtml/htmlform.c
@@ -401,7 +401,7 @@ static HRESULT WINAPI HTMLFormElement_get_elements(IHTMLFormElement *iface, IDis
         return E_FAIL;
     }
 
-    *p = (IDispatch*)create_collection_from_htmlcol(elements, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = (IDispatch*)create_collection_from_htmlcol(elements, &This->element.node.event_target.dispex);
     nsIDOMHTMLCollection_Release(elements);
     return S_OK;
 }
diff --git a/dlls/mshtml/htmltable.c b/dlls/mshtml/htmltable.c
index 6c2d72cdcea..19d03387539 100644
--- a/dlls/mshtml/htmltable.c
+++ b/dlls/mshtml/htmltable.c
@@ -693,7 +693,7 @@ static HRESULT WINAPI HTMLTableRow_get_cells(IHTMLTableRow *iface, IHTMLElementC
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, &This->element.node.event_target.dispex);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
@@ -1224,7 +1224,7 @@ static HRESULT WINAPI HTMLTable_get_rows(IHTMLTable *iface, IHTMLElementCollecti
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, &This->element.node.event_target.dispex);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
@@ -1339,7 +1339,7 @@ static HRESULT WINAPI HTMLTable_get_tBodies(IHTMLTable *iface, IHTMLElementColle
         return E_FAIL;
     }
 
-    *p = create_collection_from_htmlcol(nscol, dispex_compat_mode(&This->element.node.event_target.dispex));
+    *p = create_collection_from_htmlcol(nscol, &This->element.node.event_target.dispex);
 
     nsIDOMHTMLCollection_Release(nscol);
     return S_OK;
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index d48ba2f32ac..f245acc8d75 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1300,8 +1300,8 @@ ULONG WINAPI wrapper_Release(IUnknown *iface);
 extern const void *iface_wrapper_vtbl[];
 
 IHTMLElementCollection *create_all_collection(HTMLDOMNode*,BOOL);
-IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList*,compat_mode_t);
-IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection*,compat_mode_t);
+IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList*,DispatchEx*);
+IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection*,DispatchEx*);
 HRESULT create_child_collection(nsIDOMNodeList*,compat_mode_t,IHTMLDOMChildrenCollection**);
 
 HRESULT attr_value_to_string(VARIANT*);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 1586a7d5a4f..e676197d728 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -297,7 +297,7 @@ sync_test("builtin_toString", function() {
     if(clientRects) test("clientRects", clientRects, "ClientRectList");
     if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties", null, true);
     if(v >= 11 /* todo_wine */) test("document", document, v < 11 ? "Document" : "HTMLDocument");
-    test("elements", document.getElementsByTagName("body"), "HTMLCollection", null, true);
+    test("elements", document.getElementsByTagName("body"), "HTMLCollection");
     test("history", window.history, "History");
     test("implementation", document.implementation, "DOMImplementation");
     if(localStorage) test("localStorage", localStorage, "Storage");
-- 
2.48.1


From 4abbf0775c65dcb4603537e4f673e2dc8a0b512f Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 39/98] mshtml: Use host object script bindings for
 HTMLDOMChildrenCollection.

---
 dlls/mshtml/htmldoc.c             |  2 +-
 dlls/mshtml/htmlelem.c            |  2 +-
 dlls/mshtml/htmlnode.c            | 23 ++++-------------------
 dlls/mshtml/mshtml_private.h      |  2 +-
 dlls/mshtml/tests/documentmode.js |  2 +-
 5 files changed, 8 insertions(+), 23 deletions(-)

diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 57851f20b52..2c92b6e3d8f 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -4447,7 +4447,7 @@ static HRESULT WINAPI DocumentSelector_querySelectorAll(IDocumentSelector *iface
         return map_nsresult(nsres);
     }
 
-    hres = create_child_collection(node_list, dispex_compat_mode(&This->node.event_target.dispex), pel);
+    hres = create_child_collection(node_list, &This->node.event_target.dispex, pel);
     nsIDOMNodeList_Release(node_list);
     return hres;
 }
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 24ecf145752..f6be9c8d35e 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -5964,7 +5964,7 @@ static HRESULT WINAPI ElementSelector_querySelectorAll(IElementSelector *iface,
         return map_nsresult(nsres);
     }
 
-    hres = create_child_collection(node_list, dispex_compat_mode(&This->node.event_target.dispex), pel);
+    hres = create_child_collection(node_list, &This->node.event_target.dispex, pel);
     nsIDOMNodeList_Release(node_list);
     return hres;
 }
diff --git a/dlls/mshtml/htmlnode.c b/dlls/mshtml/htmlnode.c
index 3123e9dd72e..8f9de03fd93 100644
--- a/dlls/mshtml/htmlnode.c
+++ b/dlls/mshtml/htmlnode.c
@@ -338,21 +338,6 @@ static HRESULT HTMLDOMChildrenCollection_get_dispid(DispatchEx *dispex, const WC
     return S_OK;
 }
 
-static HRESULT HTMLDOMChildrenCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLDOMChildrenCollection *This = impl_from_DispatchEx(dispex);
-    DWORD idx = id - DISPID_CHILDCOL_0;
-    UINT32 len = 0;
-    WCHAR buf[11];
-
-    nsIDOMNodeList_GetLength(This->nslist, &len);
-    if(idx >= len)
-        return DISP_E_MEMBERNOTFOUND;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLDOMChildrenCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -389,7 +374,7 @@ static const dispex_static_data_vtbl_t HTMLDOMChildrenCollection_dispex_vtbl = {
     .traverse         = HTMLDOMChildrenCollection_traverse,
     .unlink           = HTMLDOMChildrenCollection_unlink,
     .get_dispid       = HTMLDOMChildrenCollection_get_dispid,
-    .get_name         = HTMLDOMChildrenCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLDOMChildrenCollection_invoke,
 };
 
@@ -406,7 +391,7 @@ static dispex_static_data_t HTMLDOMChildrenCollection_dispex = {
     HTMLDOMNode_init_dispex_info
 };
 
-HRESULT create_child_collection(nsIDOMNodeList *nslist, compat_mode_t compat_mode, IHTMLDOMChildrenCollection **ret)
+HRESULT create_child_collection(nsIDOMNodeList *nslist, DispatchEx *owner, IHTMLDOMChildrenCollection **ret)
 {
     HTMLDOMChildrenCollection *collection;
 
@@ -418,7 +403,7 @@ HRESULT create_child_collection(nsIDOMNodeList *nslist, compat_mode_t compat_mod
     nsIDOMNodeList_AddRef(nslist);
     collection->nslist = nslist;
 
-    init_dispatch(&collection->dispex, &HTMLDOMChildrenCollection_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&collection->dispex, &HTMLDOMChildrenCollection_dispex, owner);
 
     *ret = &collection->IHTMLDOMChildrenCollection_iface;
     return S_OK;
@@ -530,7 +515,7 @@ static HRESULT WINAPI HTMLDOMNode_get_childNodes(IHTMLDOMNode *iface, IDispatch
         return hres;
     }
 
-    hres = create_child_collection(nslist, dispex_compat_mode(&This->event_target.dispex),
+    hres = create_child_collection(nslist, &This->event_target.dispex,
                                    (IHTMLDOMChildrenCollection**)p);
     nsIDOMNodeList_Release(nslist);
     return hres;
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index f245acc8d75..1f6119eb339 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1302,7 +1302,7 @@ extern const void *iface_wrapper_vtbl[];
 IHTMLElementCollection *create_all_collection(HTMLDOMNode*,BOOL);
 IHTMLElementCollection *create_collection_from_nodelist(nsIDOMNodeList*,DispatchEx*);
 IHTMLElementCollection *create_collection_from_htmlcol(nsIDOMHTMLCollection*,DispatchEx*);
-HRESULT create_child_collection(nsIDOMNodeList*,compat_mode_t,IHTMLDOMChildrenCollection**);
+HRESULT create_child_collection(nsIDOMNodeList*,DispatchEx*,IHTMLDOMChildrenCollection**);
 
 HRESULT attr_value_to_string(VARIANT*);
 HRESULT get_elem_attr_value_by_dispid(HTMLElement*,DISPID,VARIANT*);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index e676197d728..f529743d606 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -292,7 +292,7 @@ sync_test("builtin_toString", function() {
 
     test("attribute", document.createAttribute("class"), "Attr");
     if(false /* todo_wine */) test("attributes", e.attributes, "NamedNodeMap");
-    test("childNodes", document.body.childNodes, "NodeList", null, true);
+    test("childNodes", document.body.childNodes, "NodeList");
     if(clientRects) test("clientRect", clientRects[0], "ClientRect");
     if(clientRects) test("clientRects", clientRects, "ClientRectList");
     if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties", null, true);
-- 
2.48.1


From c08e2c887b1f66ba03558d9c9188b2bf86c5b309 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 40/98] mshtml: Use host object script bindings for
 HTMLStyleSheetsCollection.

---
 dlls/mshtml/htmldoc.c             |  3 +--
 dlls/mshtml/htmlstylesheet.c      | 22 ++++------------------
 dlls/mshtml/mshtml_private.h      |  2 +-
 dlls/mshtml/tests/documentmode.js |  2 +-
 4 files changed, 7 insertions(+), 22 deletions(-)

diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 2c92b6e3d8f..537daeff6fa 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -1934,8 +1934,7 @@ static HRESULT WINAPI HTMLDocument_get_styleSheets(IHTMLDocument2 *iface,
         return map_nsresult(nsres);
     }
 
-    hres = create_style_sheet_collection(nsstylelist,
-                                         dispex_compat_mode(&This->node.event_target.dispex), p);
+    hres = create_style_sheet_collection(nsstylelist, This, p);
     nsIDOMStyleSheetList_Release(nsstylelist);
     return hres;
 }
diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index 1e8982ee098..9965b55dc79 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -690,21 +690,6 @@ static HRESULT HTMLStyleSheetsCollection_get_dispid(DispatchEx *dispex, const WC
     return S_OK;
 }
 
-static HRESULT HTMLStyleSheetsCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLStyleSheetsCollection *This = HTMLStyleSheetsCollection_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    UINT32 len = 0;
-    WCHAR buf[11];
-
-    nsIDOMStyleSheetList_GetLength(This->nslist, &len);
-    if(idx >= len)
-        return DISP_E_MEMBERNOTFOUND;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLStyleSheetsCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -751,7 +736,7 @@ static const dispex_static_data_vtbl_t HTMLStyleSheetsCollection_dispex_vtbl = {
     .traverse         = HTMLStyleSheetsCollection_traverse,
     .unlink           = HTMLStyleSheetsCollection_unlink,
     .get_dispid       = HTMLStyleSheetsCollection_get_dispid,
-    .get_name         = HTMLStyleSheetsCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLStyleSheetsCollection_invoke
 };
 static const tid_t HTMLStyleSheetsCollection_iface_tids[] = {
@@ -765,7 +750,7 @@ static dispex_static_data_t HTMLStyleSheetsCollection_dispex = {
     HTMLStyleSheetsCollection_iface_tids
 };
 
-HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, compat_mode_t compat_mode,
+HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, HTMLDocumentNode *doc,
                                       IHTMLStyleSheetsCollection **ret)
 {
     HTMLStyleSheetsCollection *collection;
@@ -779,7 +764,8 @@ HRESULT create_style_sheet_collection(nsIDOMStyleSheetList *nslist, compat_mode_
         nsIDOMStyleSheetList_AddRef(nslist);
     collection->nslist = nslist;
 
-    init_dispatch(&collection->dispex, &HTMLStyleSheetsCollection_dispex, NULL, compat_mode);
+    init_dispatch(&collection->dispex, &HTMLStyleSheetsCollection_dispex, doc->script_global,
+                  dispex_compat_mode(&doc->node.event_target.dispex));
 
     *ret = &collection->IHTMLStyleSheetsCollection_iface;
     return S_OK;
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 1f6119eb339..96d7d590d36 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1176,7 +1176,7 @@ HRESULT get_readystate_string(READYSTATE,BSTR*);
 HRESULT HTMLSelectionObject_Create(HTMLDocumentNode*,nsISelection*,IHTMLSelectionObject**);
 HRESULT HTMLTxtRange_Create(HTMLDocumentNode*,nsIDOMRange*,IHTMLTxtRange**);
 HRESULT create_style_sheet(nsIDOMStyleSheet*,compat_mode_t,IHTMLStyleSheet**);
-HRESULT create_style_sheet_collection(nsIDOMStyleSheetList*,compat_mode_t,
+HRESULT create_style_sheet_collection(nsIDOMStyleSheetList*,HTMLDocumentNode*,
                                       IHTMLStyleSheetsCollection**);
 HRESULT create_dom_range(nsIDOMRange*,HTMLDocumentNode*,IHTMLDOMRange**);
 HRESULT create_markup_pointer(IMarkupPointer**);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index f529743d606..56e6239f3f3 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -314,7 +314,7 @@ sync_test("builtin_toString", function() {
     test("styleSheet", sheet, "CSSStyleSheet", null, true);
     test("styleSheetRule", sheet.rules[0], "CSSStyleRule", null, true);
     test("styleSheetRules", sheet.rules, "MSCSSRuleList", null, true);
-    test("styleSheets", document.styleSheets, "StyleSheetList", null, true);
+    test("styleSheets", document.styleSheets, "StyleSheetList");
     test("textNode", document.createTextNode("testNode"), "Text", v < 9 ? "testNode" : null);
     test("textRange", txtRange, "TextRange");
     test("window", window, "Window", "[object Window]");
-- 
2.48.1


From 644b5a2735ffdc3c090acadb8b255c67ec5ea5ee Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 41/98] mshtml: Use host object script bindings for
 HTMLStyleSheet.

---
 dlls/mshtml/htmldoc.c             | 3 +--
 dlls/mshtml/htmlstyleelem.c       | 3 +--
 dlls/mshtml/htmlstylesheet.c      | 8 ++++----
 dlls/mshtml/mshtml_private.h      | 2 +-
 dlls/mshtml/tests/documentmode.js | 2 +-
 5 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 537daeff6fa..31d879de837 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -2003,8 +2003,7 @@ static HRESULT WINAPI HTMLDocument_createStyleSheet(IHTMLDocument2 *iface, BSTR
 
     if(bstrHref && *bstrHref) {
         FIXME("semi-stub for href %s\n", debugstr_w(bstrHref));
-        return create_style_sheet(NULL, dispex_compat_mode(&This->node.event_target.dispex),
-                                  ppnewStyleSheet);
+        return create_style_sheet(NULL, &This->node.event_target.dispex, ppnewStyleSheet);
     }
 
     hres = create_element(This, L"style", &elem);
diff --git a/dlls/mshtml/htmlstyleelem.c b/dlls/mshtml/htmlstyleelem.c
index af5831dd85a..3d23bff5da8 100644
--- a/dlls/mshtml/htmlstyleelem.c
+++ b/dlls/mshtml/htmlstyleelem.c
@@ -150,8 +150,7 @@ static HRESULT WINAPI HTMLStyleElement_get_styleSheet(IHTMLStyleElement *iface,
         assert(nsres == NS_OK);
 
         if(ss) {
-            HRESULT hres = create_style_sheet(ss, dispex_compat_mode(&This->element.node.event_target.dispex),
-                                              &This->style_sheet);
+            HRESULT hres = create_style_sheet(ss, &This->element.node.event_target.dispex, &This->style_sheet);
             nsIDOMStyleSheet_Release(ss);
             if(FAILED(hres))
                 return hres;
diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index 9965b55dc79..cf35d97f0ac 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -601,7 +601,7 @@ static HRESULT WINAPI HTMLStyleSheetsCollection_item(IHTMLStyleSheetsCollection
             return E_INVALIDARG;
         }
 
-        hres = create_style_sheet(nsstylesheet, dispex_compat_mode(&This->dispex), &stylesheet);
+        hres = create_style_sheet(nsstylesheet, &This->dispex, &stylesheet);
         nsIDOMStyleSheet_Release(nsstylesheet);
         if(FAILED(hres))
             return hres;
@@ -712,7 +712,7 @@ static HRESULT HTMLStyleSheetsCollection_invoke(DispatchEx *dispex, DISPID id, L
             return S_OK;
         }
 
-        hres = create_style_sheet(nsstylesheet, dispex_compat_mode(&This->dispex), &stylesheet);
+        hres = create_style_sheet(nsstylesheet, &This->dispex, &stylesheet);
         nsIDOMStyleSheet_Release(nsstylesheet);
         if(FAILED(hres))
             return hres;
@@ -1234,7 +1234,7 @@ static dispex_static_data_t HTMLStyleSheet_dispex = {
     HTMLStyleSheet_init_dispex_info
 };
 
-HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, compat_mode_t compat_mode, IHTMLStyleSheet **ret)
+HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, DispatchEx *owner, IHTMLStyleSheet **ret)
 {
     HTMLStyleSheet *style_sheet;
     nsresult nsres;
@@ -1246,7 +1246,7 @@ HRESULT create_style_sheet(nsIDOMStyleSheet *nsstylesheet, compat_mode_t compat_
     style_sheet->IHTMLStyleSheet4_iface.lpVtbl = &HTMLStyleSheet4Vtbl;
     style_sheet->nsstylesheet = NULL;
 
-    init_dispatch(&style_sheet->dispex, &HTMLStyleSheet_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&style_sheet->dispex, &HTMLStyleSheet_dispex, owner);
 
     if(nsstylesheet) {
         nsres = nsIDOMStyleSheet_QueryInterface(nsstylesheet, &IID_nsIDOMCSSStyleSheet,
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 96d7d590d36..b130575418f 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -1175,7 +1175,7 @@ HRESULT get_readystate_string(READYSTATE,BSTR*);
 
 HRESULT HTMLSelectionObject_Create(HTMLDocumentNode*,nsISelection*,IHTMLSelectionObject**);
 HRESULT HTMLTxtRange_Create(HTMLDocumentNode*,nsIDOMRange*,IHTMLTxtRange**);
-HRESULT create_style_sheet(nsIDOMStyleSheet*,compat_mode_t,IHTMLStyleSheet**);
+HRESULT create_style_sheet(nsIDOMStyleSheet*,DispatchEx*,IHTMLStyleSheet**);
 HRESULT create_style_sheet_collection(nsIDOMStyleSheetList*,HTMLDocumentNode*,
                                       IHTMLStyleSheetsCollection**);
 HRESULT create_dom_range(nsIDOMRange*,HTMLDocumentNode*,IHTMLDOMRange**);
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 56e6239f3f3..a52df385523 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -311,7 +311,7 @@ sync_test("builtin_toString", function() {
     test("screen", window.screen, "Screen");
     test("sessionStorage", window.sessionStorage, "Storage");
     test("style", document.body.style, "MSStyleCSSProperties", null, true);
-    test("styleSheet", sheet, "CSSStyleSheet", null, true);
+    test("styleSheet", sheet, "CSSStyleSheet");
     test("styleSheetRule", sheet.rules[0], "CSSStyleRule", null, true);
     test("styleSheetRules", sheet.rules, "MSCSSRuleList", null, true);
     test("styleSheets", document.styleSheets, "StyleSheetList");
-- 
2.48.1


From e30fef7f18783f17915fce37765aa9705ff125b8 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 42/98] mshtml: Use host object script bindings for
 HTMLStyleSheetRulesCollection.

---
 dlls/mshtml/htmlstylesheet.c      | 23 ++++-------------------
 dlls/mshtml/tests/documentmode.js |  2 +-
 2 files changed, 5 insertions(+), 20 deletions(-)

diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index cf35d97f0ac..68de7e57526 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -313,21 +313,6 @@ static HRESULT HTMLStyleSheetRulesCollection_get_dispid(DispatchEx *dispex, cons
     return S_OK;
 }
 
-static HRESULT HTMLStyleSheetRulesCollection_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
-{
-    HTMLStyleSheetRulesCollection *This = HTMLStyleSheetRulesCollection_from_DispatchEx(dispex);
-    DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
-    UINT32 len = 0;
-    WCHAR buf[11];
-
-    nsIDOMCSSRuleList_GetLength(This->nslist, &len);
-    if(idx >= len)
-        return DISP_E_MEMBERNOTFOUND;
-
-    len = swprintf(buf, ARRAY_SIZE(buf), L"%u", idx);
-    return (*name = SysAllocStringLen(buf, len)) ? S_OK : E_OUTOFMEMORY;
-}
-
 static HRESULT HTMLStyleSheetRulesCollection_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
         VARIANT *res, EXCEPINFO *ei, IServiceProvider *caller)
 {
@@ -374,7 +359,7 @@ static const dispex_static_data_vtbl_t HTMLStyleSheetRulesCollection_dispex_vtbl
     .traverse         = HTMLStyleSheetRulesCollection_traverse,
     .unlink           = HTMLStyleSheetRulesCollection_unlink,
     .get_dispid       = HTMLStyleSheetRulesCollection_get_dispid,
-    .get_name         = HTMLStyleSheetRulesCollection_get_name,
+    .get_prop_desc    = dispex_index_prop_desc,
     .invoke           = HTMLStyleSheetRulesCollection_invoke
 };
 static const tid_t HTMLStyleSheetRulesCollection_iface_tids[] = {
@@ -388,7 +373,7 @@ static dispex_static_data_t HTMLStyleSheetRulesCollection_dispex = {
     HTMLStyleSheetRulesCollection_iface_tids
 };
 
-static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, compat_mode_t compat_mode,
+static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, DispatchEx *owner,
                                                    IHTMLStyleSheetRulesCollection **ret)
 {
     HTMLStyleSheetRulesCollection *collection;
@@ -399,7 +384,7 @@ static HRESULT create_style_sheet_rules_collection(nsIDOMCSSRuleList *nslist, co
     collection->IHTMLStyleSheetRulesCollection_iface.lpVtbl = &HTMLStyleSheetRulesCollectionVtbl;
     collection->nslist = nslist;
 
-    init_dispatch(&collection->dispex, &HTMLStyleSheetRulesCollection_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&collection->dispex, &HTMLStyleSheetRulesCollection_dispex, owner);
 
     if(nslist)
         nsIDOMCSSRuleList_AddRef(nslist);
@@ -1032,7 +1017,7 @@ static HRESULT WINAPI HTMLStyleSheet_get_rules(IHTMLStyleSheet *iface,
         return E_FAIL;
     }
 
-    hres = create_style_sheet_rules_collection(nslist, dispex_compat_mode(&This->dispex), p);
+    hres = create_style_sheet_rules_collection(nslist, &This->dispex, p);
     nsIDOMCSSRuleList_Release(nslist);
     return hres;
 }
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index a52df385523..ba27db9f832 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -313,7 +313,7 @@ sync_test("builtin_toString", function() {
     test("style", document.body.style, "MSStyleCSSProperties", null, true);
     test("styleSheet", sheet, "CSSStyleSheet");
     test("styleSheetRule", sheet.rules[0], "CSSStyleRule", null, true);
-    test("styleSheetRules", sheet.rules, "MSCSSRuleList", null, true);
+    test("styleSheetRules", sheet.rules, "MSCSSRuleList");
     test("styleSheets", document.styleSheets, "StyleSheetList");
     test("textNode", document.createTextNode("testNode"), "Text", v < 9 ? "testNode" : null);
     test("textRange", txtRange, "TextRange");
-- 
2.48.1


From e8a2751e47374d462f34fdca4e3350d7261cd798 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 43/98] mshtml: Use host object script bindings for
 HTMLStyleSheetRule.

---
 dlls/mshtml/htmlstylesheet.c      | 8 ++++----
 dlls/mshtml/tests/documentmode.js | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index 68de7e57526..fa674f08ccf 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -171,7 +171,7 @@ static dispex_static_data_t HTMLStyleSheetRule_dispex = {
     HTMLStyleSheetRule_iface_tids
 };
 
-static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, compat_mode_t compat_mode,
+static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, DispatchEx *owner,
                                        IHTMLStyleSheetRule **ret)
 {
     HTMLStyleSheetRule *rule;
@@ -183,7 +183,7 @@ static HRESULT create_style_sheet_rule(nsIDOMCSSRule *nsstylesheetrule, compat_m
     rule->IHTMLStyleSheetRule_iface.lpVtbl = &HTMLStyleSheetRuleVtbl;
     rule->nsstylesheetrule = NULL;
 
-    init_dispatch(&rule->dispex, &HTMLStyleSheetRule_dispex, NULL, compat_mode);
+    init_dispatch_with_owner(&rule->dispex, &HTMLStyleSheetRule_dispex, owner);
 
     if (nsstylesheetrule)
     {
@@ -241,7 +241,7 @@ static HRESULT WINAPI HTMLStyleSheetRulesCollection_item(IHTMLStyleSheetRulesCol
     if(!nsstylesheetrule)
         return E_INVALIDARG;
 
-    hres = create_style_sheet_rule(nsstylesheetrule, dispex_compat_mode(&This->dispex), p);
+    hres = create_style_sheet_rule(nsstylesheetrule, &This->dispex, p);
     nsIDOMCSSRule_Release(nsstylesheetrule);
     return hres;
 }
@@ -335,7 +335,7 @@ static HRESULT HTMLStyleSheetRulesCollection_invoke(DispatchEx *dispex, DISPID i
             return S_OK;
         }
 
-        hres = create_style_sheet_rule(nsstylesheetrule, dispex_compat_mode(&This->dispex), &stylesheetrule);
+        hres = create_style_sheet_rule(nsstylesheetrule, &This->dispex, &stylesheetrule);
         nsIDOMCSSRule_Release(nsstylesheetrule);
         if(FAILED(hres))
             return hres;
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index ba27db9f832..5a40f39723c 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -312,7 +312,7 @@ sync_test("builtin_toString", function() {
     test("sessionStorage", window.sessionStorage, "Storage");
     test("style", document.body.style, "MSStyleCSSProperties", null, true);
     test("styleSheet", sheet, "CSSStyleSheet");
-    test("styleSheetRule", sheet.rules[0], "CSSStyleRule", null, true);
+    test("styleSheetRule", sheet.rules[0], "CSSStyleRule");
     test("styleSheetRules", sheet.rules, "MSCSSRuleList");
     test("styleSheets", document.styleSheets, "StyleSheetList");
     test("textNode", document.createTextNode("testNode"), "Text", v < 9 ? "testNode" : null);
-- 
2.48.1


From 6111556196f58be02a2201e6539afee896b6b8d1 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 44/98] mshtml: Use get_prop_desc for legacy function object
 implementation.

And remove no longer needed get_name.
---
 dlls/mshtml/dispex.c         | 40 +++++++++++++++++++-----------------
 dlls/mshtml/mshtml_private.h |  1 -
 2 files changed, 21 insertions(+), 20 deletions(-)

diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 24cba0a9be7..b8ebf1ba5f4 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -1021,14 +1021,18 @@ static HRESULT function_get_dispid(DispatchEx *dispex, const WCHAR *name, DWORD
     return DISP_E_UNKNOWNNAME;
 }
 
-static HRESULT function_get_name(DispatchEx *dispex, DISPID id, BSTR *name)
+static HRESULT function_get_prop_desc(DispatchEx *dispex, DISPID id, struct property_info *desc)
 {
     DWORD idx = id - MSHTML_DISPID_CUSTOM_MIN;
 
     if(idx >= ARRAY_SIZE(function_props))
         return DISP_E_MEMBERNOTFOUND;
 
-    return (*name = SysAllocString(function_props[idx].name)) ? S_OK : E_OUTOFMEMORY;
+    desc->id = id;
+    desc->flags = 0;
+    desc->name = function_props[idx].name;
+    desc->func_iid = 0;
+    return S_OK;
 }
 
 static HRESULT function_invoke(DispatchEx *dispex, DISPID id, LCID lcid, WORD flags, DISPPARAMS *params,
@@ -1058,7 +1062,7 @@ static const dispex_static_data_vtbl_t function_dispex_vtbl = {
     .destructor       = function_destructor,
     .value            = function_value,
     .get_dispid       = function_get_dispid,
-    .get_name         = function_get_name,
+    .get_prop_desc    = function_get_prop_desc,
     .invoke           = function_invoke
 };
 
@@ -1079,7 +1083,7 @@ static func_disp_t *create_func_disp(DispatchEx *obj, func_info_t *info)
     if(!ret)
         return NULL;
 
-    init_dispatch(&ret->dispex, &function_dispex, NULL, dispex_compat_mode(obj));
+    init_dispatch_with_owner(&ret->dispex, &function_dispex, obj);
     ret->obj = obj;
     ret->info = info;
 
@@ -2188,23 +2192,21 @@ HRESULT dispex_prop_name(DispatchEx *dispex, DISPID id, BSTR *ret)
     HRESULT hres;
 
     if(is_custom_dispid(id)) {
-        if(dispex->info->desc->vtbl->get_prop_desc) {
-            struct property_info desc;
-            WCHAR buf[12];
+        struct property_info desc;
+        WCHAR buf[12];
 
-            hres = dispex->info->desc->vtbl->get_prop_desc(dispex, id, &desc);
-            if(FAILED(hres))
-                return hres;
-            if(!desc.name) {
-                swprintf(buf, ARRAYSIZE(buf), L"%u", desc.index);
-                desc.name = buf;
-            }
-            *ret = SysAllocString(desc.name);
-            return *ret ? S_OK : E_OUTOFMEMORY;
+        if(!dispex->info->desc->vtbl->get_prop_desc)
+            return DISP_E_MEMBERNOTFOUND;
+
+        hres = dispex->info->desc->vtbl->get_prop_desc(dispex, id, &desc);
+        if(FAILED(hres))
+            return hres;
+        if(!desc.name) {
+            swprintf(buf, ARRAYSIZE(buf), L"%u", desc.index);
+            desc.name = buf;
         }
-        if(dispex->info->desc->vtbl->get_name)
-            return dispex->info->desc->vtbl->get_name(dispex, id, ret);
-        return DISP_E_MEMBERNOTFOUND;
+        *ret = SysAllocString(desc.name);
+        return *ret ? S_OK : E_OUTOFMEMORY;
     }
 
     if(is_dynamic_dispid(id)) {
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index b130575418f..f07d56b19fa 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -391,7 +391,6 @@ typedef struct {
     HRESULT (*lookup_dispid)(DispatchEx*,const WCHAR*,DWORD,DISPID*);
 
     /* These are called when the object implements GetMemberName, InvokeEx, DeleteMemberByDispID and GetNextDispID for custom props */
-    HRESULT (*get_name)(DispatchEx*,DISPID,BSTR*);
     HRESULT (*invoke)(DispatchEx*,DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*);
     HRESULT (*delete)(DispatchEx*,DISPID);
     HRESULT (*next_dispid)(DispatchEx*,DISPID,DISPID*);
-- 
2.48.1


From 089f39c4c472c3f1cf601912c91a5c8d2b457042 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Wed, 31 Jul 2024 10:50:37 +0200
Subject: [PATCH 45/98] mshtml: Use host object script bindings for style
 objects.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on patch by Gabriel IvÄƒncescu.
---
 dlls/mshtml/htmlcurstyle.c        |  2 +-
 dlls/mshtml/htmlstyle.c           | 14 +++++++-------
 dlls/mshtml/htmlstyle.h           |  4 ++--
 dlls/mshtml/htmlwindow.c          |  2 +-
 dlls/mshtml/tests/documentmode.js |  6 +++---
 5 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/dlls/mshtml/htmlcurstyle.c b/dlls/mshtml/htmlcurstyle.c
index 7d87d965469..135b1b735ee 100644
--- a/dlls/mshtml/htmlcurstyle.c
+++ b/dlls/mshtml/htmlcurstyle.c
@@ -1198,7 +1198,7 @@ HRESULT HTMLCurrentStyle_Create(HTMLElement *elem, IHTMLCurrentStyle **p)
     ret->IHTMLCurrentStyle3_iface.lpVtbl = &HTMLCurrentStyle3Vtbl;
     ret->IHTMLCurrentStyle4_iface.lpVtbl = &HTMLCurrentStyle4Vtbl;
 
-    init_css_style(&ret->css_style, nsstyle, &HTMLCurrentStyle_dispex, dispex_compat_mode(&elem->node.event_target.dispex));
+    init_css_style(&ret->css_style, nsstyle, &HTMLCurrentStyle_dispex, &elem->node.event_target.dispex);
     nsIDOMCSSStyleDeclaration_Release(nsstyle);
 
     IHTMLElement_AddRef(&elem->IHTMLElement_iface);
diff --git a/dlls/mshtml/htmlstyle.c b/dlls/mshtml/htmlstyle.c
index f1e30b6872d..d916aecb420 100644
--- a/dlls/mshtml/htmlstyle.c
+++ b/dlls/mshtml/htmlstyle.c
@@ -2940,8 +2940,8 @@ static HRESULT WINAPI HTMLStyle_removeAttribute(IHTMLStyle *iface, BSTR strAttri
         DISPID dispid;
         unsigned i;
 
-        hres = IWineJSDispatchHost_GetDispID(&This->css_style.dispex.IWineJSDispatchHost_iface, strAttributeName,
-                (lFlags&1) ? fdexNameCaseSensitive : fdexNameCaseInsensitive, &dispid);
+        hres = dispex_get_id(&This->css_style.dispex, strAttributeName,
+                             (lFlags & 1) ? fdexNameCaseSensitive : fdexNameCaseInsensitive, &dispid);
         if(hres != S_OK) {
             *pfSuccess = VARIANT_FALSE;
             return S_OK;
@@ -9714,14 +9714,14 @@ static HRESULT get_style_from_elem(HTMLElement *elem, nsIDOMCSSStyleDeclaration
     return E_NOTIMPL;
 }
 
-void init_css_style(CSSStyle *style, nsIDOMCSSStyleDeclaration *nsstyle, dispex_static_data_t *dispex_info, compat_mode_t compat_mode)
+void init_css_style(CSSStyle *style, nsIDOMCSSStyleDeclaration *nsstyle, dispex_static_data_t *dispex_info, DispatchEx *owner)
 {
     style->IHTMLCSSStyleDeclaration_iface.lpVtbl = &HTMLCSSStyleDeclarationVtbl;
     style->IHTMLCSSStyleDeclaration2_iface.lpVtbl = &HTMLCSSStyleDeclaration2Vtbl;
     style->nsstyle = nsstyle;
     nsIDOMCSSStyleDeclaration_AddRef(nsstyle);
 
-    init_dispatch(&style->dispex, dispex_info, NULL, compat_mode);
+    init_dispatch_with_owner(&style->dispex, dispex_info, owner);
 }
 
 HRESULT HTMLStyle_Create(HTMLElement *elem, HTMLStyle **ret)
@@ -9750,7 +9750,7 @@ HRESULT HTMLStyle_Create(HTMLElement *elem, HTMLStyle **ret)
     style->elem = elem;
     IHTMLDOMNode_AddRef(&elem->node.IHTMLDOMNode_iface);
 
-    init_css_style(&style->css_style, nsstyle, &HTMLStyle_dispex, dispex_compat_mode(&elem->node.event_target.dispex));
+    init_css_style(&style->css_style, nsstyle, &HTMLStyle_dispex, &elem->node.event_target.dispex);
     nsIDOMCSSStyleDeclaration_Release(nsstyle);
 
     *ret = style;
@@ -9775,14 +9775,14 @@ static dispex_static_data_t HTMLW3CComputedStyle_dispex = {
     CSSStyle_init_dispex_info
 };
 
-HRESULT create_computed_style(nsIDOMCSSStyleDeclaration *nsstyle, compat_mode_t compat_mode, IHTMLCSSStyleDeclaration **p)
+HRESULT create_computed_style(nsIDOMCSSStyleDeclaration *nsstyle, DispatchEx *owner, IHTMLCSSStyleDeclaration **p)
 {
     CSSStyle *style;
 
     if(!(style = calloc(1, sizeof(*style))))
         return E_OUTOFMEMORY;
 
-    init_css_style(style, nsstyle, &HTMLW3CComputedStyle_dispex, compat_mode);
+    init_css_style(style, nsstyle, &HTMLW3CComputedStyle_dispex, owner);
     *p = &style->IHTMLCSSStyleDeclaration_iface;
     return S_OK;
 }
diff --git a/dlls/mshtml/htmlstyle.h b/dlls/mshtml/htmlstyle.h
index 66509147836..b37daf95fa6 100644
--- a/dlls/mshtml/htmlstyle.h
+++ b/dlls/mshtml/htmlstyle.h
@@ -150,8 +150,8 @@ typedef enum {
 } styleid_t;
 
 HRESULT HTMLStyle_Create(HTMLElement*,HTMLStyle**);
-HRESULT create_computed_style(nsIDOMCSSStyleDeclaration*,compat_mode_t,IHTMLCSSStyleDeclaration**);
-void init_css_style(CSSStyle*,nsIDOMCSSStyleDeclaration*,dispex_static_data_t*,compat_mode_t);
+HRESULT create_computed_style(nsIDOMCSSStyleDeclaration*,DispatchEx*,IHTMLCSSStyleDeclaration**);
+void init_css_style(CSSStyle*,nsIDOMCSSStyleDeclaration*,dispex_static_data_t*,DispatchEx*);
 
 void *CSSStyle_query_interface(DispatchEx*,REFIID);
 void CSSStyle_traverse(DispatchEx*,nsCycleCollectionTraversalCallback*);
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index 445be60fba8..52201715af8 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -2429,7 +2429,7 @@ static HRESULT WINAPI HTMLWindow7_getComputedStyle(IHTMLWindow7 *iface, IHTMLDOM
         return S_OK;
     }
 
-    hres = create_computed_style(nsstyle, dispex_compat_mode(&This->inner_window->event_target.dispex), p);
+    hres = create_computed_style(nsstyle, &This->inner_window->event_target.dispex, p);
     nsIDOMCSSStyleDeclaration_Release(nsstyle);
     return hres;
 }
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 5a40f39723c..95c033f46dd 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -295,7 +295,7 @@ sync_test("builtin_toString", function() {
     test("childNodes", document.body.childNodes, "NodeList");
     if(clientRects) test("clientRect", clientRects[0], "ClientRect");
     if(clientRects) test("clientRects", clientRects, "ClientRectList");
-    if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties", null, true);
+    if(currentStyle) test("currentStyle", currentStyle, "MSCurrentStyleCSSProperties");
     if(v >= 11 /* todo_wine */) test("document", document, v < 11 ? "Document" : "HTMLDocument");
     test("elements", document.getElementsByTagName("body"), "HTMLCollection");
     test("history", window.history, "History");
@@ -310,7 +310,7 @@ sync_test("builtin_toString", function() {
     if(v >= 11 /* todo_wine */) test("plugins", window.navigator.plugins, v < 11 ? "MSPluginsCollection" : "PluginArray");
     test("screen", window.screen, "Screen");
     test("sessionStorage", window.sessionStorage, "Storage");
-    test("style", document.body.style, "MSStyleCSSProperties", null, true);
+    test("style", document.body.style, "MSStyleCSSProperties");
     test("styleSheet", sheet, "CSSStyleSheet");
     test("styleSheetRule", sheet.rules[0], "CSSStyleRule");
     test("styleSheetRules", sheet.rules, "MSCSSRuleList");
@@ -327,7 +327,7 @@ sync_test("builtin_toString", function() {
         test("selection", document.selection, "MSSelection");
     }
     if(v >= 9) {
-        test("computedStyle", window.getComputedStyle(e), "CSSStyleDeclaration", null, true);
+        test("computedStyle", window.getComputedStyle(e), "CSSStyleDeclaration");
         test("doctype", document.doctype, "DocumentType");
 
         test("Event", document.createEvent("Event"), "Event");
-- 
2.48.1


From 3d045847cb3a2f83d1b4ed1c50687d69c7a7836f Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Tue, 30 Jul 2024 23:24:56 -0600
Subject: [PATCH 46/98] atl: Correct comment above AtlModuleRegisterTypeLib
 function.

---
 dlls/atl/atl30.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/atl/atl30.c b/dlls/atl/atl30.c
index d7d130c2a03..ec96744a4a1 100644
--- a/dlls/atl/atl30.c
+++ b/dlls/atl/atl30.c
@@ -258,7 +258,7 @@ HRESULT WINAPI AtlModuleGetClassObject(_ATL_MODULEW *pm, REFCLSID rclsid,
 }
 
 /***********************************************************************
- *           AtlModuleGetClassObject              [ATL.@]
+ *           AtlModuleRegisterTypeLib             [ATL.@]
  */
 HRESULT WINAPI AtlModuleRegisterTypeLib(_ATL_MODULEW *pm, LPCOLESTR lpszIndex)
 {
-- 
2.48.1


From ed9b44c31ac8a9fb8fdf165d427e65f21ed45d72 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Tue, 30 Jul 2024 23:18:53 -0600
Subject: [PATCH 47/98] atl: Only warn in AtlModuleGetClassObject if the class
 was not found.

A warning should only be printed if something went wrong, not every time
the function is run.
---
 dlls/atl/atl30.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/atl/atl30.c b/dlls/atl/atl30.c
index ec96744a4a1..767fa977a92 100644
--- a/dlls/atl/atl30.c
+++ b/dlls/atl/atl30.c
@@ -247,7 +247,7 @@ HRESULT WINAPI AtlModuleGetClassObject(_ATL_MODULEW *pm, REFCLSID rclsid,
                                                   (void **)&obj->pCF);
                 if (obj->pCF)
                     hres = IUnknown_QueryInterface(obj->pCF, riid, ppv);
-                break;
+                return hres;
             }
         }
     }
-- 
2.48.1


From c3d34d43b0ed4acdeb11ab3f328a9d7fe7232839 Mon Sep 17 00:00:00 2001
From: Vijay Kiran Kamuju <infyquest@gmail.com>
Date: Fri, 8 Dec 2023 12:51:56 +0100
Subject: [PATCH 48/98] include: Add gdiplus effect parameter structs.

---
 include/gdipluscolormatrix.h |  1 +
 include/gdipluseffects.h     | 86 ++++++++++++++++++++++++++++++++++++
 2 files changed, 87 insertions(+)

diff --git a/include/gdipluscolormatrix.h b/include/gdipluscolormatrix.h
index 44016ff3451..391095ed8fb 100644
--- a/include/gdipluscolormatrix.h
+++ b/include/gdipluscolormatrix.h
@@ -62,6 +62,7 @@ enum HistogramFormat
 
 #ifndef __cplusplus
 
+typedef BYTE ColorChannelLUT[256];
 typedef enum ColorAdjustType ColorAdjustType;
 typedef enum ColorMatrixFlags ColorMatrixFlags;
 typedef enum HistogramFormat HistogramFormat;
diff --git a/include/gdipluseffects.h b/include/gdipluseffects.h
index d2d6a0500da..a0743a440e9 100644
--- a/include/gdipluseffects.h
+++ b/include/gdipluseffects.h
@@ -31,6 +31,92 @@ DEFINE_GUID(ColorBalanceEffectGuid,           0x537e597d, 0x251e, 0x48da, 0x96,
 DEFINE_GUID(RedEyeCorrectionEffectGuid,       0x74d29d05, 0x69a4, 0x4266, 0x95, 0x49, 0x3c, 0xc5, 0x28, 0x36, 0xb6, 0x32);
 DEFINE_GUID(ColorCurveEffectGuid,             0xdd6a0022, 0x58e4, 0x4a67, 0x9d, 0x9b, 0xd4, 0x8e, 0xb8, 0x81, 0xa5, 0x3d);
 
+struct BlurParams
+{
+    float radius;
+    BOOL expandEdge;
+};
+
+struct SharpenParams
+{
+    float radius;
+    float amount;
+};
+
+struct TintParams
+{
+    INT hue;
+    INT amount;
+};
+
+struct RedEyeCorrectionParams
+{
+    UINT numberOfAreas;
+    RECT *areas;
+};
+
+struct ColorLUTParams
+{
+   ColorChannelLUT lutB;
+   ColorChannelLUT lutG;
+   ColorChannelLUT lutR;
+   ColorChannelLUT lutA;
+};
+
+struct BrightnessContrastParams
+{
+    INT brightnessLevel;
+    INT contrastLevel;
+};
+
+struct HueSaturationLightnessParams
+{
+    INT hueLevel;
+    INT saturationLevel;
+    INT lightnessLevel;
+};
+
+struct ColorBalanceParams
+{
+    INT cyanRed;
+    INT magentaGreen;
+    INT yellowBlue;
+};
+
+struct LevelsParams
+{
+    INT highlight;
+    INT midtone;
+    INT shadow;
+};
+
+enum CurveAdjustments
+{
+   AdjustExposure,
+   AdjustDensity,
+   AdjustContrast,
+   AdjustHighlight,
+   AdjustShadow,
+   AdjustMidtone,
+   AdjustWhiteSaturation,
+   AdjustBlackSaturation
+};
+
+enum CurveChannel
+{
+    CurveChannelAll,
+    CurveChannelRed,
+    CurveChannelGreen,
+    CurveChannelBlue
+};
+
+struct ColorCurveParams
+{
+    enum CurveAdjustments adjustment;
+    enum CurveChannel channel;
+    INT adjustValue;
+};
+
 #ifdef __cplusplus
 extern "C" {
 #endif
-- 
2.48.1


From 37e2b7ccec153d25f818cbed9568f2e07c70a3ed Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 28 May 2024 10:25:41 +1000
Subject: [PATCH 49/98] include: Add *_SHIFT macros.

---
 include/gdipluspixelformats.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/include/gdipluspixelformats.h b/include/gdipluspixelformats.h
index 2a2a3ccbcfd..91726628be1 100644
--- a/include/gdipluspixelformats.h
+++ b/include/gdipluspixelformats.h
@@ -22,6 +22,12 @@
 typedef DWORD ARGB;
 typedef INT PixelFormat;
 
+#define ALPHA_SHIFT 24
+#define RED_SHIFT   16
+#define GREEN_SHIFT 8
+#define BLUE_SHIFT  0
+#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)
+
 #define    PixelFormatIndexed   0x00010000
 #define    PixelFormatGDI       0x00020000
 #define    PixelFormatAlpha     0x00040000
-- 
2.48.1


From 6de806d62c6a8358ad60c0bddebe711dea84cf9f Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 30 Jul 2024 16:12:46 +1000
Subject: [PATCH 50/98] include: Forward declare all gdiplus classes.

---
 include/gdiplusgpstubs.h | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/include/gdiplusgpstubs.h b/include/gdiplusgpstubs.h
index 67b6ac1e34e..ba99ccb67a9 100644
--- a/include/gdiplusgpstubs.h
+++ b/include/gdiplusgpstubs.h
@@ -21,6 +21,28 @@
 
 #ifdef __cplusplus
 
+class Bitmap;
+class Brush;
+class CachedBitmap;
+class Font;
+class FontCollection;
+class FontFamily;
+class Graphics;
+class GraphicsPath;
+class HatchBrush;
+class Image;
+class ImageAttributes;
+class InstalledFontCollection;
+class LinearGradientBrush;
+class Matrix;
+class Metafile;
+class PathGradientBrush;
+class PathIterator;
+class Pen;
+class Region;
+class SolidBrush;
+class TextureBrush;
+
 class GpGraphics {};
 class GpPen {};
 class GpBrush {};
-- 
2.48.1


From 0291c9f9fb5d759a6b464cbb55ba3de00db584f3 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 30 Jul 2024 11:55:42 -0700
Subject: [PATCH 51/98] include: Ensure that x86_64 syscall thunks have a
 consistent length when built with Clang.

GCC always assembles 'jmp 1f' to 'eb 01', as does Clang when using -O1
or higher optimization.
But with -O0, Clang outputs 'e9 01 00 00 00'.

The 'subq $0xb,0x70(%rcx)' line in __wine_syscall_dispatcher relies on
'jmp 1f' being 2 bytes.

Based on patch by Alex S.
---
 include/wine/asm.h | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/include/wine/asm.h b/include/wine/asm.h
index 7a6c03b5df7..37760a59dcd 100644
--- a/include/wine/asm.h
+++ b/include/wine/asm.h
@@ -245,9 +245,9 @@
                        ".byte 0x75,0x03\n\t"      /* jne 1f */ \
                        ".byte 0x0f,0x05\n\t"      /* syscall */ \
                        ".byte 0xc3\n\t"           /* ret */ \
-                       "jmp 1f\n\t" \
-                       ".byte 0xc3\n"             /* ret */ \
-                       "1:\t.byte 0xff,0x14,0x25\n\t" /* 1: callq *(0x7ffe1000) */ \
+                       ".byte 0xeb,0x01\n\t"      /* jmp 1f */ \
+                       ".byte 0xc3\n\t"           /* ret */ \
+                       ".byte 0xff,0x14,0x25\n\t" /* 1: callq *(0x7ffe1000) */ \
                        ".long 0x7ffe1000\n\t" \
                        "ret" )
 # else
@@ -260,10 +260,10 @@
                        ".byte 0x75,0x03\n\t"      /* jne 1f */ \
                        ".byte 0x0f,0x05\n\t"      /* syscall */ \
                        ".byte 0xc3\n\t"           /* ret */ \
-                       "jmp 1f\n\t" \
+                       ".byte 0xeb,0x02\n\t"      /* jmp 1f */ \
                        ".byte 0xc3\n"             /* ret */ \
-                       "nop\n" \
-                       "1:\tcallq *" __ASM_NAME("__wine_syscall_dispatcher") "(%rip)\n\t" \
+                       "nop\n\t" \
+                       "callq *" __ASM_NAME("__wine_syscall_dispatcher") "(%rip)\n\t" /* 1: callq __wine_syscall_dispatcher */ \
                        "ret" )
 # endif
 #elif defined __arm__
-- 
2.48.1


From 8cb1009e4c2a77f313ceb4d6f7309f215f9c7224 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 29 Jul 2024 16:54:09 -0700
Subject: [PATCH 52/98] ntdll: Use environ/_NSGetEnviron() directly rather than
 caching it in main_envp.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57005
---
 dlls/ntdll/unix/env.c          | 9 ++++++---
 dlls/ntdll/unix/loader.c       | 4 +---
 dlls/ntdll/unix/unix_private.h | 1 -
 loader/main.c                  | 6 ++----
 4 files changed, 9 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 36949b905fb..f95bf737f56 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -44,6 +44,10 @@
 #ifdef __APPLE__
 # include <CoreFoundation/CFLocale.h>
 # include <CoreFoundation/CFString.h>
+# include <crt_externs.h>
+# define environ (*_NSGetEnviron())
+#else
+  extern char **environ;
 #endif
 
 #include "ntstatus.h"
@@ -70,7 +74,6 @@ static const WCHAR bootstrapW[] = {'W','I','N','E','B','O','O','T','S','T','R','
 
 int main_argc = 0;
 char **main_argv = NULL;
-char **main_envp = NULL;
 WCHAR **main_wargv = NULL;
 
 static LCID user_lcid, system_lcid;
@@ -931,12 +934,12 @@ static WCHAR *get_initial_environment( SIZE_T *pos, SIZE_T *size )
 
     /* estimate needed size */
     *size = 1;
-    for (e = main_envp; *e; e++) *size += strlen(*e) + 1;
+    for (e = environ; *e; e++) *size += strlen(*e) + 1;
 
     env = malloc( *size * sizeof(WCHAR) );
     ptr = env;
     end = env + *size - 1;
-    for (e = main_envp; *e && ptr < end; e++)
+    for (e = environ; *e && ptr < end; e++)
     {
         char *str = *e;
 
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 1267469bf37..b7dfb5b3528 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1953,7 +1953,6 @@ static jstring wine_init_jni( JNIEnv *env, jobject obj, jobjectArray cmdline, jo
 
     main_argc = argc;
     main_argv = argv;
-    main_envp = environ;
 
     init_paths( argv );
     virtual_init();
@@ -2149,11 +2148,10 @@ static void check_command_line( int argc, char *argv[] )
  *
  * Main entry point called by the wine loader.
  */
-DECLSPEC_EXPORT void __wine_main( int argc, char *argv[], char *envp[] )
+DECLSPEC_EXPORT void __wine_main( int argc, char *argv[] )
 {
     main_argc = argc;
     main_argv = argv;
-    main_envp = envp;
 
     init_paths( argv );
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 91267f66e76..ee5630e76f1 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -172,7 +172,6 @@ extern SIZE_T startup_info_size;
 extern BOOL is_prefix_bootstrap;
 extern int main_argc;
 extern char **main_argv;
-extern char **main_envp;
 extern WCHAR **main_wargv;
 extern const WCHAR system_dir[];
 extern unsigned int supported_machines_count;
diff --git a/loader/main.c b/loader/main.c
index e5de4750015..ecb51efa136 100644
--- a/loader/main.c
+++ b/loader/main.c
@@ -37,8 +37,6 @@
 
 #include "main.h"
 
-extern char **environ;
-
 #if defined(__APPLE__) && defined(__x86_64__) && !defined(HAVE_WINE_PRELOADER)
 
 /* Not using the preloader on x86_64:
@@ -260,8 +258,8 @@ int main( int argc, char *argv[] )
 
     if ((handle = load_ntdll( argv[0] )))
     {
-        void (*init_func)(int, char **, char **) = dlsym( handle, "__wine_main" );
-        if (init_func) init_func( argc, argv, environ );
+        void (*init_func)(int, char **) = dlsym( handle, "__wine_main" );
+        if (init_func) init_func( argc, argv );
         fprintf( stderr, "wine: __wine_main function not found in ntdll.so\n" );
         exit(1);
     }
-- 
2.48.1


From 8b1a6bb7e744a0a412d1c5f7b787b404b9cd31a6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 30 Jul 2024 14:16:34 -0700
Subject: [PATCH 53/98] ntdll: Use _NSGetEnviron() instead of environ when
 spawning the server on macOS.

---
 dlls/ntdll/unix/loader.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index b7dfb5b3528..92f2e2eb3a3 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -73,11 +73,13 @@
 # ifndef _POSIX_SPAWN_DISABLE_ASLR
 #  define _POSIX_SPAWN_DISABLE_ASLR 0x0100
 # endif
+# define environ (*_NSGetEnviron())
+#else
+  extern char **environ;
 #endif
 #ifdef __ANDROID__
 # include <jni.h>
 #endif
-extern char **environ;
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
-- 
2.48.1


From 6cd79a0ea8c7b98b1673c73e68eb1fee0816e0db Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 30 Jul 2024 14:13:00 -0700
Subject: [PATCH 54/98] msv1_0: Use _NSGetEnviron() instead of environ on
 macOS.

---
 dlls/msv1_0/unixlib.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/msv1_0/unixlib.c b/dlls/msv1_0/unixlib.c
index 807f3778109..95c92233b37 100644
--- a/dlls/msv1_0/unixlib.c
+++ b/dlls/msv1_0/unixlib.c
@@ -40,7 +40,12 @@
 #include "wine/debug.h"
 #include "unixlib.h"
 
-extern char **environ;
+#ifdef __APPLE__
+# include <crt_externs.h>
+# define environ (*_NSGetEnviron())
+#else
+  extern char **environ;
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntlm);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
-- 
2.48.1


From 72bb43949782400fdb52daf100b90cc97d1a1063 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 21 Nov 2022 21:26:19 -0800
Subject: [PATCH 55/98] wintypes: Hack in some calls to RoResolveNamespace

---
 dlls/wintypes/main.c           | 84 ++++++++++++++++++++++++++++++++++
 dlls/wintypes/tests/wintypes.c | 56 +++++++++++++++++++++++
 2 files changed, 140 insertions(+)

diff --git a/dlls/wintypes/main.c b/dlls/wintypes/main.c
index 7d59ab92c41..532a45f548d 100644
--- a/dlls/wintypes/main.c
+++ b/dlls/wintypes/main.c
@@ -25,6 +25,8 @@
 #include "winstring.h"
 #include "wine/debug.h"
 #include "objbase.h"
+#include "roapi.h"
+
 
 #include "activation.h"
 #include "rometadataresolution.h"
@@ -379,10 +381,92 @@ HRESULT WINAPI RoResolveNamespace(HSTRING name, HSTRING windowsMetaDataDir,
                                   DWORD *metaDataFilePathsCount, HSTRING **metaDataFilePaths,
                                   DWORD *subNamespacesCount, HSTRING **subNamespaces)
 {
+    //https://learn.microsoft.com/en-us/windows/win32/api/rometadataresolution/nf-rometadataresolution-roresolvenamespace
+    //name L"Windows.Services.Store", windowsMetaDataDir L"", metaDataFilePaths 0000000000419088, subNamespaces 0000000000000000 stub!
+    const WCHAR *buffer = WindowsGetStringRawBuffer( name, NULL );
+    HSTRING *str = malloc(sizeof(HSTRING)), *str2 = malloc(sizeof(HSTRING));
+    // const WCHAR *path = L"C:\\Windows\\system32\\WinMetadata\\Windows.Services.winmd";
+    const WCHAR *path;
     FIXME("name %s, windowsMetaDataDir %s, metaDataFilePaths %p, subNamespaces %p stub!\n",
             debugstr_hstring(name), debugstr_hstring(windowsMetaDataDir),
             metaDataFilePaths, subNamespaces);
 
+    if(wcsstr(buffer, L"Windows.Storage") > 0){
+        FIXME("Found Windows.Storage \n");
+        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Storage.winmd";
+        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
+            FIXME("Setting vars\n");
+            *metaDataFilePaths = str;
+            *metaDataFilePathsCount = 1;
+            FIXME("Done setting\n");
+        } else {
+            FIXME("OUT OF MEMORY");
+            return E_OUTOFMEMORY;
+        }
+        // *subNamespacesCount = 0;
+        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
+        // *subNamespaces = str2;
+        FIXME("S_OK\n");
+        return S_OK;
+    }
+
+    if(wcsstr(buffer, L"Windows.ApplicationModel.DesignMode") > 0){
+        FIXME("Found Windows.ApplicationModel.DesignMode \n");
+        path = L"C:\\windows\\system32\\WinMetadata\\Windows.ApplicationModel.winmd";
+        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
+            FIXME("Setting vars\n");
+            *metaDataFilePaths = str;
+            *metaDataFilePathsCount = 1;
+            FIXME("Done setting\n");
+        } else {
+            FIXME("OUT OF MEMORY");
+            return E_OUTOFMEMORY;
+        }
+        // *subNamespacesCount = 0;
+        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
+        // *subNamespaces = str2;
+        FIXME("S_OK\n");
+        return S_OK;
+    }
+
+    if(wcsstr(buffer, L"Windows.Services.Store") > 0){
+        FIXME("Found Windows.Services.Store \n");
+        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Services.winmd";
+        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
+            FIXME("Setting vars\n");
+            *metaDataFilePaths = str;
+            *metaDataFilePathsCount = 1;
+            FIXME("Done setting\n");
+        } else {
+            FIXME("OUT OF MEMORY");
+            return E_OUTOFMEMORY;
+        }
+        // *subNamespacesCount = 0;
+        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
+        // *subNamespaces = str2;
+        FIXME("S_OK\n");
+        return S_OK;
+    }
+
+    if(wcsstr(buffer, L"Windows.Foundation") > 0){
+        FIXME("Found Windows.Foundation \n");
+        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Foundation.winmd";
+        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
+            FIXME("Setting vars\n");
+            *metaDataFilePaths = str;
+            *metaDataFilePathsCount = 1;
+            FIXME("Done setting\n");
+        } else {
+            FIXME("OUT OF MEMORY");
+            return E_OUTOFMEMORY;
+        }
+        // *subNamespacesCount = 0;
+        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
+        // *subNamespaces = str2;
+        FIXME("S_OK\n");
+        return S_OK;
+    }
+
     if (!metaDataFilePaths && !subNamespaces)
         return E_INVALIDARG;
 
diff --git a/dlls/wintypes/tests/wintypes.c b/dlls/wintypes/tests/wintypes.c
index 0703582d325..4830078a754 100644
--- a/dlls/wintypes/tests/wintypes.c
+++ b/dlls/wintypes/tests/wintypes.c
@@ -456,8 +456,64 @@ static void test_IApiInformationStatics(void)
     IActivationFactory_Release(factory);
     RoUninitialize();
 }
+static HRESULT (WINAPI *pRoResolveNamespace)(HSTRING name, HSTRING windowsMetaDataDir,
+                                  DWORD packageGraphDirsCount, const HSTRING *packageGraphDirs,
+                                  DWORD *metaDataFilePathsCount, HSTRING **metaDataFilePaths,
+                                  DWORD *subNamespacesCount, HSTRING **subNamespaces);
+static void test_RoResolveNamespace(void) {
+    HSTRING name, windowsMetaDataDir, *metaDataFilePaths, *subNamespaces;
+    DWORD metaDataFilePathsCount, subNamespacesCount;
+    HRESULT hr;
+
+
+    HMODULE hmod = LoadLibraryA("wintypes.dll");
+    if(hmod == NULL) {
+        skip("Failed to load wintypes.dll\n");
+        return;
+    }
+    pRoResolveNamespace = (void*)GetProcAddress(hmod, "RoResolveNamespace");
+    if(pRoResolveNamespace == NULL) {
+        skip("Failed to get DllGetClassObject\n");
+        return;
+    }
+
+    
+    hr = WindowsCreateString( L"Windows.Services.Store", ARRAY_SIZE(L"Windows.Services.Store") - 1, &name );
+    ok(hr == S_OK, "Could not allocate HSTRING for name, hr %#lx.\n", hr);
+    wprintf(L"Testing %s\n", WindowsGetStringRawBuffer(name, 0));
+    hr = WindowsCreateString( L"", ARRAY_SIZE(L"") - 1, &windowsMetaDataDir );
+    ok(hr == S_OK, "Could not allocate HSTRING for windowsMetaDataDir, hr %#lx.\n", hr);
+    pRoResolveNamespace(name, windowsMetaDataDir,
+        0, NULL,
+        &metaDataFilePathsCount, &metaDataFilePaths,
+        &subNamespacesCount, &subNamespaces);
+
+    if (subNamespacesCount != 0)
+    {
+        wprintf(L"\nsub namespaces %d count:\n", subNamespacesCount);
+
+        for (DWORD i = 0; i < subNamespacesCount; i++)
+        {
+            wprintf(L"Subnamespace %d: %s\n", i, WindowsGetStringRawBuffer(subNamespaces[i], 0));
+        }
+    }
+
+    if (metaDataFilePathsCount != 0)
+    {
+        wprintf(L"\nmetaDataFilePathsCount %d\n", metaDataFilePathsCount);
+
+        for (DWORD i = 0; i < metaDataFilePathsCount; i++)
+        {
+            wprintf(L"Metadata file path %d: %s\n", i, WindowsGetStringRawBuffer(metaDataFilePaths[i], 0));
+        }
+        wprintf(L"\n");
+    }
+}
 
 START_TEST(wintypes)
 {
+        if (0) {
     test_IApiInformationStatics();
+        }
+    test_RoResolveNamespace();
 }
-- 
2.48.1


From 400943e5077973bfc03001e22824aa0828bf7d3b Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 21 Nov 2022 21:31:47 -0800
Subject: [PATCH 56/98] include: Add dxcore.idl

---
 include/dxcore.idl | 226 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 226 insertions(+)
 create mode 100644 include/dxcore.idl

diff --git a/include/dxcore.idl b/include/dxcore.idl
new file mode 100644
index 00000000000..b6c3aecae2e
--- /dev/null
+++ b/include/dxcore.idl
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) the Wine project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/*
+ * Copyright (c) Microsoft Corporation.
+ *
+ * MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+import "oaidl.idl";
+import "ocidl.idl";
+
+cpp_quote("#define _FACDXCORE 0x880")
+cpp_quote("#define MAKE_DXCORE_HRESULT(code) MAKE_HRESULT(1, _FACDXCORE, code)")
+
+cpp_quote("#if 0")
+typedef struct _LUID {
+  DWORD LowPart;
+  LONG HighPart;
+} LUID, *PLUID;
+cpp_quote("#endif")
+
+typedef enum DXCoreAdapterProperty {
+  InstanceLuid = 0,
+  DriverVersion = 1,
+  DriverDescription = 2,
+  HardwareID = 3,
+  KmdModelVersion = 4,
+  ComputePreemptionGranularity = 5,
+  GraphicsPreemptionGranularity = 6,
+  DedicatedAdapterMemory = 7,
+  DedicatedSystemMemory = 8,
+  SharedSystemMemory = 9,
+  AcgCompatible = 10,
+  IsHardware = 11,
+  IsIntegrated = 12,
+  IsDetachable = 13,
+  HardwareIDParts = 14
+} DXCoreAdapterProperty;
+
+typedef enum DXCoreAdapterState {
+  IsDriverUpdateInProgress = 0,
+  AdapterMemoryBudget = 1
+} DXCoreAdapterState;
+
+typedef enum DXCoreSegmentGroup {
+  Local = 0,
+  NonLocal = 1
+} DXCoreSegmentGroup;
+
+typedef enum DXCoreNotificationType {
+  AdapterListStale = 0,
+  AdapterNoLongerValid = 1,
+  AdapterBudgetChange = 2,
+  AdapterHardwareContentProtectionTeardown = 3
+} DXCoreNotificationType;
+
+typedef enum DXCoreAdapterPreference {
+  Hardware = 0,
+  MinimumPower = 1,
+  HighPerformance = 2
+} DXCoreAdapterPreference;
+
+typedef struct DXCoreHardwareID {
+  UINT32 vendorID;
+  UINT32 deviceID;
+  UINT32 subSysID;
+  UINT32 revision;
+} DXCoreHardwareID;
+
+typedef struct DXCoreHardwareIDParts {
+  UINT32 vendorID;
+  UINT32 deviceID;
+  UINT32 subSystemID;
+  UINT32 subVendorID;
+  UINT32 revisionID;
+} DXCoreHardwareIDParts;
+
+typedef struct DXCoreAdapterMemoryBudgetNodeSegmentGroup {
+  UINT32 nodeIndex;
+  DXCoreSegmentGroup segmentGroup;
+} DXCoreAdapterMemoryBudgetNodeSegmentGroup;
+
+typedef struct DXCoreAdapterMemoryBudget {
+  UINT64 budget;
+  UINT64 currentUsage;
+  UINT64 availableForReservation;
+  UINT64 currentReservation;
+} DXCoreAdapterMemoryBudget;
+
+cpp_quote("typedef void (WINAPI *PFN_DXCORE_NOTIFICATION_CALLBACK)(DXCoreNotificationType notificationType, IUnknown *object, void *context);")
+
+cpp_quote("DEFINE_GUID(DXCORE_ADAPTER_ATTRIBUTE_D3D11_GRAPHICS, 0x8c47866b, 0x7583, 0x450d, 0xf0, 0xf0, 0x6b, 0xad, 0xa8, 0x95, 0xaf, 0x4b);")
+cpp_quote("DEFINE_GUID(DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS, 0x0c9ece4d, 0x2f6e, 0x4f01, 0x8c, 0x96, 0xe8, 0x9e, 0x33, 0x1b, 0x47, 0xb1);")
+cpp_quote("DEFINE_GUID(DXCORE_ADAPTER_ATTRIBUTE_D3D12_CORE_COMPUTE, 0x248e2800, 0xa793, 0x4724, 0xab, 0xaa, 0x23, 0xa6, 0xde, 0x1b, 0xe0, 0x90);")
+
+[uuid(f0db4c7f-fe5a-42a2-bd62-f2a6cf6fc83e), object, local, pointer_default(unique)]
+interface IDXCoreAdapter : IUnknown
+{
+  boolean IsValid();
+
+  boolean IsAttributeSupported(
+    REFGUID attributeGUID);
+
+  boolean IsPropertySupported(
+    DXCoreAdapterProperty property);
+
+  HRESULT GetProperty(
+    DXCoreAdapterProperty property,
+    SIZE_T bufferSize,
+    void *propertyData);
+
+  HRESULT GetPropertySize(
+    DXCoreAdapterProperty property,
+    SIZE_T *bufferSize);
+
+  boolean IsQueryStateSupported(
+    DXCoreAdapterState property);
+
+  HRESULT QueryState(
+    DXCoreAdapterState state,
+    SIZE_T inputStateDetailsSize,
+    const void *inputStateDetails,
+    SIZE_T outputBufferSize,
+    void *outputBuffer);
+
+  boolean IsSetStateSupported(
+    DXCoreAdapterState property);
+
+  HRESULT SetState(
+    DXCoreAdapterState state,
+    SIZE_T inputStateDetailsSize,
+    const void *inputStateDetails,
+    SIZE_T inputDataSize,
+    const void *inputData);
+
+  HRESULT GetFactory(
+    REFIID riid,
+    void **ppvFactory);
+}
+
+[uuid(526c7776-40e9-459b-b711-f32ad76dfc28), object, local, pointer_default(unique)]
+interface IDXCoreAdapterList : IUnknown
+{
+  HRESULT GetAdapter(
+    UINT32 index,
+    REFIID riid,
+    void **ppvAdapter);
+
+  UINT32 GetAdapterCount();
+  boolean IsStale();
+
+  HRESULT GetFactory(
+    REFIID riid,
+     void **ppvFactory);
+
+  HRESULT Sort(
+    UINT32 numPreferences,
+    const DXCoreAdapterPreference *preferences);
+
+  boolean IsAdapterPreferenceSupported(
+    DXCoreAdapterPreference preference);
+}
+
+[uuid(78ee5945-c36e-4b13-a669-005dd11c0f06), object, local, pointer_default(unique)]
+interface IDXCoreAdapterFactory : IUnknown
+{
+  HRESULT CreateAdapterList(
+    UINT32 numAttributes,
+    const GUID *filterAttributes,
+    REFIID riid,
+    void **ppvAdapterList);
+
+  HRESULT GetAdapterByLuid(
+    const LUID adapterLUID,
+    REFIID riid,
+    void **ppvAdapter);
+
+  boolean IsNotificationTypeSupported(
+    DXCoreNotificationType notificationType);
+
+  HRESULT RegisterEventNotification(
+    IUnknown *dxCoreObject,
+    DXCoreNotificationType notificationType,
+    void *callbackFunction,
+    void *callbackContext,
+    UINT32 *eventCookie);
+
+  HRESULT UnregisterEventNotification(
+    UINT32 eventCookie);
+}
+
+cpp_quote("STDAPI DXCoreCreateAdapterFactory(REFIID riid, void **ppvFactory);")
-- 
2.48.1


From e47e861600dc5b45d5b822ab8fbf59f1c3af4ab3 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Sun, 26 Feb 2023 12:56:24 -0800
Subject: [PATCH 57/98] shell32/iconcache: Call LoadIconW

---
 dlls/shell32/iconcache.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
index c122c145609..7e9a37db44d 100644
--- a/dlls/shell32/iconcache.c
+++ b/dlls/shell32/iconcache.c
@@ -1007,7 +1007,7 @@ HRESULT WINAPI SHGetStockIconInfo(SHSTOCKICONID id, UINT flags, SHSTOCKICONINFO
     if (flags)
         FIXME("flags 0x%x not implemented\n", flags);
 
-    sii->hIcon = NULL;
+    sii->hIcon = LoadIconW(GetModuleHandleW(L"shell32.dll"), MAKEINTRESOURCEW(IDI_SHELL_FILE));
     sii->iSysImageIndex = -1;
 
     TRACE("%3d: returning %s (%d)\n", id, debugstr_w(sii->szPath), sii->iIcon);
-- 
2.48.1


From c8cc854d8853a22c28614344fca1760af65fc8ce Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 29 Jul 2024 18:19:33 -0700
Subject: [PATCH 58/98] Revert "wined3d: Compile the clear compute shaders at
 runtime."

This reverts commit c319b874669450cc17ebe9a7f459a17b86cdcddb.
---
 dlls/wined3d/Makefile.in                      |   1 -
 .../cs_uav_clear_1d_array_float_code.hlsl     |  33 --
 .../cs_uav_clear_1d_array_uint_code.hlsl      |  33 --
 dlls/wined3d/cs_uav_clear_1d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl   |  33 --
 .../cs_uav_clear_2d_array_float_code.hlsl     |  33 --
 .../cs_uav_clear_2d_array_uint_code.hlsl      |  33 --
 dlls/wined3d/cs_uav_clear_2d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl   |  33 --
 dlls/wined3d/cs_uav_clear_3d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl   |  33 --
 .../cs_uav_clear_buffer_float_code.hlsl       |  33 --
 .../cs_uav_clear_buffer_uint_code.hlsl        |  33 --
 dlls/wined3d/resource.rc                      |  30 --
 dlls/wined3d/view.c                           | 111 +----
 dlls/wined3d/wined3d_shaders.h                | 388 ++++++++++++++++++
 16 files changed, 406 insertions(+), 520 deletions(-)
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
 delete mode 100644 dlls/wined3d/resource.rc
 create mode 100644 dlls/wined3d/wined3d_shaders.h

diff --git a/dlls/wined3d/Makefile.in b/dlls/wined3d/Makefile.in
index 69415ebb7f9..634cd903799 100644
--- a/dlls/wined3d/Makefile.in
+++ b/dlls/wined3d/Makefile.in
@@ -19,7 +19,6 @@ SOURCES = \
 	palette.c \
 	query.c \
 	resource.c \
-	resource.rc \
 	sampler.c \
 	shader.c \
 	shader_sm1.c \
diff --git a/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
deleted file mode 100644
index 9b933321d1d..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1DArray<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
deleted file mode 100644
index 7b51aefe034..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1DArray<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
deleted file mode 100644
index dbf37e565ad..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
deleted file mode 100644
index fb842339e9b..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
deleted file mode 100644
index c356a6ed64b..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2DArray<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
deleted file mode 100644
index 09fb97c19a9..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2DArray<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
deleted file mode 100644
index f74b694eee4..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
deleted file mode 100644
index cd0f73e92d5..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
deleted file mode 100644
index 63e049230c8..00000000000
--- a/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture3D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
deleted file mode 100644
index 6abff9b8fb7..00000000000
--- a/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture3D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl b/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
deleted file mode 100644
index 3710948b318..00000000000
--- a/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWBuffer<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(128, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
deleted file mode 100644
index 64bf3c63b09..00000000000
--- a/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWBuffer<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(128, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/resource.rc b/dlls/wined3d/resource.rc
deleted file mode 100644
index a970c3eecbc..00000000000
--- a/dlls/wined3d/resource.rc
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2024 Giovanni Mascellani for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-cs_uav_clear_buffer_float_code.hlsl RCDATA cs_uav_clear_buffer_float_code.hlsl
-cs_uav_clear_buffer_uint_code.hlsl RCDATA cs_uav_clear_buffer_uint_code.hlsl
-cs_uav_clear_1d_array_float_code.hlsl RCDATA cs_uav_clear_1d_array_float_code.hlsl
-cs_uav_clear_1d_array_uint_code.hlsl RCDATA cs_uav_clear_1d_array_uint_code.hlsl
-cs_uav_clear_1d_float_code.hlsl RCDATA cs_uav_clear_1d_float_code.hlsl
-cs_uav_clear_1d_uint_code.hlsl RCDATA cs_uav_clear_1d_uint_code.hlsl
-cs_uav_clear_2d_array_float_code.hlsl RCDATA cs_uav_clear_2d_array_float_code.hlsl
-cs_uav_clear_2d_array_uint_code.hlsl RCDATA cs_uav_clear_2d_array_uint_code.hlsl
-cs_uav_clear_2d_float_code.hlsl RCDATA cs_uav_clear_2d_float_code.hlsl
-cs_uav_clear_2d_uint_code.hlsl RCDATA cs_uav_clear_2d_uint_code.hlsl
-cs_uav_clear_3d_float_code.hlsl RCDATA cs_uav_clear_3d_float_code.hlsl
-cs_uav_clear_3d_uint_code.hlsl RCDATA cs_uav_clear_3d_uint_code.hlsl
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
index 91b88c2037d..ca97f6258eb 100644
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -18,6 +18,7 @@
  */
 
 #include "wined3d_private.h"
+#include "wined3d_shaders.h"
 #include "wined3d_gl.h"
 #include "wined3d_vk.h"
 
@@ -1887,36 +1888,6 @@ HRESULT wined3d_unordered_access_view_gl_init(struct wined3d_unordered_access_vi
     return hr;
 }
 
-static int compile_hlsl_cs(const struct vkd3d_shader_code *hlsl, struct vkd3d_shader_code *dxbc)
-{
-    struct vkd3d_shader_hlsl_source_info hlsl_info;
-    struct vkd3d_shader_compile_info info;
-
-    static const struct vkd3d_shader_compile_option options[] =
-    {
-        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_12},
-    };
-
-    info.type = VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO;
-    info.next = &hlsl_info;
-    info.source = *hlsl;
-    info.source_type = VKD3D_SHADER_SOURCE_HLSL;
-    info.target_type = VKD3D_SHADER_TARGET_DXBC_TPF;
-    info.options = options;
-    info.option_count = ARRAY_SIZE(options);
-    info.log_level = VKD3D_SHADER_LOG_NONE;
-    info.source_name = NULL;
-
-    hlsl_info.type = VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO;
-    hlsl_info.next = NULL;
-    hlsl_info.entry_point = "main";
-    hlsl_info.secondary_code.code = NULL;
-    hlsl_info.secondary_code.size = 0;
-    hlsl_info.profile = "cs_5_0";
-
-    return vkd3d_shader_compile(&info, dxbc, NULL);
-}
-
 struct wined3d_uav_clear_constants_vk
 {
     VkClearColorValue color;
@@ -1925,80 +1896,32 @@ struct wined3d_uav_clear_constants_vk
 };
 
 static VkPipeline create_uav_pipeline(struct wined3d_context_vk *context_vk,
-        struct wined3d_pipeline_layout_vk *layout, const char *resource_filename,
+        struct wined3d_pipeline_layout_vk *layout, const unsigned int *byte_code, size_t byte_code_size,
         enum wined3d_shader_resource_type resource_type)
 {
     VkComputePipelineCreateInfo pipeline_info;
     struct wined3d_shader_desc shader_desc;
     const struct wined3d_vk_info *vk_info;
-    struct vkd3d_shader_code code, dxbc;
     struct wined3d_context *context;
     VkShaderModule shader_module;
     VkDevice vk_device;
-    void *resource_ptr;
     VkPipeline result;
-    HGLOBAL global;
-    HMODULE module;
-    HRSRC resource;
     VkResult vr;
-    int ret;
 
     vk_info = context_vk->vk_info;
     context = &context_vk->c;
 
-    if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
-                           (const char *)create_uav_pipeline, &module))
-    {
-        ERR("Failed to get a reference to the current module, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(resource = FindResourceA(module, resource_filename, (const char *)RT_RCDATA)))
-    {
-        ERR("Failed to retrieve resource, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(global = LoadResource(module, resource)))
-    {
-        ERR("Failed to load resource, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(resource_ptr = LockResource(global)))
-    {
-        ERR("Failed to lock resource.\n");
-        FreeResource(resource);
-        return VK_NULL_HANDLE;
-    }
-
-    code.code = resource_ptr;
-    code.size = SizeofResource(module, resource);
-
-    if ((ret = compile_hlsl_cs(&code, &dxbc)) < 0)
-    {
-        ERR("Failed to compile shader, ret %d.\n", ret);
-        FreeResource(resource);
-        return VK_NULL_HANDLE;
-    }
-
-    if (FreeResource(resource))
-        ERR("Failed to free resource.\n");
-
-    shader_desc.byte_code = dxbc.code;
-    shader_desc.byte_code_size = dxbc.size;
+    shader_desc.byte_code = (const DWORD *)byte_code;
+    shader_desc.byte_code_size = byte_code_size;
 
     shader_module = (VkShaderModule)context->device->adapter->shader_backend->shader_compile(context, &shader_desc,
             WINED3D_SHADER_TYPE_COMPUTE);
     if (shader_module == VK_NULL_HANDLE)
     {
         ERR("Failed to create shader.\n");
-        vkd3d_shader_free_shader_code(&dxbc);
         return VK_NULL_HANDLE;
     }
 
-    vkd3d_shader_free_shader_code(&dxbc);
-
     pipeline_info.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
     pipeline_info.pNext = NULL;
     pipeline_info.flags = 0;
@@ -2048,30 +1971,32 @@ void wined3d_device_vk_uav_clear_state_init(struct wined3d_device_vk *device_vk)
     vk_set_bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
     state->buffer_layout = wined3d_context_vk_get_pipeline_layout(context_vk, vk_set_bindings, 2);
 
+#define SHADER_DESC(name) name, sizeof(name)
     state->float_pipelines.buffer = create_uav_pipeline(context_vk, state->buffer_layout,
-            "cs_uav_clear_buffer_float_code.hlsl", WINED3D_SHADER_RESOURCE_BUFFER);
+            SHADER_DESC(cs_uav_clear_buffer_float_code), WINED3D_SHADER_RESOURCE_BUFFER);
     state->uint_pipelines.buffer = create_uav_pipeline(context_vk, state->buffer_layout,
-            "cs_uav_clear_buffer_uint_code.hlsl", WINED3D_SHADER_RESOURCE_BUFFER);
+            SHADER_DESC(cs_uav_clear_buffer_uint_code), WINED3D_SHADER_RESOURCE_BUFFER);
     state->float_pipelines.image_1d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1D);
+            SHADER_DESC(cs_uav_clear_1d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_1D);
     state->uint_pipelines.image_1d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1D);
+            SHADER_DESC(cs_uav_clear_1d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_1D);
     state->float_pipelines.image_1d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_array_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
+            SHADER_DESC(cs_uav_clear_1d_array_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
     state->uint_pipelines.image_1d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_array_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
+            SHADER_DESC(cs_uav_clear_1d_array_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
     state->float_pipelines.image_2d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2D);
+            SHADER_DESC(cs_uav_clear_2d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_2D);
     state->uint_pipelines.image_2d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2D);
+            SHADER_DESC(cs_uav_clear_2d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_2D);
     state->float_pipelines.image_2d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_array_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
+            SHADER_DESC(cs_uav_clear_2d_array_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
     state->uint_pipelines.image_2d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_array_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
+            SHADER_DESC(cs_uav_clear_2d_array_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
     state->float_pipelines.image_3d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_3d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+            SHADER_DESC(cs_uav_clear_3d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_3D);
     state->uint_pipelines.image_3d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_3d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+            SHADER_DESC(cs_uav_clear_3d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+#undef SHADER_DESC
 
     state->buffer_group_size.x = 128;
     state->buffer_group_size.y = 1;
diff --git a/dlls/wined3d/wined3d_shaders.h b/dlls/wined3d/wined3d_shaders.h
new file mode 100644
index 00000000000..db763290af9
--- /dev/null
+++ b/dlls/wined3d/wined3d_shaders.h
@@ -0,0 +1,388 @@
+/*
+ * Copyright 2019 Philip Rebohle
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINED3D_SHADERS_H
+#define __WINE_WINED3D_SHADERS_H
+
+static const uint32_t cs_uav_clear_buffer_float_code[] =
+{
+#if 0
+    RWBuffer<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(128, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xe114ba61, 0xff6a0d0b, 0x7b25c8f4, 0xfcf7cf22, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_buffer_uint_code[] =
+{
+#if 0
+    RWBuffer<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(128, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x3afd0cfd, 0x5145c166, 0x5b9f76b8, 0xa73775cd, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_array_float_code[] =
+{
+#if 0
+    RWTexture1DArray<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x3d73bc2d, 0x2b635f3d, 0x6bf98e92, 0xbe0aa5d9, 0x00000001, 0x0000011c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
+    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_array_uint_code[] =
+{
+#if 0
+    RWTexture1DArray<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x2f0ca457, 0x72068b34, 0xd9dadc2b, 0xd3178c3e, 0x00000001, 0x0000011c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
+    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_float_code[] =
+{
+#if 0
+    RWTexture1D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x05266503, 0x4b97006f, 0x01a5cc63, 0xe617d0a1, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_uint_code[] =
+{
+#if 0
+    RWTexture1D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x19d5c8f2, 0x3ca4ac24, 0x9e258499, 0xf0463fd6, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_array_float_code[] =
+{
+#if 0
+    RWTexture2DArray<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x924d2d2c, 0xb9166376, 0x99f83871, 0x8ef65025, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_array_uint_code[] =
+{
+#if 0
+    RWTexture2DArray<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xa92219d4, 0xa2c5e47d, 0x0d308500, 0xf32197b4, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_float_code[] =
+{
+#if 0
+    RWTexture2D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x6e735b3f, 0x7348c4fa, 0xb3634e42, 0x50e2d99b, 0x00000001, 0x00000128, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
+    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
+    0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_uint_code[] =
+{
+#if 0
+    RWTexture2D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xf01db5dd, 0xc7dc5e55, 0xb017c1a8, 0x55abd52d, 0x00000001, 0x00000128, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
+    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
+    0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_3d_float_code[] =
+{
+#if 0
+    RWTexture3D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x5d8f36a0, 0x30fa86a5, 0xfec7f2ef, 0xdfd76cbb, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_3d_uint_code[] =
+{
+#if 0
+    RWTexture3D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x5b9c95b1, 0xc9bde4e3, 0x9aaff806, 0x24a1d264, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+#endif
-- 
2.48.1


From 274a0938701479ebf6cfb5a025a5c51adce98cb3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 24 Apr 2024 11:12:31 +0200
Subject: [PATCH 59/98] win32u: Introduce a new vulkan offscreen surfaces list.

---
 dlls/win32u/vulkan.c | 27 +++++++++++++++++++--------
 1 file changed, 19 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 471a4459ec3..5eb2d26a8a2 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -48,6 +48,9 @@ static struct vulkan_funcs vulkan_funcs;
 #ifdef SONAME_LIBVULKAN
 
 static const struct vulkan_driver_funcs *driver_funcs;
+/* list of surfaces attached to other processes / desktop windows */
+static struct list offscreen_surfaces = LIST_INIT(offscreen_surfaces);
+static pthread_mutex_t vulkan_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static VkResult (*p_vkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
@@ -73,6 +76,7 @@ static inline VkSurfaceKHR surface_to_handle( struct surface *surface )
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin32SurfaceCreateInfoKHR *info,
                                                 const VkAllocationCallbacks *allocator, VkSurfaceKHR *handle )
 {
+    HWND toplevel = NtUserGetAncestor( info->hwnd, GA_ROOT );
     struct surface *surface;
     VkResult res;
     WND *win;
@@ -87,8 +91,12 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         return res;
     }
 
-    if (!(win = get_win_ptr( info->hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
-        list_init( &surface->entry );
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_add_tail( &offscreen_surfaces, &surface->entry );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
@@ -107,7 +115,10 @@ static void win32u_vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR handle
     TRACE( "instance %p, handle 0x%s, allocator %p\n", instance, wine_dbgstr_longlong(handle), allocator );
     if (allocator) FIXME( "Support for allocation callbacks not implemented yet\n" );
 
+    pthread_mutex_lock( &vulkan_mutex );
     list_remove( &surface->entry );
+    pthread_mutex_unlock( &vulkan_mutex );
+
     p_vkDestroySurfaceKHR( instance, surface->host_surface, NULL /* allocator */ );
     driver_funcs->p_vulkan_surface_destroy( surface->hwnd, surface->driver_private );
     free( surface );
@@ -315,14 +326,14 @@ static void vulkan_init_once(void)
 
 void vulkan_detach_surfaces( struct list *surfaces )
 {
-    struct surface *surface, *next;
+    struct surface *surface;
 
-    LIST_FOR_EACH_ENTRY_SAFE( surface, next, surfaces, struct surface, entry )
-    {
+    LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
-        list_remove( &surface->entry );
-        list_init( &surface->entry );
-    }
+
+    pthread_mutex_lock( &vulkan_mutex );
+    list_move_tail( &offscreen_surfaces, surfaces );
+    pthread_mutex_unlock( &vulkan_mutex );
 }
 
 #else /* SONAME_LIBVULKAN */
-- 
2.48.1


From 340ba20ca6271acd38f717f6a61d0bfcc8cd398f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 24 Apr 2024 11:12:31 +0200
Subject: [PATCH 60/98] win32u: Move vulkan surfaces to their new parent when
 reparenting.

---
 dlls/win32u/ntuser_private.h |  1 +
 dlls/win32u/vulkan.c         | 79 ++++++++++++++++++++++++++++++++++++
 dlls/win32u/window.c         |  1 +
 3 files changed, 81 insertions(+)

diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index a361e1d73a5..2c0d4845453 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -247,6 +247,7 @@ extern void *(*p_vkGetInstanceProcAddr)(VkInstance, const char *);
 
 extern BOOL vulkan_init(void);
 extern void vulkan_detach_surfaces( struct list *surfaces );
+extern void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent );
 
 /* window.c */
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type );
diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 5eb2d26a8a2..0cec13f3f23 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -336,6 +336,85 @@ void vulkan_detach_surfaces( struct list *surfaces )
     pthread_mutex_unlock( &vulkan_mutex );
 }
 
+static void append_window_surfaces( HWND toplevel, struct list *surfaces )
+{
+    WND *win;
+
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_move_tail( &offscreen_surfaces, surfaces );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
+    else
+    {
+        list_move_tail( &win->vulkan_surfaces, surfaces );
+        release_win_ptr( win );
+    }
+}
+
+static void enum_window_surfaces( HWND toplevel, HWND hwnd, struct list *surfaces )
+{
+    struct list tmp_surfaces = LIST_INIT(tmp_surfaces);
+    struct surface *surface, *next;
+    WND *win;
+
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_move_tail( &tmp_surfaces, &offscreen_surfaces );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
+    else
+    {
+        list_move_tail( &tmp_surfaces, &win->vulkan_surfaces );
+        release_win_ptr( win );
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE( surface, next, &tmp_surfaces, struct surface, entry )
+    {
+        if (surface->hwnd != hwnd && !NtUserIsChild( hwnd, surface->hwnd )) continue;
+        list_remove( &surface->entry );
+        list_add_tail( surfaces, &surface->entry );
+    }
+
+    append_window_surfaces( toplevel, &tmp_surfaces );
+}
+
+void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
+{
+    struct list surfaces = LIST_INIT(surfaces);
+    HWND new_toplevel, old_toplevel;
+
+    TRACE( "hwnd %p new_parent %p old_parent %p\n", hwnd, new_parent, old_parent );
+
+    if (new_parent == NtUserGetDesktopWindow()) new_toplevel = hwnd;
+    else new_toplevel = NtUserGetAncestor( new_parent, GA_ROOT );
+    if (old_parent == NtUserGetDesktopWindow()) old_toplevel = hwnd;
+    else old_toplevel = NtUserGetAncestor( old_parent, GA_ROOT );
+    if (old_toplevel == new_toplevel) return;
+
+    enum_window_surfaces( old_toplevel, hwnd, &surfaces );
+    append_window_surfaces( new_toplevel, &surfaces );
+}
+
+/***********************************************************************
+ *      __wine_get_vulkan_driver  (win32u.so)
+ */
+const struct vulkan_funcs *__wine_get_vulkan_driver( UINT version )
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR( "version mismatch, vulkan wants %u but win32u has %u\n", version, WINE_VULKAN_DRIVER_VERSION );
+        return NULL;
+    }
+
+    pthread_once( &init_once, vulkan_init );
+    return vulkan_handle ? &vulkan_funcs : NULL;
+}
+
 #else /* SONAME_LIBVULKAN */
 
 void vulkan_detach_surfaces( struct list *surfaces )
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 4499e226a7b..b34f53457aa 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -462,6 +462,7 @@ HWND WINAPI NtUserSetParent( HWND hwnd, HWND parent )
     context = set_thread_dpi_awareness_context( get_window_dpi_awareness_context( hwnd ));
 
     user_driver->pSetParent( full_handle, parent, old_parent );
+    vulkan_set_parent( full_handle, parent, old_parent );
 
     winpos.hwnd = hwnd;
     winpos.hwndInsertAfter = HWND_TOP;
-- 
2.48.1


From f1c63ffdc31d2e9608e8058423d8853a08cecdd9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:33:06 +0200
Subject: [PATCH 61/98] win32u: Detach offscreen, child or vulkan surfaces for
 another process.

And attach them back when they are on-screen again.
---
 dlls/win32u/vulkan.c          | 23 +++++++++++++++++++++++
 dlls/winemac.drv/vulkan.c     |  5 +++++
 dlls/winewayland.drv/vulkan.c |  5 +++++
 dlls/winex11.drv/vulkan.c     | 15 +++++++++++++++
 dlls/winex11.drv/window.c     |  2 +-
 dlls/winex11.drv/x11drv.h     |  1 +
 include/wine/vulkan_driver.h  |  3 ++-
 7 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 0cec13f3f23..54d2acfb367 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -96,11 +96,13 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         pthread_mutex_lock( &vulkan_mutex );
         list_add_tail( &offscreen_surfaces, &surface->entry );
         pthread_mutex_unlock( &vulkan_mutex );
+        driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
     }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
         release_win_ptr( win );
+        if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
     }
 
     surface->hwnd = info->hwnd;
@@ -198,6 +200,10 @@ static void nulldrv_vulkan_surface_destroy( HWND hwnd, void *private )
 {
 }
 
+static void nulldrv_vulkan_surface_attach( HWND hwnd, void *private )
+{
+}
+
 static void nulldrv_vulkan_surface_detach( HWND hwnd, void *private )
 {
 }
@@ -220,6 +226,7 @@ static const struct vulkan_driver_funcs nulldrv_funcs =
 {
     .p_vulkan_surface_create = nulldrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = nulldrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = nulldrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = nulldrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = nulldrv_vulkan_surface_presented,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = nulldrv_vkGetPhysicalDeviceWin32PresentationSupportKHR,
@@ -264,6 +271,12 @@ static void lazydrv_vulkan_surface_destroy( HWND hwnd, void *private )
     return driver_funcs->p_vulkan_surface_destroy( hwnd, private );
 }
 
+static void lazydrv_vulkan_surface_attach( HWND hwnd, void *private )
+{
+    vulkan_driver_load();
+    return driver_funcs->p_vulkan_surface_attach( hwnd, private );
+}
+
 static void lazydrv_vulkan_surface_detach( HWND hwnd, void *private )
 {
     vulkan_driver_load();
@@ -292,6 +305,7 @@ static const struct vulkan_driver_funcs lazydrv_funcs =
 {
     .p_vulkan_surface_create = lazydrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = lazydrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = lazydrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = lazydrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = lazydrv_vulkan_surface_presented,
 };
@@ -338,6 +352,7 @@ void vulkan_detach_surfaces( struct list *surfaces )
 
 static void append_window_surfaces( HWND toplevel, struct list *surfaces )
 {
+    struct surface *surface;
     WND *win;
 
     if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
@@ -350,6 +365,9 @@ static void append_window_surfaces( HWND toplevel, struct list *surfaces )
     {
         list_move_tail( &win->vulkan_surfaces, surfaces );
         release_win_ptr( win );
+
+        LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
+            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
     }
 }
 
@@ -385,6 +403,7 @@ void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
 {
     struct list surfaces = LIST_INIT(surfaces);
     HWND new_toplevel, old_toplevel;
+    struct surface *surface;
 
     TRACE( "hwnd %p new_parent %p old_parent %p\n", hwnd, new_parent, old_parent );
 
@@ -395,6 +414,10 @@ void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
     if (old_toplevel == new_toplevel) return;
 
     enum_window_surfaces( old_toplevel, hwnd, &surfaces );
+
+    LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+
     append_window_surfaces( new_toplevel, &surfaces );
 }
 
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index d5a3df579d0..9b033a84d57 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -178,6 +178,10 @@ static void macdrv_vulkan_surface_destroy(HWND hwnd, void *private)
     wine_vk_surface_destroy(mac_surface);
 }
 
+static void macdrv_vulkan_surface_attach(HWND hwnd, void *private)
+{
+}
+
 static void macdrv_vulkan_surface_detach(HWND hwnd, void *private)
 {
 }
@@ -203,6 +207,7 @@ static const struct vulkan_driver_funcs macdrv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = macdrv_vulkan_surface_create,
     .p_vulkan_surface_destroy = macdrv_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = macdrv_vulkan_surface_attach,
     .p_vulkan_surface_detach = macdrv_vulkan_surface_detach,
     .p_vulkan_surface_presented = macdrv_vulkan_surface_presented,
 
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 16084175013..cd63981bf0d 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -132,6 +132,10 @@ static void wayland_vulkan_surface_destroy(HWND hwnd, void *private)
     wine_vk_surface_destroy(client);
 }
 
+static void wayland_vulkan_surface_attach(HWND hwnd, void *private)
+{
+}
+
 static void wayland_vulkan_surface_detach(HWND hwnd, void *private)
 {
 }
@@ -175,6 +179,7 @@ static const struct vulkan_driver_funcs wayland_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = wayland_vulkan_surface_create,
     .p_vulkan_surface_destroy = wayland_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = wayland_vulkan_surface_attach,
     .p_vulkan_surface_detach = wayland_vulkan_surface_detach,
     .p_vulkan_surface_presented = wayland_vulkan_surface_presented,
 
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 85993bc517a..b979da1085e 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -109,6 +109,20 @@ static void X11DRV_vulkan_surface_destroy( HWND hwnd, void *private )
     destroy_client_window( hwnd, client_window );
 }
 
+static void X11DRV_vulkan_surface_attach( HWND hwnd, void *private )
+{
+    Window client_window = (Window)private;
+    struct x11drv_win_data *data;
+
+    TRACE( "%p %p\n", hwnd, private );
+
+    if ((data = get_win_data( hwnd )))
+    {
+        attach_client_window( data, client_window );
+        release_win_data( data );
+    }
+}
+
 static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private )
 {
     Window client_window = (Window)private;
@@ -145,6 +159,7 @@ static const struct vulkan_driver_funcs x11drv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = X11DRV_vulkan_surface_create,
     .p_vulkan_surface_destroy = X11DRV_vulkan_surface_destroy,
+    .p_vulkan_surface_attach = X11DRV_vulkan_surface_attach,
     .p_vulkan_surface_detach = X11DRV_vulkan_surface_detach,
     .p_vulkan_surface_presented = X11DRV_vulkan_surface_presented,
 
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 98cb7952164..2b9bfe302ae 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1641,7 +1641,7 @@ void detach_client_window( struct x11drv_win_data *data, Window client_window )
 /**********************************************************************
  *             attach_client_window
  */
-static void attach_client_window( struct x11drv_win_data *data, Window client_window )
+void attach_client_window( struct x11drv_win_data *data, Window client_window )
 {
     if (data->client_window == client_window || !client_window) return;
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index fc57c72cb79..0e4bdc52661 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -646,6 +646,7 @@ extern void read_net_wm_states( Display *display, struct x11drv_win_data *data )
 extern void update_net_wm_states( struct x11drv_win_data *data );
 extern void make_window_embedded( struct x11drv_win_data *data );
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual, Colormap colormap );
+extern void attach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void detach_client_window( struct x11drv_win_data *data, Window client_window );
 extern void destroy_client_window( HWND hwnd, Window client_window );
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha );
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 7ddba4739f4..180cff0e09b 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,7 +21,7 @@
 #define __WINE_VULKAN_DRIVER_H
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 34
+#define WINE_VULKAN_DRIVER_VERSION 35
 
 struct vulkan_funcs
 {
@@ -46,6 +46,7 @@ struct vulkan_driver_funcs
 {
     VkResult (*p_vulkan_surface_create)(HWND, VkInstance, VkSurfaceKHR *, void **);
     void (*p_vulkan_surface_destroy)(HWND, void *);
+    void (*p_vulkan_surface_attach)(HWND, void *);
     void (*p_vulkan_surface_detach)(HWND, void *);
     void (*p_vulkan_surface_presented)(HWND, VkResult);
 
-- 
2.48.1


From 92a038bdc706443d370b7d8a3522f5bd2f51ce6b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:35:31 +0200
Subject: [PATCH 62/98] win32u: Detach vulkan surfaces that aren't fully
 visible.

And attach them back when they are.
---
 dlls/win32u/ntuser_private.h |  1 +
 dlls/win32u/vulkan.c         | 54 ++++++++++++++++++++++++++++++++----
 dlls/win32u/window.c         |  3 ++
 3 files changed, 53 insertions(+), 5 deletions(-)

diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 2c0d4845453..f58a1cfadac 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -248,6 +248,7 @@ extern void *(*p_vkGetInstanceProcAddr)(VkInstance, const char *);
 extern BOOL vulkan_init(void);
 extern void vulkan_detach_surfaces( struct list *surfaces );
 extern void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent );
+extern void vulkan_set_region( HWND toplevel, HRGN region );
 
 /* window.c */
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type );
diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 54d2acfb367..5f454625870 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -60,6 +60,7 @@ struct surface
     struct list entry;
     VkSurfaceKHR host_surface;
     void *driver_private;
+    BOOL is_detached;
     HWND hwnd;
 };
 
@@ -97,12 +98,17 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         list_add_tail( &offscreen_surfaces, &surface->entry );
         pthread_mutex_unlock( &vulkan_mutex );
         driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
     }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
         release_win_ptr( win );
-        if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+        if (toplevel != info->hwnd)
+        {
+            driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+            surface->is_detached = TRUE;
+        }
     }
 
     surface->hwnd = info->hwnd;
@@ -343,7 +349,11 @@ void vulkan_detach_surfaces( struct list *surfaces )
     struct surface *surface;
 
     LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
+    {
+        if (surface->is_detached) continue;
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
+    }
 
     pthread_mutex_lock( &vulkan_mutex );
     list_move_tail( &offscreen_surfaces, surfaces );
@@ -352,7 +362,6 @@ void vulkan_detach_surfaces( struct list *surfaces )
 
 static void append_window_surfaces( HWND toplevel, struct list *surfaces )
 {
-    struct surface *surface;
     WND *win;
 
     if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
@@ -365,9 +374,6 @@ static void append_window_surfaces( HWND toplevel, struct list *surfaces )
     {
         list_move_tail( &win->vulkan_surfaces, surfaces );
         release_win_ptr( win );
-
-        LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
-            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
     }
 }
 
@@ -415,12 +421,50 @@ void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
 
     enum_window_surfaces( old_toplevel, hwnd, &surfaces );
 
+    /* surfaces will be re-attached as needed from surface region updates */
     LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        if (surface->is_detached) continue;
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
+    }
 
     append_window_surfaces( new_toplevel, &surfaces );
 }
 
+void vulkan_set_region( HWND toplevel, HRGN region )
+{
+    struct list surfaces = LIST_INIT(surfaces);
+    struct surface *surface;
+
+    enum_window_surfaces( toplevel, toplevel, &surfaces );
+
+    LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        RECT client_rect;
+        BOOL is_clipped;
+
+        NtUserGetClientRect( surface->hwnd, &client_rect );
+        NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2 );
+        is_clipped = NtGdiRectInRegion( region, &client_rect );
+
+        if (is_clipped && !surface->is_detached)
+        {
+            TRACE( "surface %p is now clipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+            surface->is_detached = TRUE;
+        }
+        else if (!is_clipped && surface->is_detached)
+        {
+            TRACE( "surface %p is now unclipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
+            surface->is_detached = FALSE;
+        }
+    }
+
+    append_window_surfaces( toplevel, &surfaces );
+}
+
 /***********************************************************************
  *      __wine_get_vulkan_driver  (win32u.so)
  */
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index b34f53457aa..de33f612f92 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -1787,6 +1787,9 @@ static void update_surface_region( HWND hwnd )
 done:
     if (shape) NtGdiDeleteObjectApp( shape );
     release_win_ptr( win );
+
+    vulkan_set_region( hwnd, region );
+    if (region) NtGdiDeleteObjectApp( region );
 }
 
 
-- 
2.48.1


From 2c7ad6b25ae37bb815df74a962b3cc2d6467a237 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 2 May 2024 11:55:59 +0200
Subject: [PATCH 63/98] win32u: Make sure vulkan windows have a pixel format
 selected.

---
 dlls/win32u/vulkan.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 5f454625870..f78e8b5db8f 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -92,6 +92,9 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         return res;
     }
 
+    /* make sure the window has a pixel format selected to get consistent window surface updates */
+    if (!win32u_get_window_pixel_format( info->hwnd )) win32u_set_window_pixel_format( info->hwnd, 1, TRUE );
+
     if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
     {
         pthread_mutex_lock( &vulkan_mutex );
-- 
2.48.1


From 8b47de92e686201c0696ef04135b5ccc09c993e6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 29 Mar 2024 10:49:46 +0100
Subject: [PATCH 64/98] winex11: Also attach child client windows to their
 toplevel window.

---
 dlls/winex11.drv/window.c | 54 +++++++++++++++++++++++++++++----------
 1 file changed, 40 insertions(+), 14 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 2b9bfe302ae..ed77922e639 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1475,8 +1475,21 @@ static void sync_client_position( struct x11drv_win_data *data,
 
     if (!data->client_window) return;
 
-    changes.x      = data->client_rect.left - data->whole_rect.left;
-    changes.y      = data->client_rect.top - data->whole_rect.top;
+    if (data->whole_window)
+    {
+        changes.x = data->client_rect.left - data->whole_rect.left;
+        changes.y = data->client_rect.top - data->whole_rect.top;
+    }
+    else
+    {
+        HWND toplevel = NtUserGetAncestor( data->hwnd, GA_ROOT );
+        POINT pos = {data->client_rect.left, data->client_rect.top};
+
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1 );
+        changes.x = pos.x;
+        changes.y = pos.y;
+    }
+
     changes.width  = min( max( 1, data->client_rect.right - data->client_rect.left ), 65535 );
     changes.height = min( max( 1, data->client_rect.bottom - data->client_rect.top ), 65535 );
 
@@ -1628,11 +1641,8 @@ void detach_client_window( struct x11drv_win_data *data, Window client_window )
 
     TRACE( "%p/%lx detaching client window %lx\n", data->hwnd, data->whole_window, client_window );
 
-    if (data->whole_window)
-    {
-        client_window_events_disable( data, client_window );
-        XReparentWindow( gdi_display, client_window, get_dummy_parent(), 0, 0 );
-    }
+    client_window_events_disable( data, client_window );
+    XReparentWindow( gdi_display, client_window, get_dummy_parent(), 0, 0 );
 
     data->client_window = 0;
 }
@@ -1643,18 +1653,33 @@ void detach_client_window( struct x11drv_win_data *data, Window client_window )
  */
 void attach_client_window( struct x11drv_win_data *data, Window client_window )
 {
+    Window whole_window;
+    POINT pos = {0};
+
     if (data->client_window == client_window || !client_window) return;
 
     TRACE( "%p/%lx attaching client window %lx\n", data->hwnd, data->whole_window, client_window );
 
     detach_client_window( data, data->client_window );
 
-    if (data->whole_window)
+    if ((whole_window = data->whole_window))
     {
-        client_window_events_enable( data, client_window );
-        XReparentWindow( gdi_display, client_window, data->whole_window, data->client_rect.left - data->whole_rect.left,
-                         data->client_rect.top - data->whole_rect.top );
+        pos.x = data->client_rect.left - data->whole_rect.left;
+        pos.y = data->client_rect.top - data->whole_rect.top;
     }
+    else
+    {
+        HWND toplevel = NtUserGetAncestor( data->hwnd, GA_ROOT );
+        whole_window = X11DRV_get_whole_window( toplevel );
+
+        pos.x = data->client_rect.left;
+        pos.y = data->client_rect.top;
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1 );
+    }
+    if (!whole_window) whole_window = get_dummy_parent();
+
+    client_window_events_enable( data, client_window );
+    XReparentWindow( gdi_display, client_window, whole_window, pos.x, pos.y );
 
     data->client_window = client_window;
 }
@@ -1819,6 +1844,9 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
 {
     TRACE( "win %p xwin %lx/%lx\n", data->hwnd, data->whole_window, data->client_window );
 
+    if (!already_destroyed) detach_client_window( data, data->client_window );
+    else if (data->client_window) client_window_events_disable( data, data->client_window );
+
     if (!data->whole_window)
     {
         if (data->embedded)
@@ -1835,8 +1863,6 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
     }
     else
     {
-        if (!already_destroyed) detach_client_window( data, data->client_window );
-        else if (data->client_window) client_window_events_disable( data, data->client_window );
         XDeleteContext( data->display, data->whole_window, winContext );
         if (!already_destroyed)
         {
@@ -1845,7 +1871,7 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
         }
     }
     if (data->whole_colormap) XFreeColormap( data->display, data->whole_colormap );
-    data->whole_window = data->client_window = 0;
+    data->whole_window = 0;
     data->whole_colormap = 0;
     data->wm_state = WithdrawnState;
     data->net_wm_state = 0;
-- 
2.48.1


From 7b8bafaa4d8139af34e6befb863f84604b3a7a10 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:35:31 +0200
Subject: [PATCH 65/98] win32u: Pass a HDC parameter to vulkan_surface_detach.

---
 dlls/win32u/vulkan.c          | 38 +++++++++++++++--------------------
 dlls/winemac.drv/vulkan.c     |  2 +-
 dlls/winewayland.drv/vulkan.c |  2 +-
 dlls/winex11.drv/vulkan.c     |  4 ++--
 include/wine/vulkan_driver.h  |  2 +-
 5 files changed, 21 insertions(+), 27 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index f78e8b5db8f..9854709021f 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -60,7 +60,7 @@ struct surface
     struct list entry;
     VkSurfaceKHR host_surface;
     void *driver_private;
-    BOOL is_detached;
+    HDC offscreen_dc;
     HWND hwnd;
 };
 
@@ -100,18 +100,13 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         pthread_mutex_lock( &vulkan_mutex );
         list_add_tail( &offscreen_surfaces, &surface->entry );
         pthread_mutex_unlock( &vulkan_mutex );
-        driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
-        surface->is_detached = TRUE;
+        driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
         release_win_ptr( win );
-        if (toplevel != info->hwnd)
-        {
-            driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
-            surface->is_detached = TRUE;
-        }
+        if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
 
     surface->hwnd = info->hwnd;
@@ -130,6 +125,7 @@ static void win32u_vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR handle
     list_remove( &surface->entry );
     pthread_mutex_unlock( &vulkan_mutex );
 
+    if (surface->offscreen_dc) NtGdiDeleteObjectApp( surface->offscreen_dc );
     p_vkDestroySurfaceKHR( instance, surface->host_surface, NULL /* allocator */ );
     driver_funcs->p_vulkan_surface_destroy( surface->hwnd, surface->driver_private );
     free( surface );
@@ -213,7 +209,7 @@ static void nulldrv_vulkan_surface_attach( HWND hwnd, void *private )
 {
 }
 
-static void nulldrv_vulkan_surface_detach( HWND hwnd, void *private )
+static void nulldrv_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
 }
 
@@ -286,10 +282,10 @@ static void lazydrv_vulkan_surface_attach( HWND hwnd, void *private )
     return driver_funcs->p_vulkan_surface_attach( hwnd, private );
 }
 
-static void lazydrv_vulkan_surface_detach( HWND hwnd, void *private )
+static void lazydrv_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
     vulkan_driver_load();
-    return driver_funcs->p_vulkan_surface_detach( hwnd, private );
+    return driver_funcs->p_vulkan_surface_detach( hwnd, private, hdc );
 }
 
 static void lazydrv_vulkan_surface_presented( HWND hwnd, VkResult result )
@@ -353,9 +349,8 @@ void vulkan_detach_surfaces( struct list *surfaces )
 
     LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
     {
-        if (surface->is_detached) continue;
-        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
-        surface->is_detached = TRUE;
+        if (surface->offscreen_dc) continue;
+        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
 
     pthread_mutex_lock( &vulkan_mutex );
@@ -427,9 +422,8 @@ void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
     /* surfaces will be re-attached as needed from surface region updates */
     LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
     {
-        if (surface->is_detached) continue;
-        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
-        surface->is_detached = TRUE;
+        if (surface->offscreen_dc) continue;
+        driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
 
     append_window_surfaces( new_toplevel, &surfaces );
@@ -451,17 +445,17 @@ void vulkan_set_region( HWND toplevel, HRGN region )
         NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2 );
         is_clipped = NtGdiRectInRegion( region, &client_rect );
 
-        if (is_clipped && !surface->is_detached)
+        if (is_clipped && !surface->offscreen_dc)
         {
             TRACE( "surface %p is now clipped\n", surface->hwnd );
-            driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
-            surface->is_detached = TRUE;
+            driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
         }
-        else if (!is_clipped && surface->is_detached)
+        else if (!is_clipped && surface->offscreen_dc)
         {
             TRACE( "surface %p is now unclipped\n", surface->hwnd );
             driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
-            surface->is_detached = FALSE;
+            NtGdiDeleteObjectApp( surface->offscreen_dc );
+            surface->offscreen_dc = NULL;
         }
     }
 
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 9b033a84d57..736d0d397d5 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -182,7 +182,7 @@ static void macdrv_vulkan_surface_attach(HWND hwnd, void *private)
 {
 }
 
-static void macdrv_vulkan_surface_detach(HWND hwnd, void *private)
+static void macdrv_vulkan_surface_detach(HWND hwnd, void *private, HDC *hdc)
 {
 }
 
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index cd63981bf0d..175d8cfa49a 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -136,7 +136,7 @@ static void wayland_vulkan_surface_attach(HWND hwnd, void *private)
 {
 }
 
-static void wayland_vulkan_surface_detach(HWND hwnd, void *private)
+static void wayland_vulkan_surface_detach(HWND hwnd, void *private, HDC *hdc)
 {
 }
 
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index b979da1085e..cf5c44012c8 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -123,12 +123,12 @@ static void X11DRV_vulkan_surface_attach( HWND hwnd, void *private )
     }
 }
 
-static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private )
+static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
     Window client_window = (Window)private;
     struct x11drv_win_data *data;
 
-    TRACE( "%p %p\n", hwnd, private );
+    TRACE( "%p %p %p\n", hwnd, private, hdc );
 
     if ((data = get_win_data( hwnd )))
     {
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 180cff0e09b..74cdcd8987f 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -47,7 +47,7 @@ struct vulkan_driver_funcs
     VkResult (*p_vulkan_surface_create)(HWND, VkInstance, VkSurfaceKHR *, void **);
     void (*p_vulkan_surface_destroy)(HWND, void *);
     void (*p_vulkan_surface_attach)(HWND, void *);
-    void (*p_vulkan_surface_detach)(HWND, void *);
+    void (*p_vulkan_surface_detach)(HWND, void *, HDC *);
     void (*p_vulkan_surface_presented)(HWND, VkResult);
 
     VkBool32 (*p_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice, uint32_t);
-- 
2.48.1


From 1728e06920180bb3152119956a2b60b1e37599b4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:35:31 +0200
Subject: [PATCH 66/98] winex11: Return an offscreen HDC from
 vulkan_surface_detach.

---
 dlls/winex11.drv/vulkan.c | 26 +++++++++++++++++++-------
 1 file changed, 19 insertions(+), 7 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index cf5c44012c8..df6882271b4 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -37,6 +37,7 @@
 
 #include "wine/debug.h"
 #include "x11drv.h"
+#include "xcomposite.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -74,13 +75,6 @@ static VkResult X11DRV_vulkan_surface_create( HWND hwnd, VkInstance instance, Vk
 
     TRACE( "%p %p %p %p\n", hwnd, instance, surface, private );
 
-    /* TODO: support child window rendering. */
-    if (NtUserGetAncestor( hwnd, GA_PARENT ) != NtUserGetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     if (!(info.window = create_client_window( hwnd, &default_visual, default_colormap )))
     {
         ERR("Failed to allocate client window for hwnd=%p\n", hwnd);
@@ -118,6 +112,9 @@ static void X11DRV_vulkan_surface_attach( HWND hwnd, void *private )
 
     if ((data = get_win_data( hwnd )))
     {
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeUnredirectWindow( gdi_display, client_window, CompositeRedirectManual );
+#endif
         attach_client_window( data, client_window );
         release_win_data( data );
     }
@@ -125,6 +122,8 @@ static void X11DRV_vulkan_surface_attach( HWND hwnd, void *private )
 
 static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
 {
+    static const WCHAR displayW[] = {'D','I','S','P','L','A','Y'};
+    UNICODE_STRING device_str = RTL_CONSTANT_STRING(displayW);
     Window client_window = (Window)private;
     struct x11drv_win_data *data;
 
@@ -135,6 +134,19 @@ static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
         detach_client_window( data, client_window );
         release_win_data( data );
     }
+
+    if (hdc && (*hdc = NtGdiOpenDCW( &device_str, NULL, NULL, 0, TRUE, NULL, NULL, NULL )))
+    {
+        struct x11drv_escape_set_drawable escape = {0};
+        escape.code = X11DRV_SET_DRAWABLE;
+        escape.mode = IncludeInferiors;
+        escape.drawable = client_window;
+        NtUserGetClientRect( hwnd, &escape.dc_rect );
+        NtGdiExtEscape( *hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+#ifdef SONAME_LIBXCOMPOSITE
+        if (usexcomposite) pXCompositeRedirectWindow( gdi_display, client_window, CompositeRedirectManual );
+#endif
+    }
 }
 
 static void X11DRV_vulkan_surface_presented(HWND hwnd, VkResult result)
-- 
2.48.1


From 0c0dec9029cf6eb05afdf946d832aa4b601fbf17 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:42:21 +0200
Subject: [PATCH 67/98] win32u: Use GDI blit to implement partial or other
 process presentation.

---
 dlls/win32u/vulkan.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 9854709021f..49c8b20d5ce 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -61,6 +61,7 @@ struct surface
     VkSurfaceKHR host_surface;
     void *driver_private;
     HDC offscreen_dc;
+    HRGN region;
     HWND hwnd;
 };
 
@@ -109,6 +110,7 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private, &surface->offscreen_dc );
     }
 
+    surface->region = NtGdiCreateRectRgn( 0, 0, 0, 0 );
     surface->hwnd = info->hwnd;
     *handle = surface_to_handle( surface );
     return VK_SUCCESS;
@@ -128,6 +130,7 @@ static void win32u_vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR handle
     if (surface->offscreen_dc) NtGdiDeleteObjectApp( surface->offscreen_dc );
     p_vkDestroySurfaceKHR( instance, surface->host_surface, NULL /* allocator */ );
     driver_funcs->p_vulkan_surface_destroy( surface->hwnd, surface->driver_private );
+    NtGdiDeleteObjectApp( surface->region );
     free( surface );
 }
 
@@ -146,6 +149,26 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR
         struct surface *surface = surface_from_handle( surfaces[i] );
 
         driver_funcs->p_vulkan_surface_presented( surface->hwnd, swapchain_res );
+
+        if (swapchain_res >= VK_SUCCESS && surface->offscreen_dc)
+        {
+            UINT width, height;
+            RECT client_rect;
+            HDC hdc_dst;
+
+            NtUserGetClientRect( surface->hwnd, &client_rect );
+            width = client_rect.right - client_rect.left;
+            height = client_rect.bottom - client_rect.top;
+
+            WARN("Copying vulkan child window %p rect %s\n", surface->hwnd, wine_dbgstr_rect(&client_rect));
+
+            if ((hdc_dst = NtUserGetDCEx(surface->hwnd, surface->region, DCX_USESTYLE | DCX_CACHE)))
+            {
+                NtGdiStretchBlt(hdc_dst, client_rect.left, client_rect.top, width, height,
+                                surface->offscreen_dc, 0, 0, width, height, SRCCOPY, 0);
+                NtUserReleaseDC(surface->hwnd, hdc_dst);
+            }
+        }
     }
 
     return res;
@@ -449,6 +472,7 @@ void vulkan_set_region( HWND toplevel, HRGN region )
         {
             TRACE( "surface %p is now clipped\n", surface->hwnd );
             driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private, &surface->offscreen_dc );
+            NtGdiCombineRgn( surface->region, region, 0, RGN_COPY );
         }
         else if (!is_clipped && surface->offscreen_dc)
         {
-- 
2.48.1


From 7b8d4ed61c24a790b48be2236e3d47882df16e48 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 29 Jul 2024 21:20:40 -0700
Subject: [PATCH 68/98] Add in dpi context for nt calls

---
 dlls/win32u/vulkan.c      | 25 ++++---------------------
 dlls/winex11.drv/vulkan.c |  2 +-
 dlls/winex11.drv/window.c |  4 ++--
 3 files changed, 7 insertions(+), 24 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 49c8b20d5ce..251aece7252 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -155,8 +155,7 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR
             UINT width, height;
             RECT client_rect;
             HDC hdc_dst;
-
-            NtUserGetClientRect( surface->hwnd, &client_rect );
+            NtUserGetClientRect( surface->hwnd, &client_rect, get_dpi_for_window(surface->hwnd) );
             width = client_rect.right - client_rect.left;
             height = client_rect.bottom - client_rect.top;
 
@@ -456,6 +455,7 @@ void vulkan_set_region( HWND toplevel, HRGN region )
 {
     struct list surfaces = LIST_INIT(surfaces);
     struct surface *surface;
+    UINT_PTR dpi = (UINT_PTR)get_dpi_for_window(toplevel);
 
     enum_window_surfaces( toplevel, toplevel, &surfaces );
 
@@ -464,8 +464,8 @@ void vulkan_set_region( HWND toplevel, HRGN region )
         RECT client_rect;
         BOOL is_clipped;
 
-        NtUserGetClientRect( surface->hwnd, &client_rect );
-        NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2 );
+        NtUserGetClientRect( surface->hwnd, &client_rect, dpi );
+        NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2, dpi);
         is_clipped = NtGdiRectInRegion( region, &client_rect );
 
         if (is_clipped && !surface->offscreen_dc)
@@ -486,23 +486,6 @@ void vulkan_set_region( HWND toplevel, HRGN region )
     append_window_surfaces( toplevel, &surfaces );
 }
 
-/***********************************************************************
- *      __wine_get_vulkan_driver  (win32u.so)
- */
-const struct vulkan_funcs *__wine_get_vulkan_driver( UINT version )
-{
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
-
-    if (version != WINE_VULKAN_DRIVER_VERSION)
-    {
-        ERR( "version mismatch, vulkan wants %u but win32u has %u\n", version, WINE_VULKAN_DRIVER_VERSION );
-        return NULL;
-    }
-
-    pthread_once( &init_once, vulkan_init );
-    return vulkan_handle ? &vulkan_funcs : NULL;
-}
-
 #else /* SONAME_LIBVULKAN */
 
 void vulkan_detach_surfaces( struct list *surfaces )
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index df6882271b4..3d284daaf52 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -141,7 +141,7 @@ static void X11DRV_vulkan_surface_detach( HWND hwnd, void *private, HDC *hdc )
         escape.code = X11DRV_SET_DRAWABLE;
         escape.mode = IncludeInferiors;
         escape.drawable = client_window;
-        NtUserGetClientRect( hwnd, &escape.dc_rect );
+        NtUserGetClientRect( hwnd, &escape.dc_rect, NtUserGetThreadInfo()->dpi_context );
         NtGdiExtEscape( *hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 #ifdef SONAME_LIBXCOMPOSITE
         if (usexcomposite) pXCompositeRedirectWindow( gdi_display, client_window, CompositeRedirectManual );
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index ed77922e639..5c130840f5a 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1485,7 +1485,7 @@ static void sync_client_position( struct x11drv_win_data *data,
         HWND toplevel = NtUserGetAncestor( data->hwnd, GA_ROOT );
         POINT pos = {data->client_rect.left, data->client_rect.top};
 
-        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1 );
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1, NtUserGetThreadInfo()->dpi_context );
         changes.x = pos.x;
         changes.y = pos.y;
     }
@@ -1674,7 +1674,7 @@ void attach_client_window( struct x11drv_win_data *data, Window client_window )
 
         pos.x = data->client_rect.left;
         pos.y = data->client_rect.top;
-        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1 );
+        NtUserMapWindowPoints( toplevel, toplevel, &pos, 1, NtUserGetThreadInfo()->dpi_context );
     }
     if (!whole_window) whole_window = get_dummy_parent();
 
-- 
2.48.1


From 8ee0e0ae1d7ed2a7334d7843c143697e907c8bda Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 14:47:41 +0300
Subject: [PATCH 69/98] winewayland: Store visible_rect in wayland_win_data.

This allows wayland_win_data_update_wayland_surface() to be called
outside of WAYLAND_WindowPosChange, which will be needed in upcoming
commits.
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 17 +++++++++++------
 2 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index efb13821696..c25f5775762 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -294,6 +294,7 @@ struct wayland_win_data
     RECT window_rect;
     /* USER client rectangle relative to win32 parent window client area */
     RECT client_rect;
+    RECT visible_rect;
     BOOL managed;
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index dc6a6b7e03a..fda7139283f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -78,7 +78,8 @@ static struct rb_tree win_data_rb = { wayland_win_data_cmp_rb };
  */
 static struct wayland_win_data *wayland_win_data_create(HWND hwnd,
                                                         const RECT *window_rect,
-                                                        const RECT *client_rect)
+                                                        const RECT *client_rect,
+                                                        const RECT *visible_rect)
 {
     struct wayland_win_data *data;
     struct rb_entry *rb_entry;
@@ -94,6 +95,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd,
     data->hwnd = hwnd;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible_rect = *visible_rect;
 
     pthread_mutex_lock(&win_data_mutex);
 
@@ -200,14 +202,14 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
-static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, const RECT *visible_rect)
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
 {
     struct wayland_surface *surface = data->wayland_surface;
     HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
     BOOL visible, xdg_visible;
     WCHAR text[1024];
 
-    TRACE("hwnd=%p, rect=%s\n", data->hwnd, wine_dbgstr_rect(visible_rect));
+    TRACE("hwnd=%p\n", data->hwnd);
 
     /* We don't want wayland surfaces for child windows. */
     if (parent != NtUserGetDesktopWindow() && parent != 0)
@@ -251,7 +253,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     pthread_mutex_unlock(&surface->mutex);
 
     if (data->window_surface)
-        wayland_window_surface_update_wayland_surface(data->window_surface, visible_rect, surface);
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      &data->visible_rect, surface);
 
     /* Size/position changes affect the effective pointer constraint, so update
      * it as needed. */
@@ -438,7 +441,8 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const REC
           hwnd, swp_flags, shaped, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
           wine_dbgstr_rect(visible_rect));
 
-    if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect))) return FALSE; /* use default surface */
+    if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect, visible_rect)))
+        return FALSE; /* use default surface */
 
     parent = NtUserGetAncestor(hwnd, GA_PARENT);
     if ((parent && parent != NtUserGetDesktopWindow())) goto done; /* use default surface */
@@ -475,13 +479,14 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
 
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible_rect = *visible_rect;
     data->managed = managed;
 
     if (surface) window_surface_add_ref(surface);
     if (data->window_surface) window_surface_release(data->window_surface);
     data->window_surface = surface;
 
-    wayland_win_data_update_wayland_surface(data, visible_rect);
+    wayland_win_data_update_wayland_surface(data);
     if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
 
     wayland_win_data_release(data);
-- 
2.48.1


From c685252efbc4da1583b61edba9c86cde0bb9bd9c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:36:39 +0300
Subject: [PATCH 70/98] winewayland: Create subsurfaces for child windows.

Create (possibly nested) Wayland subsurfaces for all child windows,
to allow GL/VK contents to be presented onto them.
---
 dlls/winewayland.drv/wayland_surface.c | 61 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 12 +++++
 dlls/winewayland.drv/window.c          | 69 +++++++++++++++++---------
 3 files changed, 119 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 39c3976cdfd..de3307ec51e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -218,6 +218,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->xdg_surface = NULL;
     }
 
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
     if (surface->wl_surface)
     {
         wl_surface_destroy(surface->wl_surface);
@@ -253,6 +259,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface)
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel) goto err;
     xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface->hwnd);
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
     if (process_name)
         xdg_toplevel_set_app_id(surface->xdg_toplevel, process_name);
@@ -267,6 +274,53 @@ err:
     ERR("Failed to assign toplevel role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_make_subsurface
+ *
+ * Gives the subsurface role to a plain wayland surface.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wl_region *empty_region;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+    {
+        ERR("Failed to create client wl_subsurface\n");
+        goto err;
+    }
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+    surface->parent_hwnd = parent->hwnd;
+
+    /* Let parent handle all pointer events. */
+    empty_region = wl_compositor_create_region(process_wayland.wl_compositor);
+    if (!empty_region)
+    {
+        ERR("Failed to create wl_region\n");
+        goto err;
+    }
+    wl_surface_set_input_region(surface->wl_surface, empty_region);
+    wl_region_destroy(empty_region);
+
+    /* Present contents independently of the parent surface. */
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_display_flush(process_wayland.wl_display);
+
+    return;
+
+err:
+    wayland_surface_clear_role(surface);
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
 /**********************************************************************
  *          wayland_surface_clear_role
  *
@@ -290,10 +344,17 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         surface->xdg_surface = NULL;
     }
 
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
     memset(&surface->pending, 0, sizeof(surface->pending));
     memset(&surface->requested, 0, sizeof(surface->requested));
     memset(&surface->processing, 0, sizeof(surface->processing));
     memset(&surface->current, 0, sizeof(surface->current));
+    surface->parent_hwnd = 0;
 
     /* Ensure no buffer is attached, otherwise future role assignments may fail. */
     wl_surface_attach(surface->wl_surface, NULL, 0, 0);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c25f5775762..87d071707a8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -73,6 +73,13 @@ enum wayland_surface_config_state
     WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN = (1 << 3)
 };
 
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+};
+
 struct wayland_keyboard
 {
     struct wl_keyboard *wl_keyboard;
@@ -195,6 +202,7 @@ struct wayland_surface
     struct wl_surface *wl_surface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
+    struct wl_subsurface *wl_subsurface;
     struct wp_viewport *wp_viewport;
     pthread_mutex_t mutex;
     struct wayland_surface_config pending, requested, processing, current;
@@ -204,6 +212,8 @@ struct wayland_surface
     struct wayland_client_surface *client;
     int buffer_width, buffer_height;
     HCURSOR hcursor;
+    enum wayland_surface_role role;
+    HWND parent_hwnd;
 };
 
 struct wayland_shm_buffer
@@ -239,6 +249,8 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 struct wayland_surface *wayland_surface_create(HWND hwnd);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_make_toplevel(struct wayland_surface *surface);
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent);
 void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index fda7139283f..9be98363ac8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -134,19 +134,32 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
 }
 
 /***********************************************************************
- *           wayland_win_data_get
+ *           wayland_win_data_get_nolock
  *
- * Lock and return the data structure associated with a window.
+ * Return the data structure associated with a window. This function does
+ * not lock the win_data_mutex, so it must be externally synchronized.
  */
-struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+static struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd)
 {
     struct rb_entry *rb_entry;
 
-    pthread_mutex_lock(&win_data_mutex);
-
     if ((rb_entry = rb_get(&win_data_rb, hwnd)))
         return RB_ENTRY_VALUE(rb_entry, struct wayland_win_data, entry);
 
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    pthread_mutex_lock(&win_data_mutex);
+    if ((data = wayland_win_data_get_nolock(hwnd))) return data;
     pthread_mutex_unlock(&win_data_mutex);
 
     return NULL;
@@ -205,38 +218,42 @@ static void reapply_cursor_clipping(void)
 static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
 {
     struct wayland_surface *surface = data->wayland_surface;
-    HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
-    BOOL visible, xdg_visible;
+    struct wayland_win_data *parent_data;
+    enum wayland_surface_role role;
     WCHAR text[1024];
 
     TRACE("hwnd=%p\n", data->hwnd);
 
-    /* We don't want wayland surfaces for child windows. */
-    if (parent != NtUserGetDesktopWindow() && parent != 0)
+    if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
     {
-        if (data->window_surface)
-            wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
-        if (surface) wayland_surface_destroy(surface);
-        surface = NULL;
-        goto out;
+        parent_data = wayland_win_data_get_nolock(NtUserGetAncestor(data->hwnd, GA_PARENT));
+        if (parent_data && parent_data->wayland_surface)
+            role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+        else
+            role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
     }
+    else
+        role = WAYLAND_SURFACE_ROLE_NONE;
 
-    /* Otherwise ensure that we have a wayland surface. */
-    if (!surface && !(surface = wayland_surface_create(data->hwnd))) return;
+    /* We can temporarily remove a role from a wayland surface and add it back,
+     * but we can't change a surface's role.
+     * TODO: Recreate the surface to allow role change. */
+    if (surface && role && surface->role && role != surface->role) goto out;
 
-    visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
-    xdg_visible = surface->xdg_toplevel != NULL;
+    /* Ensure that we have a wayland surface. */
+    if (!surface && !(surface = wayland_surface_create(data->hwnd))) goto out;
 
     pthread_mutex_lock(&surface->mutex);
 
-    if (visible != xdg_visible)
+    if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE && surface->parent_hwnd != parent_data->hwnd))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
-        /* If the window is a visible toplevel make it a wayland
-         * xdg_toplevel. Otherwise keep it role-less to avoid polluting the
-         * compositor with empty xdg_toplevels. */
-        if (visible)
+        /* If the window is visible give it a role, otherwise keep it role-less
+         * to avoid polluting the compositor with unused role objects. */
+        if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
         {
             wayland_surface_make_toplevel(surface);
             if (surface->xdg_toplevel)
@@ -246,6 +263,12 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
                 wayland_surface_set_title(surface, text);
             }
         }
+        else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        {
+            pthread_mutex_lock(&parent_data->wayland_surface->mutex);
+            wayland_surface_make_subsurface(surface, parent_data->wayland_surface);
+            pthread_mutex_unlock(&parent_data->wayland_surface->mutex);
+        }
     }
 
     wayland_win_data_get_config(data, &surface->window);
-- 
2.48.1


From b986e08dba06d8d7b07a3c3afbf700508edd34c5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:37:18 +0300
Subject: [PATCH 71/98] winewayland: Handle subsurface reconfiguration.

---
 dlls/winewayland.drv/wayland_surface.c | 99 +++++++++++++++++++++-----
 dlls/winewayland.drv/window.c          | 11 ++-
 2 files changed, 91 insertions(+), 19 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index de3307ec51e..425c270099e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -568,6 +568,7 @@ static void wayland_surface_reconfigure_client(struct wayland_surface *surface)
     TRACE("hwnd=%p subsurface=%d,%d+%dx%d\n", surface->hwnd, x, y, width, height);
 
     wl_subsurface_set_position(surface->client->wl_subsurface, x, y);
+    wl_subsurface_place_above(surface->client->wl_subsurface, surface->wl_surface);
 
     if (surface->client->wp_viewport)
     {
@@ -589,29 +590,15 @@ static void wayland_surface_reconfigure_client(struct wayland_surface *surface)
 }
 
 /**********************************************************************
- *          wayland_surface_reconfigure
+ *          wayland_surface_reconfigure_xdg
  *
- * Reconfigures the wayland surface as needed to match the latest requested
+ * Reconfigures the xdg surface as needed to match the latest requested
  * state.
  */
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
+static BOOL wayland_surface_reconfigure_xdg(struct wayland_surface *surface,
+                                            int width, int height)
 {
     struct wayland_window_config *window = &surface->window;
-    int win_width, win_height, width, height;
-
-    if (!surface->xdg_toplevel) return TRUE;
-
-    win_width = surface->window.rect.right - surface->window.rect.left;
-    win_height = surface->window.rect.bottom - surface->window.rect.top;
-
-    wayland_surface_coords_from_window(surface, win_width, win_height,
-                                       &width, &height);
-
-    TRACE("hwnd=%p window=%dx%d,%#x processing=%dx%d,%#x current=%dx%d,%#x\n",
-          surface->hwnd, win_width, win_height, window->state,
-          surface->processing.width, surface->processing.height,
-          surface->processing.state, surface->current.width,
-          surface->current.height, surface->current.state);
 
     /* Acknowledge any compatible processed config. */
     if (surface->processing.serial && surface->processing.processed &&
@@ -644,6 +631,82 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
     }
 
     wayland_surface_reconfigure_geometry(surface, width, height);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_subsurface
+ *
+ * Reconfigures the subsurface as needed to match the latest requested
+ * state.
+ */
+static void wayland_surface_reconfigure_subsurface(struct wayland_surface *surface)
+{
+    struct wayland_surface *parent;
+    int local_x, local_y, x, y;
+
+    /* TODO: Locking the parent surface using the HWND may lead to a deadlock,
+     * since we will try to acquire the win_data_mutex while holding a surface
+     * mutex (from the argument of this function), whereas all other paths
+     * acquire the win_data_mutex before any surface mutex. */
+    if (surface->processing.serial && surface->processing.processed &&
+        (parent = wayland_surface_lock_hwnd(surface->parent_hwnd)))
+    {
+        /* For now we use a subsurface only for child windows, whose window
+         * coordinates are relative to the client area of their parent. */
+        local_x = surface->window.rect.left +
+                  (parent->window.client_rect.left - parent->window.rect.left);
+        local_y = surface->window.rect.top +
+                  (parent->window.client_rect.top - parent->window.rect.top);
+        wayland_surface_coords_from_window(surface, local_x, local_y, &x, &y);
+
+        TRACE("hwnd=%p pos=%d,%d\n", surface->hwnd, x, y);
+
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+        if (parent->client)
+            wl_subsurface_place_above(surface->wl_subsurface, parent->client->wl_surface);
+        else
+            wl_subsurface_place_above(surface->wl_subsurface, parent->wl_surface);
+        wl_surface_commit(parent->wl_surface);
+
+        pthread_mutex_unlock(&parent->mutex);
+
+        memset(&surface->processing, 0, sizeof(surface->processing));
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure
+ *
+ * Reconfigures the wayland surface as needed to match the latest requested
+ * state.
+ */
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
+{
+    int win_width, win_height, width, height;
+
+    win_width = surface->window.rect.right - surface->window.rect.left;
+    win_height = surface->window.rect.bottom - surface->window.rect.top;
+
+    wayland_surface_coords_from_window(surface, win_width, win_height,
+                                       &width, &height);
+
+    TRACE("hwnd=%p window=%dx%d,%#x processing=%dx%d,%#x current=%dx%d,%#x\n",
+          surface->hwnd, win_width, win_height, surface->window.state,
+          surface->processing.width, surface->processing.height,
+          surface->processing.state, surface->current.width,
+          surface->current.height, surface->current.state);
+
+    if (surface->xdg_toplevel)
+    {
+        if (!wayland_surface_reconfigure_xdg(surface, width, height)) return FALSE;
+    }
+    else if (surface->wl_subsurface)
+    {
+        wayland_surface_reconfigure_subsurface(surface);
+    }
+
     wayland_surface_reconfigure_size(surface, width, height);
     wayland_surface_reconfigure_client(surface);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9be98363ac8..6ee3707357a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -295,7 +295,16 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
 
     pthread_mutex_lock(&surface->mutex);
 
-    if (!surface->xdg_toplevel) goto out;
+    if (surface->wl_subsurface)
+    {
+        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd, surface->parent_hwnd);
+        /* Although subsurfaces don't have a dedicated surface config mechanism,
+         * we use the config fields to mark them as updated. */
+        surface->processing.serial = 1;
+        surface->processing.processed = TRUE;
+        goto out;
+    }
+    else if (!surface->xdg_toplevel) goto out;
 
     processing_config = surface->processing.serial &&
                         !surface->processing.processed;
-- 
2.48.1


From 308a3bd710564211c7bea2dc0a964e2a7d2349a8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 22 Jul 2024 11:57:53 +0300
Subject: [PATCH 72/98] winewayland: Use weak references for parent
 wayland_surfaces.

Don't access the parent wayland_surface through their HWND while holding
a lock to the child surface, since this requires acquiring the
win_data_mutex and may lead to a deadlock.

Instead introduce a weak reference mechanism and use that to directly
access the parent wayland_surface.
---
 dlls/winewayland.drv/wayland_surface.c | 58 +++++++++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h      |  7 +++-
 dlls/winewayland.drv/window.c          |  6 ++-
 3 files changed, 58 insertions(+), 13 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 425c270099e..57fd217e0d3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -168,6 +168,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
     }
 
     surface->window.scale = 1.0;
+    surface->weak_ref = 1;
 
     return surface;
 
@@ -176,6 +177,43 @@ err:
     return NULL;
 }
 
+/**********************************************************************
+ *          wayland_surface_get_weak_ref
+ *
+ * Gets a weak reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_get_weak_ref(struct wayland_surface *surface)
+{
+    InterlockedIncrement(&surface->weak_ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_get_weak_ref
+ *
+ * Releases a weak reference to a wayland_surface.
+ */
+void wayland_surface_release_weak_ref(struct wayland_surface *surface)
+{
+    if (InterlockedDecrement(&surface->weak_ref) > 0) return;
+    pthread_mutex_destroy(&surface->mutex);
+    free(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_lock_weak_ref
+ *
+ * Returns a locked wayland_surface from a weak reference, or NULL if the
+ * surface has been destroyed.
+ */
+struct wayland_surface *wayland_surface_lock_weak_ref(struct wayland_surface *surface)
+{
+    pthread_mutex_lock(&surface->mutex);
+    if (!surface->destroyed) return surface;
+    pthread_mutex_unlock(&surface->mutex);
+    return NULL;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
@@ -237,9 +275,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wl_display_flush(process_wayland.wl_display);
 
-    pthread_mutex_destroy(&surface->mutex);
-
-    free(surface);
+    wayland_surface_release_weak_ref(surface);
 }
 
 /**********************************************************************
@@ -297,7 +333,7 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     }
 
     surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
-    surface->parent_hwnd = parent->hwnd;
+    surface->parent_weak_ref = wayland_surface_get_weak_ref(parent);
 
     /* Let parent handle all pointer events. */
     empty_region = wl_compositor_create_region(process_wayland.wl_compositor);
@@ -350,11 +386,16 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         surface->wl_subsurface = NULL;
     }
 
+    if (surface->parent_weak_ref)
+    {
+        wayland_surface_release_weak_ref(surface->parent_weak_ref);
+        surface->parent_weak_ref = NULL;
+    }
+
     memset(&surface->pending, 0, sizeof(surface->pending));
     memset(&surface->requested, 0, sizeof(surface->requested));
     memset(&surface->processing, 0, sizeof(surface->processing));
     memset(&surface->current, 0, sizeof(surface->current));
-    surface->parent_hwnd = 0;
 
     /* Ensure no buffer is attached, otherwise future role assignments may fail. */
     wl_surface_attach(surface->wl_surface, NULL, 0, 0);
@@ -646,12 +687,9 @@ static void wayland_surface_reconfigure_subsurface(struct wayland_surface *surfa
     struct wayland_surface *parent;
     int local_x, local_y, x, y;
 
-    /* TODO: Locking the parent surface using the HWND may lead to a deadlock,
-     * since we will try to acquire the win_data_mutex while holding a surface
-     * mutex (from the argument of this function), whereas all other paths
-     * acquire the win_data_mutex before any surface mutex. */
     if (surface->processing.serial && surface->processing.processed &&
-        (parent = wayland_surface_lock_hwnd(surface->parent_hwnd)))
+        surface->parent_weak_ref &&
+        (parent = wayland_surface_lock_weak_ref(surface->parent_weak_ref)))
     {
         /* For now we use a subsurface only for child windows, whose window
          * coordinates are relative to the client area of their parent. */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87d071707a8..98cf4d41c10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -213,7 +213,9 @@ struct wayland_surface
     int buffer_width, buffer_height;
     HCURSOR hcursor;
     enum wayland_surface_role role;
-    HWND parent_hwnd;
+    LONG weak_ref;
+    BOOL destroyed;
+    struct wayland_surface *parent_weak_ref;
 };
 
 struct wayland_shm_buffer
@@ -247,6 +249,9 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
  */
 
 struct wayland_surface *wayland_surface_create(HWND hwnd);
+struct wayland_surface *wayland_surface_get_weak_ref(struct wayland_surface *surface);
+void wayland_surface_release_weak_ref(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_lock_weak_ref(struct wayland_surface *surface);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_make_toplevel(struct wayland_surface *surface);
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 6ee3707357a..4f3daca14d4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -247,7 +247,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
-        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE && surface->parent_hwnd != parent_data->hwnd))
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE &&
+         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
@@ -297,7 +298,8 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
 
     if (surface->wl_subsurface)
     {
-        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd, surface->parent_hwnd);
+        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd,
+              surface->parent_weak_ref ? surface->parent_weak_ref->hwnd : 0);
         /* Although subsurfaces don't have a dedicated surface config mechanism,
          * we use the config fields to mark them as updated. */
         surface->processing.serial = 1;
-- 
2.48.1


From bb6c7c6edeb3d61f55f27cb23a6a00a66f7b66ec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:39:01 +0300
Subject: [PATCH 73/98] winewayland: Support Wayland surface role changes.

Windows supports changing between the WS_CHILD and WS_POPUP window
styles which requires a Wayland surface role change between
wl_subsurface and xdg_toplevel.

Since Wayland doesn't support changing a surface's role, to support this
scenario we recreate the Wayland surface and adjust any related
subsurfaces to use the new parent surface.
---
 dlls/winewayland.drv/wayland_surface.c | 31 +++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/window.c          | 54 +++++++++++++++++++++-----
 3 files changed, 78 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 57fd217e0d3..4ace7a16246 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1004,6 +1004,37 @@ err:
     return NULL;
 }
 
+/**********************************************************************
+ *          wayland_surface_attach_client
+ */
+void wayland_surface_attach_client(struct wayland_surface *surface,
+                                   struct wayland_client_surface *client)
+{
+    assert(!surface->client && client);
+
+    if (client->wl_subsurface) wl_subsurface_destroy(client->wl_subsurface);
+
+    /* Create a new subsurface that it is attached to the proper parent. */
+    client->wl_subsurface =
+        wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
+                                        client->wl_surface,
+                                        surface->wl_surface);
+    if (!client->wl_subsurface)
+    {
+        ERR("Failed to create client wl_subsurface\n");
+        return;
+    }
+    /* Present contents independently of the parent surface. */
+    wl_subsurface_set_desync(client->wl_subsurface);
+
+    InterlockedIncrement(&client->ref);
+    surface->client = client;
+
+    wayland_surface_reconfigure_client(surface);
+    /* Commit to apply subsurface positioning. */
+    wl_surface_commit(surface->wl_surface);
+}
+
 static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
 {
     struct wayland_shm_buffer *shm_buffer = data;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 98cf4d41c10..87e0d29ef0c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -273,6 +273,8 @@ void wayland_surface_coords_to_window(struct wayland_surface *surface,
                                       int *window_x, int *window_y);
 struct wayland_client_surface *wayland_surface_get_client(struct wayland_surface *surface);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
+void wayland_surface_attach_client(struct wayland_surface *surface,
+                                   struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 4f3daca14d4..617ad6e392c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -36,6 +36,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+#define UWS_FORCE_ROLE_UPDATE 0x01
 
 /**********************************************************************
  *       get_win_monitor_dpi
@@ -215,14 +216,18 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
-static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+static void wayland_win_data_update_wayland_state(struct wayland_win_data *data);
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, UINT flags)
 {
     struct wayland_surface *surface = data->wayland_surface;
-    struct wayland_win_data *parent_data;
+    struct wayland_win_data *parent_data, *wwd;
     enum wayland_surface_role role;
+    BOOL surface_changed = FALSE;
+    struct wayland_client_surface *client = NULL;
     WCHAR text[1024];
 
-    TRACE("hwnd=%p\n", data->hwnd);
+    TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
     if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
     {
@@ -236,19 +241,33 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         role = WAYLAND_SURFACE_ROLE_NONE;
 
     /* We can temporarily remove a role from a wayland surface and add it back,
-     * but we can't change a surface's role.
-     * TODO: Recreate the surface to allow role change. */
-    if (surface && role && surface->role && role != surface->role) goto out;
+     * but we can't change a surface's role. */
+    if (surface && role && surface->role && role != surface->role)
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
+        pthread_mutex_lock(&surface->mutex);
+        if (surface->client) client = wayland_surface_get_client(surface);
+        pthread_mutex_unlock(&surface->mutex);
+        wayland_surface_destroy(surface);
+        surface = NULL;
+    }
 
     /* Ensure that we have a wayland surface. */
-    if (!surface && !(surface = wayland_surface_create(data->hwnd))) goto out;
+    if (!surface)
+    {
+        surface = wayland_surface_create(data->hwnd);
+        surface_changed = data->wayland_surface || surface;
+        if (!surface) goto out;
+    }
 
     pthread_mutex_lock(&surface->mutex);
 
     if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE &&
-         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd))
+         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd) ||
+        (flags & UWS_FORCE_ROLE_UPDATE))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
@@ -273,6 +292,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     }
 
     wayland_win_data_get_config(data, &surface->window);
+    if (client) wayland_surface_attach_client(surface, client);
 
     pthread_mutex_unlock(&surface->mutex);
 
@@ -287,6 +307,22 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 out:
     TRACE("hwnd=%p surface=%p=>%p\n", data->hwnd, data->wayland_surface, surface);
     data->wayland_surface = surface;
+    if (client) wayland_client_surface_release(client);
+
+    /* If the surface for this hwnd changed, update child surfaces. */
+    if (surface_changed)
+    {
+        RB_FOR_EACH_ENTRY(wwd, &win_data_rb, struct wayland_win_data, entry)
+        {
+            if (wwd->wayland_surface && NtUserGetAncestor(wwd->hwnd, GA_PARENT) == data->hwnd)
+            {
+                /* wayland_win_data_update_wayland_surface doesn't detect a surface
+                 * change without a window change, so force a role update. */
+                wayland_win_data_update_wayland_surface(wwd, UWS_FORCE_ROLE_UPDATE);
+                if (wwd->wayland_surface) wayland_win_data_update_wayland_state(wwd);
+            }
+        }
+    }
 }
 
 static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
@@ -520,7 +556,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     if (data->window_surface) window_surface_release(data->window_surface);
     data->window_surface = surface;
 
-    wayland_win_data_update_wayland_surface(data);
+    wayland_win_data_update_wayland_surface(data, 0);
     if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
 
     wayland_win_data_release(data);
-- 
2.48.1


From a90e7463c2aa28129a606297670514a7d5fb52af Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 16:29:48 +0300
Subject: [PATCH 74/98] winewayland: Ensure parent surface contents for
 accelerated windows.

---
 dlls/winewayland.drv/opengl.c | 26 +++++++++++++++-----------
 dlls/winewayland.drv/vulkan.c |  4 +++-
 2 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 994154968b3..eaf07cabc6a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -267,21 +267,25 @@ static void wayland_gl_drawable_sync_size(struct wayland_gl_drawable *gl)
 static void wayland_gl_drawable_sync_surface_state(struct wayland_gl_drawable *gl)
 {
     struct wayland_surface *wayland_surface;
+    HWND hwnd = gl->hwnd;
 
-    if (!(wayland_surface = wayland_surface_lock_hwnd(gl->hwnd))) return;
+    while (hwnd && (wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    {
+        wayland_surface_ensure_contents(wayland_surface);
 
-    wayland_surface_ensure_contents(wayland_surface);
+        /* Handle any processed configure request, to ensure the related
+         * surface state is applied by the compositor. */
+        if (wayland_surface->processing.serial &&
+            wayland_surface->processing.processed &&
+            wayland_surface_reconfigure(wayland_surface))
+        {
+            wl_surface_commit(wayland_surface->wl_surface);
+        }
 
-    /* Handle any processed configure request, to ensure the related
-     * surface state is applied by the compositor. */
-    if (wayland_surface->processing.serial &&
-        wayland_surface->processing.processed &&
-        wayland_surface_reconfigure(wayland_surface))
-    {
-        wl_surface_commit(wayland_surface->wl_surface);
+        hwnd = wayland_surface->parent_weak_ref ?
+               wayland_surface->parent_weak_ref->hwnd : 0;
+        pthread_mutex_unlock(&wayland_surface->mutex);
     }
-
-    pthread_mutex_unlock(&wayland_surface->mutex);
 }
 
 static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd,
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 175d8cfa49a..02f3a6104ef 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -144,7 +144,7 @@ static void wayland_vulkan_surface_presented(HWND hwnd, VkResult result)
 {
     struct wayland_surface *wayland_surface;
 
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    while (hwnd && (wayland_surface = wayland_surface_lock_hwnd(hwnd)))
     {
         wayland_surface_ensure_contents(wayland_surface);
 
@@ -157,6 +157,8 @@ static void wayland_vulkan_surface_presented(HWND hwnd, VkResult result)
             wl_surface_commit(wayland_surface->wl_surface);
         }
 
+        hwnd = wayland_surface->parent_weak_ref ?
+               wayland_surface->parent_weak_ref->hwnd : 0;
         pthread_mutex_unlock(&wayland_surface->mutex);
     }
 }
-- 
2.48.1


From 99313d5572a080d48ac30d43bd6bdca03c62ce41 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 12 Jul 2024 10:18:05 +0300
Subject: [PATCH 75/98] winewayland: Create Wayland surfaces for child windows
 on demand.

Wayland surfaces for child windows are currently only needed to render
GL/VK contents, so instead of creating them for all child windows,
create them only when GL/VK needs them.

Furthermore, these child window Wayland surfaces will now be anchored
directly to their top-level parent to avoid unnecessary nested
subsurface chains.
---
 dlls/winewayland.drv/opengl.c     |  2 +-
 dlls/winewayland.drv/vulkan.c     |  2 +-
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 99 ++++++++++++++++++++++++++++---
 4 files changed, 93 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index eaf07cabc6a..473ab4e23c3 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -165,7 +165,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     /* Get the client surface for the HWND. If don't have a wayland surface
      * (e.g., HWND_MESSAGE windows) just create a dummy surface to act as the
      * target render surface. */
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    if ((wayland_surface = wayland_surface_lock_accel_hwnd(hwnd)))
     {
         gl->client = wayland_surface_get_client(wayland_surface);
         client_width = wayland_surface->window.client_rect.right -
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 02f3a6104ef..ec855fb4b9d 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -85,7 +85,7 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, Vk
 
     TRACE("%p %p %p %p\n", hwnd, instance, surface, private);
 
-    wayland_surface = wayland_surface_lock_hwnd(hwnd);
+    wayland_surface = wayland_surface_lock_accel_hwnd(hwnd);
     if (!wayland_surface)
     {
         ERR("Failed to find wayland surface for hwnd=%p\n", hwnd);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87e0d29ef0c..378d408a719 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -261,6 +261,7 @@ void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
 struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd);
+struct wayland_surface *wayland_surface_lock_accel_hwnd(HWND hwnd);
 BOOL wayland_surface_reconfigure(struct wayland_surface *surface);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 617ad6e392c..e160ef9ce12 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -36,7 +36,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
-#define UWS_FORCE_ROLE_UPDATE 0x01
+#define UWS_FORCE_ROLE_UPDATE  0x01
+#define UWS_FORCE_CREATE       0x02
+#define UWS_NO_UPDATE_CHILDREN 0x04
 
 /**********************************************************************
  *       get_win_monitor_dpi
@@ -216,6 +218,37 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
+static struct wayland_win_data *wayland_win_data_get_top_parent(struct wayland_win_data *data)
+{
+    HWND desktop = NtUserGetDesktopWindow(), cur = data->hwnd, parent;
+
+    while ((parent = NtUserGetAncestor(cur, GA_PARENT)) && parent != desktop)
+        cur = parent;
+
+    /* Don't return ourselves */
+    return cur == data->hwnd ? NULL : wayland_win_data_get_nolock(cur);
+}
+
+static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data)
+{
+    HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
+
+    /* We want a Wayland surface for toplevel windows. */
+    if (!parent || parent == NtUserGetDesktopWindow()) return TRUE;
+
+    /* We want to keep the Wayland surface if we have a client area subsurface. */
+    if (data->wayland_surface)
+    {
+        BOOL has_client;
+        pthread_mutex_lock(&data->wayland_surface->mutex);
+        has_client = !!data->wayland_surface->client;
+        pthread_mutex_unlock(&data->wayland_surface->mutex);
+        if (has_client) return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void wayland_win_data_update_wayland_state(struct wayland_win_data *data);
 
 static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, UINT flags)
@@ -229,9 +262,24 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
-    if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
+    /* Destroy unused surfaces of child windows. */
+    if (!wayland_win_data_needs_wayland_surface(data) && !(flags & UWS_FORCE_CREATE))
+    {
+        if (surface)
+        {
+            if (data->window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
+            wayland_surface_destroy(surface);
+            surface = NULL;
+            surface_changed = TRUE;
+        }
+        goto out;
+    }
+
+    if (NtUserIsWindowVisible(data->hwnd))
     {
-        parent_data = wayland_win_data_get_nolock(NtUserGetAncestor(data->hwnd, GA_PARENT));
+        /* We anchor child windows to their toplevel parent window. */
+        parent_data = wayland_win_data_get_top_parent(data);
         if (parent_data && parent_data->wayland_surface)
             role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
         else
@@ -309,16 +357,18 @@ out:
     data->wayland_surface = surface;
     if (client) wayland_client_surface_release(client);
 
-    /* If the surface for this hwnd changed, update child surfaces. */
-    if (surface_changed)
+    if (!(flags & UWS_NO_UPDATE_CHILDREN))
     {
+        /* Update child window surfaces, but do not allow recursive updates. */
+        UINT wwd_flags = UWS_NO_UPDATE_CHILDREN;
+        /* wayland_win_data_update_wayland_surface doesn't detect a surface
+         * change without a window change, so force a role update. */
+        if (surface_changed) wwd_flags |= UWS_FORCE_ROLE_UPDATE;
         RB_FOR_EACH_ENTRY(wwd, &win_data_rb, struct wayland_win_data, entry)
         {
-            if (wwd->wayland_surface && NtUserGetAncestor(wwd->hwnd, GA_PARENT) == data->hwnd)
+            if (wwd->wayland_surface && NtUserIsChild(data->hwnd, wwd->hwnd))
             {
-                /* wayland_win_data_update_wayland_surface doesn't detect a surface
-                 * change without a window change, so force a role update. */
-                wayland_win_data_update_wayland_surface(wwd, UWS_FORCE_ROLE_UPDATE);
+                wayland_win_data_update_wayland_surface(wwd, wwd_flags);
                 if (wwd->wayland_surface) wayland_win_data_update_wayland_state(wwd);
             }
         }
@@ -805,6 +855,8 @@ void wayland_window_flush(HWND hwnd)
 
 /**********************************************************************
  *           wayland_surface_lock_hwnd
+ *
+ *  Get the locked surface for a window.
  */
 struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
 {
@@ -819,3 +871,32 @@ struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
 
     return surface;
 }
+
+/**********************************************************************
+ *           wayland_surface_lock_accel_hwnd
+ *
+ *  Get the locked surface for a window, creating the surface for a child
+ *  on demand if needed, so accelerated content can be presented into it.
+ */
+struct wayland_surface *wayland_surface_lock_accel_hwnd(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    struct wayland_surface *surface;
+
+    if (!data) return NULL;
+
+    /* If the hwnd is a child window we can anchor to some toplevel,
+     * create a wayland surface for it to be the target of accelerated
+     * rendering. */
+    if (!data->wayland_surface && wayland_win_data_get_top_parent(data))
+    {
+        wayland_win_data_update_wayland_surface(data, UWS_FORCE_CREATE);
+        if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
+    }
+
+    if ((surface = data->wayland_surface)) pthread_mutex_lock(&surface->mutex);
+
+    wayland_win_data_release(data);
+
+    return surface;
+}
-- 
2.48.1


From 9a93b5b17660c26e00275d028b7492fd052b4fd5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 23 Jul 2024 15:06:43 +0300
Subject: [PATCH 76/98] winewayland: Improve integration of GDI rendering with
 accelerated content.

Created dedicated Wayland surfaces and window surfaces for child windows
whose contents may be obscured by the client area subsurfaces we
use to display accelerated content.
---
 dlls/winewayland.drv/window.c | 30 ++++++++++++++++++++++++------
 1 file changed, 24 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e160ef9ce12..ca1bdca5ddb 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -229,7 +229,8 @@ static struct wayland_win_data *wayland_win_data_get_top_parent(struct wayland_w
     return cur == data->hwnd ? NULL : wayland_win_data_get_nolock(cur);
 }
 
-static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data)
+static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data,
+                                                   struct wayland_win_data *parent_data)
 {
     HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
 
@@ -246,6 +247,17 @@ static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data
         if (has_client) return TRUE;
     }
 
+    /* We want a Wayland surface if the parent has a client area subsurface
+     * which may obscure our contents (as a child window of that parent). */
+    if (parent_data->wayland_surface)
+    {
+        BOOL parent_has_client;
+        pthread_mutex_lock(&parent_data->wayland_surface->mutex);
+        parent_has_client = !!parent_data->wayland_surface->client;
+        pthread_mutex_unlock(&parent_data->wayland_surface->mutex);
+        if (parent_has_client) return TRUE;
+    }
+
     return FALSE;
 }
 
@@ -262,8 +274,12 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
+    /* We anchor child windows to their toplevel parent window. */
+    parent_data = wayland_win_data_get_top_parent(data);
+
     /* Destroy unused surfaces of child windows. */
-    if (!wayland_win_data_needs_wayland_surface(data) && !(flags & UWS_FORCE_CREATE))
+    if (!wayland_win_data_needs_wayland_surface(data, parent_data) &&
+        !(flags & UWS_FORCE_CREATE))
     {
         if (surface)
         {
@@ -278,8 +294,6 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     if (NtUserIsWindowVisible(data->hwnd))
     {
-        /* We anchor child windows to their toplevel parent window. */
-        parent_data = wayland_win_data_get_top_parent(data);
         if (parent_data && parent_data->wayland_surface)
             role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
         else
@@ -564,8 +578,12 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const REC
     if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect, visible_rect)))
         return FALSE; /* use default surface */
 
-    parent = NtUserGetAncestor(hwnd, GA_PARENT);
-    if ((parent && parent != NtUserGetDesktopWindow())) goto done; /* use default surface */
+    /* Use the default surface for child windows, unless we need a dedicated
+     * wayland surface in which case use a dedicated window surface. */
+     parent = NtUserGetAncestor(hwnd, GA_PARENT);
+     if (parent && parent != NtUserGetDesktopWindow() &&
+         !wayland_win_data_needs_wayland_surface(data, wayland_win_data_get_top_parent(data)))
+        goto done; /* use default surface */
 
     ret = TRUE;
 
-- 
2.48.1


From 6e92bfd4fcfd583417538797c02d1c828272242e Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 29 Jul 2024 21:55:20 -0700
Subject: [PATCH 77/98] Revert "wintypes: Hack in some calls to
 RoResolveNamespace"

This reverts commit 798d2c78c201121fad39391b1a0c4bbc611d030e.
---
 dlls/wintypes/main.c           | 84 ----------------------------------
 dlls/wintypes/tests/wintypes.c | 56 -----------------------
 2 files changed, 140 deletions(-)

diff --git a/dlls/wintypes/main.c b/dlls/wintypes/main.c
index 532a45f548d..7d59ab92c41 100644
--- a/dlls/wintypes/main.c
+++ b/dlls/wintypes/main.c
@@ -25,8 +25,6 @@
 #include "winstring.h"
 #include "wine/debug.h"
 #include "objbase.h"
-#include "roapi.h"
-
 
 #include "activation.h"
 #include "rometadataresolution.h"
@@ -381,92 +379,10 @@ HRESULT WINAPI RoResolveNamespace(HSTRING name, HSTRING windowsMetaDataDir,
                                   DWORD *metaDataFilePathsCount, HSTRING **metaDataFilePaths,
                                   DWORD *subNamespacesCount, HSTRING **subNamespaces)
 {
-    //https://learn.microsoft.com/en-us/windows/win32/api/rometadataresolution/nf-rometadataresolution-roresolvenamespace
-    //name L"Windows.Services.Store", windowsMetaDataDir L"", metaDataFilePaths 0000000000419088, subNamespaces 0000000000000000 stub!
-    const WCHAR *buffer = WindowsGetStringRawBuffer( name, NULL );
-    HSTRING *str = malloc(sizeof(HSTRING)), *str2 = malloc(sizeof(HSTRING));
-    // const WCHAR *path = L"C:\\Windows\\system32\\WinMetadata\\Windows.Services.winmd";
-    const WCHAR *path;
     FIXME("name %s, windowsMetaDataDir %s, metaDataFilePaths %p, subNamespaces %p stub!\n",
             debugstr_hstring(name), debugstr_hstring(windowsMetaDataDir),
             metaDataFilePaths, subNamespaces);
 
-    if(wcsstr(buffer, L"Windows.Storage") > 0){
-        FIXME("Found Windows.Storage \n");
-        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Storage.winmd";
-        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
-            FIXME("Setting vars\n");
-            *metaDataFilePaths = str;
-            *metaDataFilePathsCount = 1;
-            FIXME("Done setting\n");
-        } else {
-            FIXME("OUT OF MEMORY");
-            return E_OUTOFMEMORY;
-        }
-        // *subNamespacesCount = 0;
-        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
-        // *subNamespaces = str2;
-        FIXME("S_OK\n");
-        return S_OK;
-    }
-
-    if(wcsstr(buffer, L"Windows.ApplicationModel.DesignMode") > 0){
-        FIXME("Found Windows.ApplicationModel.DesignMode \n");
-        path = L"C:\\windows\\system32\\WinMetadata\\Windows.ApplicationModel.winmd";
-        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
-            FIXME("Setting vars\n");
-            *metaDataFilePaths = str;
-            *metaDataFilePathsCount = 1;
-            FIXME("Done setting\n");
-        } else {
-            FIXME("OUT OF MEMORY");
-            return E_OUTOFMEMORY;
-        }
-        // *subNamespacesCount = 0;
-        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
-        // *subNamespaces = str2;
-        FIXME("S_OK\n");
-        return S_OK;
-    }
-
-    if(wcsstr(buffer, L"Windows.Services.Store") > 0){
-        FIXME("Found Windows.Services.Store \n");
-        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Services.winmd";
-        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
-            FIXME("Setting vars\n");
-            *metaDataFilePaths = str;
-            *metaDataFilePathsCount = 1;
-            FIXME("Done setting\n");
-        } else {
-            FIXME("OUT OF MEMORY");
-            return E_OUTOFMEMORY;
-        }
-        // *subNamespacesCount = 0;
-        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
-        // *subNamespaces = str2;
-        FIXME("S_OK\n");
-        return S_OK;
-    }
-
-    if(wcsstr(buffer, L"Windows.Foundation") > 0){
-        FIXME("Found Windows.Foundation \n");
-        path = L"C:\\windows\\system32\\WinMetadata\\Windows.Foundation.winmd";
-        if(WindowsCreateString(path, wcslen(path), str) == S_OK) {
-            FIXME("Setting vars\n");
-            *metaDataFilePaths = str;
-            *metaDataFilePathsCount = 1;
-            FIXME("Done setting\n");
-        } else {
-            FIXME("OUT OF MEMORY");
-            return E_OUTOFMEMORY;
-        }
-        // *subNamespacesCount = 0;
-        // WindowsCreateString(L"StoreContract", wcslen(L"StoreContract"), str2);
-        // *subNamespaces = str2;
-        FIXME("S_OK\n");
-        return S_OK;
-    }
-
     if (!metaDataFilePaths && !subNamespaces)
         return E_INVALIDARG;
 
diff --git a/dlls/wintypes/tests/wintypes.c b/dlls/wintypes/tests/wintypes.c
index 4830078a754..0703582d325 100644
--- a/dlls/wintypes/tests/wintypes.c
+++ b/dlls/wintypes/tests/wintypes.c
@@ -456,64 +456,8 @@ static void test_IApiInformationStatics(void)
     IActivationFactory_Release(factory);
     RoUninitialize();
 }
-static HRESULT (WINAPI *pRoResolveNamespace)(HSTRING name, HSTRING windowsMetaDataDir,
-                                  DWORD packageGraphDirsCount, const HSTRING *packageGraphDirs,
-                                  DWORD *metaDataFilePathsCount, HSTRING **metaDataFilePaths,
-                                  DWORD *subNamespacesCount, HSTRING **subNamespaces);
-static void test_RoResolveNamespace(void) {
-    HSTRING name, windowsMetaDataDir, *metaDataFilePaths, *subNamespaces;
-    DWORD metaDataFilePathsCount, subNamespacesCount;
-    HRESULT hr;
-
-
-    HMODULE hmod = LoadLibraryA("wintypes.dll");
-    if(hmod == NULL) {
-        skip("Failed to load wintypes.dll\n");
-        return;
-    }
-    pRoResolveNamespace = (void*)GetProcAddress(hmod, "RoResolveNamespace");
-    if(pRoResolveNamespace == NULL) {
-        skip("Failed to get DllGetClassObject\n");
-        return;
-    }
-
-    
-    hr = WindowsCreateString( L"Windows.Services.Store", ARRAY_SIZE(L"Windows.Services.Store") - 1, &name );
-    ok(hr == S_OK, "Could not allocate HSTRING for name, hr %#lx.\n", hr);
-    wprintf(L"Testing %s\n", WindowsGetStringRawBuffer(name, 0));
-    hr = WindowsCreateString( L"", ARRAY_SIZE(L"") - 1, &windowsMetaDataDir );
-    ok(hr == S_OK, "Could not allocate HSTRING for windowsMetaDataDir, hr %#lx.\n", hr);
-    pRoResolveNamespace(name, windowsMetaDataDir,
-        0, NULL,
-        &metaDataFilePathsCount, &metaDataFilePaths,
-        &subNamespacesCount, &subNamespaces);
-
-    if (subNamespacesCount != 0)
-    {
-        wprintf(L"\nsub namespaces %d count:\n", subNamespacesCount);
-
-        for (DWORD i = 0; i < subNamespacesCount; i++)
-        {
-            wprintf(L"Subnamespace %d: %s\n", i, WindowsGetStringRawBuffer(subNamespaces[i], 0));
-        }
-    }
-
-    if (metaDataFilePathsCount != 0)
-    {
-        wprintf(L"\nmetaDataFilePathsCount %d\n", metaDataFilePathsCount);
-
-        for (DWORD i = 0; i < metaDataFilePathsCount; i++)
-        {
-            wprintf(L"Metadata file path %d: %s\n", i, WindowsGetStringRawBuffer(metaDataFilePaths[i], 0));
-        }
-        wprintf(L"\n");
-    }
-}
 
 START_TEST(wintypes)
 {
-        if (0) {
     test_IApiInformationStatics();
-        }
-    test_RoResolveNamespace();
 }
-- 
2.48.1


From e4f264a15b73ff7b59c0066798140b3e6925913b Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 10:37:51 -0700
Subject: [PATCH 78/98] __avg__ patch for dxcore

---
 dlls/dxcore/Makefile.in |   6 +-
 dlls/dxcore/adapter.c   | 342 +++++++++++++++++++++++++++++++++++++++
 dlls/dxcore/factory.c   | 346 ++++++++++++++++++++++++++++++++++++++++
 dlls/dxcore/main.c      |   9 +-
 4 files changed, 698 insertions(+), 5 deletions(-)
 create mode 100644 dlls/dxcore/adapter.c
 create mode 100644 dlls/dxcore/factory.c

diff --git a/dlls/dxcore/Makefile.in b/dlls/dxcore/Makefile.in
index 3a1d12c73e5..42269825d70 100644
--- a/dlls/dxcore/Makefile.in
+++ b/dlls/dxcore/Makefile.in
@@ -1,4 +1,8 @@
 MODULE = dxcore.dll
+IMPORTLIB = dxcore
+IMPORTS = dxgi dxguid uuid wined3d user32 win32u
 
 SOURCES = \
-	main.c
+	main.c \
+	factory.c \
+	adapter.c
diff --git a/dlls/dxcore/adapter.c b/dlls/dxcore/adapter.c
new file mode 100644
index 00000000000..21f4ff8c96b
--- /dev/null
+++ b/dlls/dxcore/adapter.c
@@ -0,0 +1,342 @@
+#include "private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
+
+
+// -- IDXCoreAdapter --
+static inline struct dxcore_adapter *impl_from_IDXCoreAdapter(IDXCoreAdapter *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_adapter, IDXCoreAdapter_iface);
+}
+
+
+HRESULT dxcore_adapter_pInstanceLuid(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    DXGI_ADAPTER_DESC desc;
+
+    if (lenBuffer < sizeof(LUID))
+        return E_INVALIDARG;
+
+    hr = IDXGIAdapter_GetDesc(this->adapter, &desc);
+    if (FAILED(hr))
+        return hr;
+
+    memcpy(buffer, (void*)&desc.AdapterLuid, sizeof(&desc.AdapterLuid));
+    return S_OK;
+}
+HRESULT dxcore_adapter_pDriverVersion(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    LARGE_INTEGER res;
+    if (lenBuffer < sizeof(uint64_t))
+        return E_INVALIDARG;
+
+    hr = IDXGIAdapter_CheckInterfaceSupport(this->adapter, &IID_IDXGIDevice, &res);
+    TRACE("Driver version; h %ld, l %ld, q %lld.\n", res.HighPart, res.LowPart, res.QuadPart);
+    memcpy(buffer, &res, sizeof(res));
+    return hr;
+}
+HRESULT dxcore_adapter_pDriverDescription(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    size_t len;
+    DXGI_ADAPTER_DESC desc;
+
+    hr = IDXGIAdapter_GetDesc(this->adapter, &desc);
+    if (FAILED(hr))
+        return hr;
+
+    len = wcslen(desc.Description);
+
+    if (lenBuffer < len+1)
+        return E_INVALIDARG;
+
+    wcstombs(buffer, desc.Description, sizeof(desc.Description));
+    TRACE("Driver Description: '%s'\n", (char *)buffer);
+    return S_OK;
+}
+HRESULT dxcore_adapter_pHardwareID(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    HRESULT hr;
+    DXGI_ADAPTER_DESC desc;
+    DXCoreHardwareID result;
+
+    if (lenBuffer < sizeof(result))
+        return E_INVALIDARG;
+
+    if (FAILED(hr = IDXGIAdapter_GetDesc(this->adapter, &desc)))
+        return hr;
+
+    result.vendorID = desc.VendorId;
+    result.deviceID = desc.DeviceId;
+    result.subSysID = desc.SubSysId;
+    result.revision = desc.Revision;
+
+    memcpy(buffer, &result, sizeof(result));
+    return S_OK;
+}
+// ...
+HRESULT dxcore_adapter_pIsHardware(struct dxcore_adapter *this, size_t lenBuffer, void *buffer) {
+    char result = TRUE;
+    if (lenBuffer < sizeof(result))
+        return E_INVALIDARG;
+
+    memcpy(buffer, &result, sizeof(result));
+    return S_OK;
+}
+
+
+HRESULT (*dxcore_adapter_properties[])(struct dxcore_adapter *, size_t, void*) = {
+    dxcore_adapter_pInstanceLuid,
+    dxcore_adapter_pDriverVersion,
+    dxcore_adapter_pDriverDescription,
+    dxcore_adapter_pHardwareID,
+    NULL, // dxcore_adapter_pKmdModelVersion,
+    NULL, // dxcore_adapter_pComputePreemptionGranularity,
+    NULL, // dxcore_adapter_pGraphicsPreemptionGranularity,
+    NULL, // dxcore_adapter_pDedicatedAdapterMemory,
+    NULL, // dxcore_adapter_pDedicatedSystemMemory,
+    NULL, // dxcore_adapter_pSharedSystemMemory,
+    NULL, // dxcore_adapter_pAcgCompatible,
+    dxcore_adapter_pIsHardware,
+    NULL, // dxcore_adapter_pIsIntegrated,
+    NULL, // dxcore_adapter_pIsDetachable,
+    NULL, // dxcore_adapter_pHardwareIDParts,
+    NULL, // dxcore_adapter_pPhysicalAdapterCount,
+    NULL, // dxcore_adapter_pAdapterEngineCount,
+    NULL // dxcore_adapter_pAdapterEngineName
+};
+
+size_t dxcore_adapter_sInstanceLuid(struct dxcore_adapter *adapter) {
+    return sizeof(LUID);
+}
+size_t dxcore_adapter_sDriverVersion(struct dxcore_adapter *adapter) {
+    return sizeof(uint64_t);
+}
+size_t dxcore_adapter_sDriverDescription(struct dxcore_adapter *adapter) {
+    DXGI_ADAPTER_DESC desc;
+    if (FAILED(IDXGIAdapter_GetDesc(adapter->adapter, &desc)))
+        return 0;
+    return wcslen(desc.Description)+1;
+}
+size_t dxcore_adapter_sHardwareID(struct dxcore_adapter *adapter) {
+    return sizeof(DXCoreHardwareID);
+}
+size_t dxcore_adapter_sIsHardware(struct dxcore_adapter *adapter) {
+    return 1;
+}
+
+size_t (*dxcore_adapter_property_sizes[])(struct dxcore_adapter *) = {
+    dxcore_adapter_sInstanceLuid,
+    dxcore_adapter_sDriverVersion,
+    dxcore_adapter_sDriverDescription,
+    dxcore_adapter_sHardwareID,
+    NULL, // dxcore_adapter_pKmdModelVersion,
+    NULL, // dxcore_adapter_pComputePreemptionGranularity,
+    NULL, // dxcore_adapter_pGraphicsPreemptionGranularity,
+    NULL, // dxcore_adapter_pDedicatedAdapterMemory,
+    NULL, // dxcore_adapter_pDedicatedSystemMemory,
+    NULL, // dxcore_adapter_pSharedSystemMemory,
+    NULL, // dxcore_adapter_pAcgCompatible,
+    dxcore_adapter_sIsHardware,
+    NULL, // dxcore_adapter_pIsIntegrated,
+    NULL, // dxcore_adapter_pIsDetachable,
+    NULL, // dxcore_adapter_pHardwareIDParts,
+    NULL, // dxcore_adapter_pPhysicalAdapterCount,
+    NULL, // dxcore_adapter_pAdapterEngineCount,
+    NULL // dxcore_adapter_pAdapterEngineName
+};
+
+
+ULONG STDMETHODCALLTYPE dxcore_adapter_AddRef(IDXCoreAdapter *iface) {
+    LONG count;
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    count = InterlockedIncrement(&this->refcount);
+    return count;
+}
+
+
+ULONG STDMETHODCALLTYPE dxcore_adapter_Release(IDXCoreAdapter *iface) {
+    LONG count;
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    count = InterlockedDecrement(&this->refcount);
+    if (!count) {
+        IUnknown_Release(&this->factory->IDXCoreAdapterFactory_iface);
+        free(this);
+    }
+    return count;
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryInterface(IDXCoreAdapter *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    *ppv = NULL;
+    TRACE("riid %s, factory %p.\n", wine_dbgstr_guid(riid), ppv);
+
+
+    if (IsEqualIID(riid, &IID_IUnknown)
+        ||IsEqualIID(riid, &IID_IDXCoreAdapter))
+    {
+        *ppv = iface;
+        iface->lpVtbl->AddRef(iface);
+        return S_OK;
+    }
+
+    /*
+    -- AFFINITY SPECIFIC --
+    d3d12_main.c/wined3d_get_adapter somehow gets passed this adapter object. To avoid having to rewrite d3d12
+    (which still allow users to inject other d3d implementations), we just return our inner IDXGIAdapter here.
+    */
+    return IUnknown_QueryInterface(this->adapter, riid, ppv);
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetFactory(IDXCoreAdapter *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+    IDXCoreAdapterFactory *factory = &this->factory->IDXCoreAdapterFactory_iface;
+    return IUnknown_QueryInterface(factory, riid, ppv);
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsPropertySupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterProperty property
+) {
+    TRACE("property %d\n", property);
+    return !((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL));
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetProperty(
+    IDXCoreAdapter *iface,
+    DXCoreAdapterProperty property, size_t buffer, void *propertyData
+) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+
+    TRACE("property %d, buffer %lld, propertyData %p\n",
+        property, (long long)buffer, propertyData);
+
+    if ((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL))
+        return DXGI_ERROR_UNSUPPORTED;
+
+    return dxcore_adapter_properties[property](this, buffer, propertyData);
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_GetPropertySize(
+    IDXCoreAdapter *iface,
+    DXCoreAdapterProperty property, size_t *bufferSize
+) {
+    struct dxcore_adapter *this = impl_from_IDXCoreAdapter(iface);
+    TRACE("property %d, bufferSize %p\n", property, bufferSize);
+
+    if ((property >= (sizeof(dxcore_adapter_properties)/sizeof(void*)))
+            || (dxcore_adapter_properties[property] == NULL))
+        return DXGI_ERROR_UNSUPPORTED;
+
+    *bufferSize = dxcore_adapter_property_sizes[property](this);
+    return S_OK;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsAttributeSupported(
+    IDXCoreAdapter *this,
+    REFGUID attributeGUID
+) {
+    FIXME("attributeGUID %s stub!\n", wine_dbgstr_guid(attributeGUID));
+    return TRUE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsQueryStateSupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state
+) {
+    FIXME("state %d stub!\n", state);
+    return FALSE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsSetStateSupported(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state
+) {
+    FIXME("state %d, stub!\n", state);
+    return FALSE;
+}
+
+
+BOOL STDMETHODCALLTYPE dxcore_adapter_IsValid(
+    IDXCoreAdapter *this
+) {
+    FIXME("assuming valid; stub!\n");
+    return TRUE;
+}
+
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_QueryState(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state,
+    size_t inputStateDetailsSize,
+    void const *inputStateDetails,
+    size_t outputBufferSize,
+    void * outputBuffer
+) {
+    FIXME("state %d, inputStateDetailSize %lld, inputStateDetails %p, stub!\n",
+        state, (long long)inputStateDetailsSize, inputStateDetails);
+    return DXGI_ERROR_UNSUPPORTED;
+}
+
+HRESULT STDMETHODCALLTYPE dxcore_adapter_SetState(
+    IDXCoreAdapter *this,
+    DXCoreAdapterState state,
+    size_t inputStateDetailsSize,
+    void const *inputStateDetails,
+    size_t inputDataSize,
+    void const *inputData
+) {
+    FIXME("state %d, inputStateDetailsSize %lld, inputStateDetails %p, stub!\n",
+        state, (long long)inputStateDetailsSize, inputStateDetails);
+    return DXGI_ERROR_UNSUPPORTED;
+}
+
+
+static IDXCoreAdapterVtbl dxcore_adapter_vtbl = {
+    dxcore_adapter_QueryInterface,
+    dxcore_adapter_AddRef,
+    dxcore_adapter_Release,
+    dxcore_adapter_IsValid,
+    dxcore_adapter_IsAttributeSupported,
+    dxcore_adapter_IsPropertySupported,
+    dxcore_adapter_GetProperty,
+    dxcore_adapter_GetPropertySize,
+    dxcore_adapter_IsQueryStateSupported,
+    dxcore_adapter_QueryState,
+    dxcore_adapter_IsSetStateSupported,
+    dxcore_adapter_SetState,
+    dxcore_adapter_GetFactory
+};
+
+
+HRESULT dxcore_adapter_create(
+    struct dxcore_factory *factory,
+    IDXGIAdapter *adapter,
+    struct dxcore_adapter **result
+) {
+    struct dxcore_adapter *this;
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    this->refcount = 1;
+    this->IDXCoreAdapter_iface.lpVtbl = &dxcore_adapter_vtbl;
+    this->factory = factory;
+    this->adapter = adapter;
+    IUnknown_AddRef(&factory->IDXCoreAdapterFactory_iface);
+    IUnknown_AddRef(adapter);
+
+    *result = this;
+    return S_OK;
+}
diff --git a/dlls/dxcore/factory.c b/dlls/dxcore/factory.c
new file mode 100644
index 00000000000..160cabea43e
--- /dev/null
+++ b/dlls/dxcore/factory.c
@@ -0,0 +1,346 @@
+#include "private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
+
+
+// -- IDXCoreAdapterList --
+static inline struct dxcore_adapter_list *impl_from_IDXCoreAdapterList(IDXCoreAdapterList *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_adapter_list, IDXCoreAdapterList_iface);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_adapter_list_AddRef(IDXCoreAdapterList *_this) {
+    ULONG refcount;
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(_this);
+
+    refcount = InterlockedIncrement(&this->refcount);
+    return refcount;
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_adapter_list_Release(IDXCoreAdapterList *_this) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(_this);
+
+    ULONG refcount = InterlockedDecrement(&this->refcount);
+    if (!refcount) {
+        IUnknown_Release(&this->factory->IDXCoreAdapterFactory_iface);
+        free(this);
+    }
+    return refcount;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_QueryInterface(
+    IDXCoreAdapterList *this,
+    REFIID iid, void **factory
+) {
+    *factory = NULL;
+    TRACE("this %p, riid, %s, factory, %p\n", this, wine_dbgstr_guid(iid), factory);
+    if (IsEqualIID(iid, &IID_IDXCoreAdapterList)
+        ||IsEqualIID(iid, &IID_IUnknown))
+    {
+        *factory = this;
+        this->lpVtbl->AddRef(this);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+
+static uint32_t STDMETHODCALLTYPE dxcore_adapter_list_GetAdapterCount(IDXCoreAdapterList *iface) {
+    UINT count;
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    count = this->len;
+    TRACE("adapter count %d\n", count);
+    return count;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetAdapter(IDXCoreAdapterList *iface, uint32_t index, REFIID riid, void **ppv) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    *ppv = NULL;
+    TRACE("index %d, riid %s, ppv %p\n", index, wine_dbgstr_guid(riid), ppv);
+
+    if (index >= this->len)
+        return E_INVALIDARG;
+
+    return IUnknown_QueryInterface(&this->adapters[index]->IDXCoreAdapter_iface, riid, ppv);
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsStale(IDXCoreAdapterList *this) {
+    FIXME("stub\n");
+    return FALSE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_Sort(
+    IDXCoreAdapterList *this,
+    uint32_t numPreferences, const DXCoreAdapterPreference *preferences
+) {
+    FIXME("numPreferences %d, preferences %p, stub\n", numPreferences, preferences);
+    return E_NOINTERFACE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_adapter_list_GetFactory(IDXCoreAdapterList *iface, REFIID riid, void **ppv) {
+    struct dxcore_adapter_list *this = impl_from_IDXCoreAdapterList(iface);
+
+    return IUnknown_QueryInterface(
+        &this->factory->IDXCoreAdapterFactory_iface,
+        riid, ppv
+    );
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_adapter_list_IsAdapterPreferenceSupported(
+    IDXCoreAdapterList *this, DXCoreAdapterPreference preference
+) {
+    FIXME("preference %d, stub\n", preference);
+    return FALSE;
+}
+
+
+static const IDXCoreAdapterListVtbl dxcore_adapter_list_vtbl = {
+    dxcore_adapter_list_QueryInterface,
+    dxcore_adapter_list_AddRef,
+    dxcore_adapter_list_Release,
+    dxcore_adapter_list_GetAdapter,
+    dxcore_adapter_list_GetAdapterCount,
+    dxcore_adapter_list_IsStale,
+    dxcore_adapter_list_GetFactory,
+    dxcore_adapter_list_Sort,
+    dxcore_adapter_list_IsAdapterPreferenceSupported
+};
+
+
+static HRESULT dxcore_adapter_list_init(
+    struct dxcore_adapter_list* this,
+    IDXGIFactory *dxgi_factory,
+    const GUID* filter
+) {
+    IDXGIAdapter *adapter;
+    HRESULT hr = 0;
+
+    this->len = 0;
+
+    // note: we're technically ignoring the filterAttributes
+    // feel free to add them if you know how
+
+    // count the adapters
+    while (!hr) {
+        hr = IDXGIFactory_EnumAdapters(
+            dxgi_factory, this->len, &adapter);
+        if (hr)
+            break;
+        IUnknown_Release(adapter);
+        this->len++;
+    }
+    if (!this->len)
+        return S_OK;
+
+    if (!(this->adapters = calloc(this->len, sizeof(struct dxcore_adapter*))))
+        return E_OUTOFMEMORY;
+
+    for (int i=0; i<this->len; i++) {
+        hr = IDXGIFactory_EnumAdapters(
+            dxgi_factory, i, &adapter);
+        if (hr)
+            break;
+        hr = dxcore_adapter_create(this->factory, adapter, &this->adapters[i]);
+        IUnknown_Release(adapter);
+        if (FAILED(hr))
+            break;
+    }
+    return hr;
+}
+
+
+static HRESULT dxcore_adapter_list_create(
+    struct dxcore_factory *factory,
+    uint32_t numAttributes, const GUID* filterAttributes,
+    REFIID riid, void **ppv
+) {
+    HRESULT result;
+    IDXCoreAdapterList *iface;
+    struct dxcore_adapter_list *this;
+    IDXGIFactory *dxgi_factory;
+
+    if (!numAttributes && filterAttributes)
+        return E_INVALIDARG;
+
+    if (FAILED(result = CreateDXGIFactory1(&IID_IDXGIFactory, (void**)&dxgi_factory)))
+        return result;
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    this->refcount = 1;
+    this->dxgi_factory = dxgi_factory;
+    IUnknown_AddRef(&factory->IDXCoreAdapterFactory_iface);
+    this->factory = factory;
+    iface = &this->IDXCoreAdapterList_iface;
+    iface->lpVtbl = &dxcore_adapter_list_vtbl;
+
+    if (FAILED(result = dxcore_adapter_list_init(this, dxgi_factory, filterAttributes))) {
+        IUnknown_Release(iface);
+        return result;
+    }
+
+    result = IUnknown_QueryInterface(iface, riid, ppv);
+    IUnknown_Release(iface);
+    return result;
+}
+
+
+// -- IDXCoreAdapterFactory --
+static struct dxcore_factory *dxcore_factory_singleton = NULL;
+
+
+static inline struct dxcore_factory *impl_from_IDXCoreAdapterFactory(IDXCoreAdapterFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct dxcore_factory, IDXCoreAdapterFactory_iface);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_factory_AddRef(IDXCoreAdapterFactory *iface) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+    return InterlockedIncrement(&this->refcount);
+}
+
+
+static ULONG STDMETHODCALLTYPE dxcore_factory_Release(IDXCoreAdapterFactory *iface) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+    ULONG refcount = InterlockedDecrement(&this->refcount);
+
+    if (!refcount) {
+        dxcore_factory_singleton = NULL;
+        free(this);
+    }
+    return refcount;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_QueryInterface(
+    IDXCoreAdapterFactory *this,
+    REFIID iid, void **factory
+) {
+    *factory = NULL;
+    TRACE("this %p, riid, %s, factory, %p\n", this, wine_dbgstr_guid(iid), factory);
+    if (IsEqualIID(iid, &IID_IDXCoreAdapterFactory)
+            || IsEqualIID(iid, &IID_IUnknown))
+    {
+        *factory = this;
+        this->lpVtbl->AddRef(this);
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_CreateAdapterList(
+    IDXCoreAdapterFactory *iface,
+    uint32_t num_attributes, const GUID *filter_attributes,
+    REFIID riid, void **ppv
+) {
+    struct dxcore_factory *this = impl_from_IDXCoreAdapterFactory(iface);
+
+    TRACE("num_attributes %d, filter_attributes %p, riid %s, ppv %p\n",
+        num_attributes, filter_attributes, wine_dbgstr_guid(riid), ppv);
+
+    return dxcore_adapter_list_create(this, num_attributes, filter_attributes, riid, ppv);
+}
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_GetAdapterByLuid(
+    IDXCoreAdapterFactory *this,
+    REFLUID adapter_luid,
+    REFIID riid, void **ppv
+) {
+    FIXME("this %p, adapter_luid %p, riid %s, ppv %p, stub!\n",
+        this, adapter_luid, wine_dbgstr_guid(riid), ppv);
+    return E_INVALIDARG;
+}
+
+
+static BOOL STDMETHODCALLTYPE dxcore_factory_IsNotificationTypeSupported(
+    IDXCoreAdapterFactory *this,
+    DXCoreNotificationType type
+) {
+    FIXME("type %i\n", type);
+    return (type < 2);
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_RegisterEventNotification(
+    IDXCoreAdapterFactory *this,
+    IUnknown *dxcore_object, DXCoreNotificationType type,
+    PFN_DXCORE_NOTIFICATION_CALLBACK callback, void *callback_context,
+    uint32_t *event_cookie
+) {
+    FIXME("dxcore_object %p, type %d, callback %p, callback_context %p, event_cookie %p\n",
+        dxcore_object, type, callback, callback_context, event_cookie);
+    if (type < 2)
+        return S_OK;
+    return DXGI_ERROR_INVALID_CALL;
+}
+
+
+static HRESULT STDMETHODCALLTYPE dxcore_factory_UnregisterEventNotification(
+    IDXCoreAdapterFactory *this,
+    uint32_t event_cookie
+) {
+    FIXME("event_cookie %d\n", event_cookie);
+    return S_OK;
+}
+
+
+static const struct IDXCoreAdapterFactoryVtbl dxcore_factory_vtbl = {
+    dxcore_factory_QueryInterface,
+    dxcore_factory_AddRef,
+    dxcore_factory_Release,
+    dxcore_factory_CreateAdapterList,
+    dxcore_factory_GetAdapterByLuid,
+    dxcore_factory_IsNotificationTypeSupported,
+    dxcore_factory_RegisterEventNotification,
+    dxcore_factory_UnregisterEventNotification,
+};
+
+
+static HRESULT dxcore_factory_init(struct dxcore_factory *this) {
+    dxcore_factory_singleton = this;
+    this->IDXCoreAdapterFactory_iface.lpVtbl = &dxcore_factory_vtbl;
+    this->refcount = 1;
+
+    return S_OK;
+}
+
+
+HRESULT dxcore_factory_create(REFIID riid, void **ppv) {
+    struct dxcore_factory *this;
+    HRESULT res;
+
+    *ppv = NULL;
+
+    if (dxcore_factory_singleton != NULL) {
+        TRACE("Reusing factory %p\n", dxcore_factory_singleton);
+        return IUnknown_QueryInterface(
+            &dxcore_factory_singleton->IDXCoreAdapterFactory_iface, riid, ppv
+        );
+    }
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    if (FAILED(res = dxcore_factory_init(this))) {
+        WARN("Failed to initialize factory, hr %#lx.\n", res);
+        free(this);
+        return res;
+    }
+
+    TRACE("Created factory %p.\n", this);
+    *ppv = this;
+    return S_OK;
+}
diff --git a/dlls/dxcore/main.c b/dlls/dxcore/main.c
index dcc294d04fa..ee7b0a21c03 100644
--- a/dlls/dxcore/main.c
+++ b/dlls/dxcore/main.c
@@ -16,13 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "dxcore.h"
-#include "wine/debug.h"
+#define DXCORE_INIT_GUID
+#include "dxcore_interface.h"
+
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
 
 HRESULT WINAPI DXCoreCreateAdapterFactory( REFIID riid, void **ppv )
 {
-    FIXME( "riid %s, ppv %p stub!\n", debugstr_guid(riid), ppv );
-    return E_NOINTERFACE;
+    TRACE( "riid %s, ppv %p\n", debugstr_guid(riid), ppv );
+    return dxcore_factory_create(riid, ppv);
 }
-- 
2.48.1


From b3e836f7c6bca10745384a7eab715c575ad0e180 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 10:38:13 -0700
Subject: [PATCH 79/98] __avg__ patch for opencl

---
 dlls/opencl/Makefile.in            |   3 +-
 dlls/opencl/cl_khr_d3d10_sharing.c | 164 +++++++++++++++++++++++++++++
 dlls/opencl/extensions.h           |  10 ++
 dlls/opencl/make_opencl            |  17 ++-
 dlls/opencl/opencl_types.h         |  23 ++++
 dlls/opencl/pe_thunks.c            |   7 ++
 dlls/opencl/pe_wrappers.c          |  30 +++++-
 7 files changed, 250 insertions(+), 4 deletions(-)
 create mode 100644 dlls/opencl/cl_khr_d3d10_sharing.c
 create mode 100644 dlls/opencl/extensions.h

diff --git a/dlls/opencl/Makefile.in b/dlls/opencl/Makefile.in
index 69df0a3073c..aac44bdb20d 100644
--- a/dlls/opencl/Makefile.in
+++ b/dlls/opencl/Makefile.in
@@ -6,4 +6,5 @@ SOURCES = \
 	pe_thunks.c \
 	pe_wrappers.c \
 	unix_thunks.c \
-	unix_wrappers.c
+	unix_wrappers.c \
+	cl_khr_d3d10_sharing.c
diff --git a/dlls/opencl/cl_khr_d3d10_sharing.c b/dlls/opencl/cl_khr_d3d10_sharing.c
new file mode 100644
index 00000000000..737afce9ea9
--- /dev/null
+++ b/dlls/opencl/cl_khr_d3d10_sharing.c
@@ -0,0 +1,164 @@
+#include "opencl_private.h"
+#include "opencl_types.h"
+#include "unixlib.h"
+#include "extensions.h"
+
+#define COBJMACROS
+#include "objbase.h"
+#include "initguid.h"
+#include "dxgi1_6.h"
+
+
+WINE_DEFAULT_DEBUG_CHANNEL(opencl);
+
+
+cl_int compare_dxgi_cl_device(IUnknown* d3d_adapter, cl_device_id cl_device, cl_bool *result) {
+    cl_int err;
+    IDXGIAdapter *this;
+    DXGI_ADAPTER_DESC info;
+    WCHAR *cl_name;
+    struct clGetDeviceInfo_params params;
+
+    // note: it is possible to compare the UUID if the device supports cl_khr_device_uuid
+    // and I would like to do that, but I also want built in DXVK support :)
+    // also SLI isn't really supported anymore so probs not relevant
+    if (FAILED(IUnknown_QueryInterface(d3d_adapter, &IID_IDXGIAdapter, (void **)&this))) {
+        ERR("Not a IDXGIAdapter %p.\n", d3d_adapter);
+        return CL_DEVICE_NOT_FOUND;
+    }
+
+    if (FAILED(IDXGIAdapter_GetDesc(this, &info))) {
+        ERR("Could not get adapter info %p.\n", this);
+        IUnknown_Release(this);
+        return CL_DEVICE_NOT_FOUND;
+    }
+    IUnknown_Release(this);
+
+
+    params.device = cl_device;
+    params.param_name = CL_DEVICE_NAME;
+    params.param_value = NULL;
+    params.param_value_size = 0;
+    params.param_value_size_ret = &params.param_value_size;
+    if ((err = OPENCL_CALL( clGetDeviceInfo, &params ))) {
+        ERR("Error getting device name of %p; %d.\n", cl_device, err);
+        return err;
+    }
+
+    if (!(params.param_value = calloc(params.param_value_size+1, 1)))
+        err = CL_OUT_OF_HOST_MEMORY;
+    if (!(cl_name = calloc(params.param_value_size+1, sizeof(WCHAR))))
+        err = CL_OUT_OF_HOST_MEMORY;
+
+    if (err) {
+        if (params.param_value) free(params.param_value);
+        if (cl_name) free(params.param_value);
+        return err;
+    }
+
+    if ((err = OPENCL_CALL( clGetDeviceInfo, &params ))) {
+        ERR("Error getting device name of %p; %d.\n", cl_device, err);
+        return err;
+    }
+
+    mbstowcs(cl_name, params.param_value, params.param_value_size);
+    free(params.param_value);
+
+    TRACE("cl_name %s, from %lld, d3d %s.\n", wine_dbgstr_w(cl_name), params.param_value_size, wine_dbgstr_w(info.Description));
+    *result = (wcscmp(cl_name, info.Description) == 0);
+
+    free(cl_name);
+
+    return CL_SUCCESS;
+}
+
+
+cl_int WINAPI dxgi_adapter_to_opencl(
+    IUnknown *adapter,
+    cl_platform_id platform,
+    cl_uint d3d_device_set,
+    cl_uint num_entries,
+    cl_device_id *devices,
+    cl_uint *num_devices
+) {
+    struct clGetDeviceIDs_params ids_params;
+
+    int i;
+    cl_int err;
+    cl_uint p_num_devices;
+    cl_bool same_device;
+
+
+    ids_params.platform = platform;
+    ids_params.device_type = CL_DEVICE_TYPE_ALL;
+    ids_params.num_devices = &ids_params.num_entries;
+    ids_params.num_entries = 0;
+    ids_params.devices = NULL;
+
+    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params )))
+        return err;
+
+    if (!(ids_params.devices = calloc(ids_params.num_entries, sizeof(cl_device_id))))
+        return CL_OUT_OF_HOST_MEMORY;
+
+    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params ))) {
+        free(ids_params.devices);
+        return err;
+    }
+
+    p_num_devices = 0;
+
+    // compare devices
+    for (i=0; i<ids_params.num_entries; i++) {
+        err = compare_dxgi_cl_device(adapter, ids_params.devices[i], &same_device);
+        if (err)
+            break;
+
+        if (!same_device)
+            continue;
+
+        if (devices) {
+            if (num_entries > p_num_devices) {
+                devices[p_num_devices] = ids_params.devices[i];
+            } else {
+                err = CL_INVALID_VALUE;
+                break;
+            }
+        }
+        p_num_devices++;
+    }
+
+    free(ids_params.devices);
+
+    if ((!err) && num_devices)
+        *num_devices = p_num_devices;
+
+    return err;
+}
+
+
+cl_int WINAPI clGetDeviceIDsFromD3D10KHR(
+    cl_platform_id platform,
+    cl_uint d3d_device_source,
+    void* d3d_object,
+    cl_uint d3d_device_set,
+    cl_uint num_entries,
+    cl_device_id* devices,
+    cl_uint* num_devices
+) {
+    TRACE("platform %p, device_source %d, d3d_object %p, d3d_device_set %u, num_entries %u, devices %p, num_devices %p semi-stub!\n",
+        platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
+
+    return dxgi_adapter_to_opencl((IUnknown*)d3d_object, platform,
+            d3d_device_set, num_entries, devices, num_devices);
+}
+
+
+void* cl_khr_d3d10_sharing_get_function(const char* name) {
+    // NOTE: other functions in this extension seem non-trivial to implement,
+    // involve lots of deep knowledge of D3D and OpenCL (which I do not have),
+    // and may involve a heavy rewrite of this whole OpenCL wrapper.
+    if (!strcmp(name, "clGetDeviceIDsFromD3D10KHR"))
+        return clGetDeviceIDsFromD3D10KHR;
+    return NULL;
+}
diff --git a/dlls/opencl/extensions.h b/dlls/opencl/extensions.h
new file mode 100644
index 00000000000..4c7e9955751
--- /dev/null
+++ b/dlls/opencl/extensions.h
@@ -0,0 +1,10 @@
+struct extension_info {
+    const char *name;
+    void* (*get_function)(const char*);
+};
+
+void* cl_khr_d3d10_sharing_get_function(const char*);
+
+static struct extension_info known_extensions[] = {
+    {"cl_khr_d3d10_sharing", cl_khr_d3d10_sharing_get_function}
+};
diff --git a/dlls/opencl/make_opencl b/dlls/opencl/make_opencl
index 6d9881c84b3..af2839b649c 100755
--- a/dlls/opencl/make_opencl
+++ b/dlls/opencl/make_opencl
@@ -60,7 +60,6 @@ my %unsupported_extensions =
         # Needs wined3d integration.
         "cl_intel_d3d11_nv12_media_sharing" => 1,
         "cl_intel_dx9_media_sharing" => 1,
-        "cl_khr_d3d10_sharing" => 1,
         "cl_khr_d3d11_sharing" => 1,
         "cl_khr_dx9_media_sharing" => 1,
         "cl_nv_d3d9_sharing" => 1,
@@ -76,6 +75,11 @@ my %unsupported_extensions =
         "cl_arm_shared_virtual_memory" => 1,
     );
 
+my %provided_extensions =
+    (
+        "cl_khr_d3d10_sharing" => 1,
+    );
+
 sub generate_pe_thunk($$)
 {
     my ($name, $func_ref) = @_;
@@ -509,6 +513,8 @@ sub parse_file($)
         # support KHR_gl_sharing yet, but we need to export the functions anyway
         # (some applications expect them to be present).
         parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_gl_sharing";
+        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_device_uuid";
+        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_d3d10_sharing";
     }
 }
 
@@ -532,7 +538,8 @@ print PE "/* Automatically generated from OpenCL registry files; DO NOT EDIT! */
 
 print PE "#include \"opencl_private.h\"\n";
 print PE "#include \"opencl_types.h\"\n";
-print PE "#include \"unixlib.h\"\n\n";
+print PE "#include \"unixlib.h\"\n";
+print PE "#include \"extensions.h\"\n\n";
 
 print PE "WINE_DEFAULT_DEBUG_CHANNEL(opencl);\n" if $gen_traces;
 
@@ -561,6 +568,12 @@ foreach (sort keys %unsupported_extensions)
 print PE <<EOF
     };
 
+    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
+    {
+        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
+            return TRUE;
+    }
+
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/opencl_types.h b/dlls/opencl/opencl_types.h
index b116bb55259..b752f6f13f8 100644
--- a/dlls/opencl/opencl_types.h
+++ b/dlls/opencl/opencl_types.h
@@ -79,6 +79,8 @@ typedef struct _cl_image_desc
  cl_mem mem_object;
  };
 } cl_image_desc;
+typedef cl_uint          cl_d3d10_device_source_khr;
+typedef cl_uint          cl_d3d10_device_set_khr;
 typedef cl_uint          cl_gl_context_info;
 typedef cl_uint          cl_gl_object_type;
 typedef cl_uint          cl_gl_texture_info;
@@ -90,6 +92,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_ADDRESS_MIRRORED_REPEAT 0x1134
 #define CL_ADDRESS_NONE 0x1130
 #define CL_ADDRESS_REPEAT 0x1133
+#define CL_ALL_DEVICES_FOR_D3D10_KHR 0x4013
 #define CL_ARGB 0x10B7
 #define CL_BGRA 0x10B6
 #define CL_BLOCKING CL_TRUE
@@ -103,6 +106,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CHAR_BIT 8
 #define CL_CHAR_MAX CL_SCHAR_MAX
 #define CL_CHAR_MIN CL_SCHAR_MIN
+#define CL_COMMAND_ACQUIRE_D3D10_OBJECTS_KHR 0x4017
 #define CL_COMMAND_ACQUIRE_GL_OBJECTS 0x11FF
 #define CL_COMMAND_BARRIER 0x1205
 #define CL_COMMAND_COPY_BUFFER 0x11F5
@@ -121,6 +125,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMMAND_READ_BUFFER 0x11F3
 #define CL_COMMAND_READ_BUFFER_RECT 0x1201
 #define CL_COMMAND_READ_IMAGE 0x11F6
+#define CL_COMMAND_RELEASE_D3D10_OBJECTS_KHR 0x4018
 #define CL_COMMAND_RELEASE_GL_OBJECTS 0x1200
 #define CL_COMMAND_TASK 0x11F1
 #define CL_COMMAND_UNMAP_MEM_OBJECT 0x11FD
@@ -131,6 +136,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMPILER_NOT_AVAILABLE -3
 #define CL_COMPILE_PROGRAM_FAILURE -15
 #define CL_COMPLETE 0x0
+#define CL_CONTEXT_D3D10_DEVICE_KHR 0x4014
+#define CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR 0x402C
 #define CL_CONTEXT_DEVICES 0x1081
 #define CL_CONTEXT_INTEROP_USER_SYNC 0x1085
 #define CL_CONTEXT_NUM_DEVICES 0x1083
@@ -138,6 +145,10 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CONTEXT_PROPERTIES 0x1082
 #define CL_CONTEXT_REFERENCE_COUNT 0x1080
 #define CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR 0x2006
+#define CL_D3D10_DEVICE_KHR 0x4010
+#define CL_D3D10_DXGI_ADAPTER_KHR 0x4011
+#define CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR -1004
+#define CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR -1005
 #define CL_DBL_DIG 15
 #define CL_DBL_EPSILON 2.220446049250313080847e-16
 #define CL_DBL_MANT_DIG 53
@@ -180,6 +191,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_LINKER_AVAILABLE 0x103E
 #define CL_DEVICE_LOCAL_MEM_SIZE 0x1023
 #define CL_DEVICE_LOCAL_MEM_TYPE 0x1022
+#define CL_DEVICE_LUID_KHR 0x106D
+#define CL_DEVICE_LUID_VALID_KHR 0x106C
 #define CL_DEVICE_MAX_CLOCK_FREQUENCY 0x100C
 #define CL_DEVICE_MAX_COMPUTE_UNITS 0x1002
 #define CL_DEVICE_MAX_CONSTANT_ARGS 0x1021
@@ -202,6 +215,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_INT 0x1038
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG 0x1039
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT 0x1037
+#define CL_DEVICE_NODE_MASK_KHR 0x106E
 #define CL_DEVICE_NOT_AVAILABLE -2
 #define CL_DEVICE_NOT_FOUND -1
 #define CL_DEVICE_OPENCL_C_VERSION 0x103D
@@ -237,9 +251,11 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_TYPE_CUSTOM (1 << 4)
 #define CL_DEVICE_TYPE_DEFAULT (1 << 0)
 #define CL_DEVICE_TYPE_GPU (1 << 2)
+#define CL_DEVICE_UUID_KHR 0x106A
 #define CL_DEVICE_VENDOR 0x102C
 #define CL_DEVICE_VENDOR_ID 0x1001
 #define CL_DEVICE_VERSION 0x102F
+#define CL_DRIVER_UUID_KHR 0x106B
 #define CL_DRIVER_VERSION 0x102D
 #define CL_EGL_DISPLAY_KHR 0x2009
 #define CL_EVENT_COMMAND_EXECUTION_STATUS 0x11D3
@@ -291,6 +307,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_HUGE_VALF ((cl_float) 1e50)
 #define CL_IMAGE_ARRAY_SIZE 0x1117
 #define CL_IMAGE_BUFFER 0x1118
+#define CL_IMAGE_D3D10_SUBRESOURCE_KHR 0x4016
 #define CL_IMAGE_DEPTH 0x1116
 #define CL_IMAGE_ELEMENT_SIZE 0x1111
 #define CL_IMAGE_FORMAT 0x1110
@@ -315,6 +332,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_INVALID_COMMAND_QUEUE -36
 #define CL_INVALID_COMPILER_OPTIONS -66
 #define CL_INVALID_CONTEXT -34
+#define CL_INVALID_D3D10_DEVICE_KHR -1002
+#define CL_INVALID_D3D10_RESOURCE_KHR -1003
 #define CL_INVALID_DEVICE -33
 #define CL_INVALID_DEVICE_PARTITION_COUNT -68
 #define CL_INVALID_DEVICE_TYPE -31
@@ -381,6 +400,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_LOCAL 0x1
 #define CL_LONG_MAX ((cl_long) 0x7FFFFFFFFFFFFFFFLL)
 #define CL_LONG_MIN ((cl_long) -0x7FFFFFFFFFFFFFFFLL - 1LL)
+#define CL_LUID_SIZE_KHR 8
 #define CL_LUMINANCE 0x10B9
 #define CL_MAP_FAILURE -12
 #define CL_MAP_READ (1 << 0)
@@ -392,6 +412,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_MEM_CONTEXT 0x1106
 #define CL_MEM_COPY_HOST_PTR (1 << 5)
 #define CL_MEM_COPY_OVERLAP -8
+#define CL_MEM_D3D10_RESOURCE_KHR 0x4015
 #define CL_MEM_FLAGS 0x1101
 #define CL_MEM_HOST_NO_ACCESS (1 << 9)
 #define CL_MEM_HOST_PTR 0x1103
@@ -427,6 +448,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_PLATFORM_PROFILE 0x0900
 #define CL_PLATFORM_VENDOR 0x0903
 #define CL_PLATFORM_VERSION 0x0901
+#define CL_PREFERRED_DEVICES_FOR_D3D10_KHR 0x4012
 #define CL_PROFILING_COMMAND_END 0x1283
 #define CL_PROFILING_COMMAND_QUEUED 0x1280
 #define CL_PROFILING_COMMAND_START 0x1282
@@ -496,4 +518,5 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_UNSIGNED_INT32 0x10DC
 #define CL_UNSIGNED_INT8 0x10DA
 #define CL_USHRT_MAX 65535
+#define CL_UUID_SIZE_KHR 16
 #define CL_WGL_HDC_KHR 0x200B
diff --git a/dlls/opencl/pe_thunks.c b/dlls/opencl/pe_thunks.c
index f34826e5377..288a19e7e7a 100644
--- a/dlls/opencl/pe_thunks.c
+++ b/dlls/opencl/pe_thunks.c
@@ -3,6 +3,7 @@
 #include "opencl_private.h"
 #include "opencl_types.h"
 #include "unixlib.h"
+#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -667,6 +668,12 @@ BOOL extension_is_supported( const char *name, size_t len )
         "cl_qcom_ext_host_ptr",
     };
 
+    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
+    {
+        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
+            return TRUE;
+    }
+
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/pe_wrappers.c b/dlls/opencl/pe_wrappers.c
index 3b6846009c1..00896b7c37c 100644
--- a/dlls/opencl/pe_wrappers.c
+++ b/dlls/opencl/pe_wrappers.c
@@ -22,6 +22,7 @@
 #include "opencl_types.h"
 #include "unixlib.h"
 #include "wine/wgl.h"
+#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -35,6 +36,13 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
 
     ext = unix_exts;
     win_size = 0;
+
+    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        if (!strstr(ext, known_extensions[i].name)) {
+            win_size += strlen(known_extensions[i].name) + 1;
+        }
+    }
+
     while (*ext)
     {
         const char *end = strchr( ext, ' ' );
@@ -53,6 +61,17 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
     if (size < win_size) return CL_INVALID_VALUE;
 
     win_exts[0] = 0;
+
+    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        size_t len;
+        if (!strstr(unix_exts, known_extensions[i].name)) {
+            len = strlen(known_extensions[i].name);
+            if (p != win_exts) *p++ = ' ';
+            memcpy(p, known_extensions[i].name, len);
+            p += len;
+        }
+    }
+
     ext = unix_exts;
     while (*ext)
     {
@@ -174,8 +193,17 @@ cl_int WINAPI clGetDeviceInfo( cl_device_id device, cl_device_info name,
 
 void * WINAPI clGetExtensionFunctionAddress( const char *func_name )
 {
+    int i;
     void * ret = 0;
     TRACE("(%s)\n",func_name);
+    for (i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        if (known_extensions->get_function == NULL)
+            continue;
+        ret = known_extensions->get_function(func_name);
+        if (ret)
+            break;
+    }
+    return ret;
 #if 0
     ret = clGetExtensionFunctionAddress(func_name);
 #else
@@ -197,7 +225,7 @@ cl_int WINAPI clSetCommandQueueProperty( cl_command_queue command_queue, cl_comm
 void * WINAPI clGetExtensionFunctionAddressForPlatform( cl_platform_id platform, const char *func_name )
 {
     FIXME( "(%p, %s) stub!\n", platform, debugstr_a(func_name) );
-    return NULL;
+    return clGetExtensionFunctionAddress(func_name);
 }
 
 
-- 
2.48.1


From d5b5b9540f490a5e25c2e131e46c83f095423c6b Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 10:38:45 -0700
Subject: [PATCH 80/98] __avg__ changes for RoResolveNamespace

---
 dlls/wintypes/main.c | 96 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 95 insertions(+), 1 deletion(-)

diff --git a/dlls/wintypes/main.c b/dlls/wintypes/main.c
index 7d59ab92c41..b6762cdd9d3 100644
--- a/dlls/wintypes/main.c
+++ b/dlls/wintypes/main.c
@@ -26,6 +26,7 @@
 #include "wine/debug.h"
 #include "objbase.h"
 
+#include "fileapi.h"
 #include "activation.h"
 #include "rometadataresolution.h"
 
@@ -379,6 +380,21 @@ HRESULT WINAPI RoResolveNamespace(HSTRING name, HSTRING windowsMetaDataDir,
                                   DWORD *metaDataFilePathsCount, HSTRING **metaDataFilePaths,
                                   DWORD *subNamespacesCount, HSTRING **subNamespaces)
 {
+    const WCHAR *_name = WindowsGetStringRawBuffer(name, NULL);
+    HRESULT err = S_OK;
+    WCHAR winMdDir[MAX_PATH+1];
+    WCHAR glob[MAX_PATH+10];
+    UINT32 winMdDir_len;
+    DWORD resCount = 0;
+    UINT16 resSize = 4;
+    HSTRING *res = calloc(resSize, sizeof(HRESULT));
+    HSTRING *oldres;
+    WIN32_FIND_DATAW f_data;
+    HANDLE f_handle;
+    WCHAR *basename;
+    WCHAR *fullname;
+    UINT32 i;
+
     FIXME("name %s, windowsMetaDataDir %s, metaDataFilePaths %p, subNamespaces %p stub!\n",
             debugstr_hstring(name), debugstr_hstring(windowsMetaDataDir),
             metaDataFilePaths, subNamespaces);
@@ -386,5 +402,83 @@ HRESULT WINAPI RoResolveNamespace(HSTRING name, HSTRING windowsMetaDataDir,
     if (!metaDataFilePaths && !subNamespaces)
         return E_INVALIDARG;
 
-    return RO_E_METADATA_NAME_NOT_FOUND;
+    if (subNamespaces) {
+        FIXME("subNamespaces not implemented\n");
+        return RO_E_METADATA_NAME_NOT_FOUND;
+    }
+
+    memset(winMdDir, 0, (MAX_PATH+1)*sizeof(WCHAR));
+    memset(glob, 0, (MAX_PATH+1)*sizeof(WCHAR));
+
+    if (!windowsMetaDataDir) {
+        winMdDir_len = GetWindowsDirectoryW(winMdDir, MAX_PATH);
+        wcscat(winMdDir, L"\\system32\\WinMetadata");
+        winMdDir_len += 22;
+    } else {
+        winMdDir_len = WindowsGetStringLen(windowsMetaDataDir);
+        memcpy(winMdDir, WindowsGetStringRawBuffer(windowsMetaDataDir, NULL), sizeof(WCHAR)*winMdDir_len);
+    }
+
+    memcpy(glob, winMdDir, wcslen(winMdDir)*sizeof(WCHAR));
+    wcscat(glob, L"\\*.winmd");
+
+    f_handle = FindFirstFileW(glob, &f_data);
+    if (f_handle == INVALID_HANDLE_VALUE) {
+        FIXME("NO .WINMD FILES.\n");
+        return RO_E_METADATA_NAME_NOT_FOUND;
+    }
+    if (res == NULL)
+        return E_OUTOFMEMORY;
+    basename = calloc(MAX_PATH+1, sizeof(WCHAR));
+    if (basename == NULL)
+        return E_OUTOFMEMORY;
+    fullname = calloc(MAX_PATH+wcslen(winMdDir)+1, sizeof(WCHAR));
+    if (fullname == NULL)
+        return E_OUTOFMEMORY;
+    while (err == S_OK) {
+        memset(basename, 0, (MAX_PATH+1)*sizeof(WCHAR));
+        memset(fullname, 0, (MAX_PATH+wcslen(winMdDir)+1)*sizeof(WCHAR));
+        lstrcpynW(basename, f_data.cFileName, wcslen(f_data.cFileName) - 5);
+        wcscpy(fullname, winMdDir);
+        if (
+            (wcslen(_name) >= wcslen(basename) && wcsstr(_name, basename) == _name)
+            || (wcslen(basename) > wcslen(_name) && wcsstr(basename, _name) == basename)
+        ) {
+            resCount ++;
+            if (resCount > resSize) {
+                oldres = res;
+                res = realloc(res, sizeof(HSTRING)*resSize*2);
+                if (res == NULL) {
+                    err = E_OUTOFMEMORY;
+                    res = oldres;
+                    break;
+                }
+            }
+
+            wcscat(fullname, L"\\");
+            wcscat(fullname, f_data.cFileName);
+            err = WindowsCreateString(fullname, wcslen(fullname), &res[resCount-1]);
+            FIXME("RESOLVED: %s\n", wine_dbgstr_hstring(res[resCount-1]));
+        }
+        if (!FindNextFileW(f_handle, &f_data))
+            break;
+    }
+    FindClose(f_handle);
+    free(basename);
+    free(fullname);
+    if (!err) {
+        if (resCount > 0) {
+            *metaDataFilePaths = res;
+            *metaDataFilePathsCount = resCount;
+        } else {
+            err = RO_E_METADATA_NAME_NOT_FOUND;
+        }
+    } else {
+        for (i=0; i<resCount-1; i++) {
+            WindowsDeleteString(res[i]);
+        }
+        free(res);
+    }
+
+    return err;
 }
-- 
2.48.1


From 148655be5ab46b1f39b60f30c837b73d5f190b5a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 21:22:18 +0200
Subject: [PATCH 81/98] winewayland: Post WM_WAYLAND_CONFIGURE outside of the
 surface lock.

---
 dlls/winewayland.drv/wayland_surface.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 4ace7a16246..6b582ada765 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -38,7 +38,7 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface;
-    BOOL initial_configure = FALSE;
+    BOOL should_post = FALSE, initial_configure = FALSE;
     HWND hwnd = data;
 
     TRACE("serial=%u\n", serial);
@@ -52,16 +52,17 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
          * avoid sending another message to reduce message queue traffic. */
-        BOOL should_post = surface->requested.serial == 0;
+        should_post = surface->requested.serial == 0;
         initial_configure = surface->current.serial == 0;
         surface->pending.serial = serial;
         surface->requested = surface->pending;
         memset(&surface->pending, 0, sizeof(surface->pending));
-        if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
     }
 
     pthread_mutex_unlock(&surface->mutex);
 
+    if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+
     /* Flush the window surface in case there is content that we weren't
      * able to flush before due to the lack of the initial configure. */
     if (initial_configure) wayland_window_flush(hwnd);
-- 
2.48.1


From 92007b1352c024fc2309fc152c9b316b4bff2bf3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 82/98] winewayland: Use WL_SHM_FORMAT_ARGB8888 format for
 window surfaces.

---
 dlls/winewayland.drv/window_surface.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index e9eb74b17ca..3b354925a8e 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -154,7 +154,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
         if (nbuffers < 3)
         {
             shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
-                                                   WL_SHM_FORMAT_XRGB8888);
+                                                   WL_SHM_FORMAT_ARGB8888);
             if (shm_buffer)
             {
                 /* Buffer events go to their own queue so that we can dispatch
@@ -262,7 +262,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
     {
         const char *src;
         char *dst;
-        int y, width_bytes, height;
+        int x, y, width_bytes, height;
         RECT rc;
 
         TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
@@ -279,12 +279,14 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
         if (width_bytes == src_stride && width_bytes == dst_stride)
         {
             memcpy(dst, src, height * width_bytes);
+            for (x = 3; x < height * width_bytes; x += bpp) dst[x] = 0xff;
             continue;
         }
 
         for (y = 0; y < height; y++)
         {
             memcpy(dst, src, width_bytes);
+            for (x = 3; x < width_bytes; x += bpp) dst[x] = 0xff;
             src += src_stride;
             dst += dst_stride;
         }
-- 
2.48.1


From 5f1431ce9cbd3f12d3045973bdc9df5dd4a05167 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 83/98] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 29 +++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 3b354925a8e..961ba511c7a 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -317,6 +317,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_data
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -387,6 +415,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     }
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
 
     pthread_mutex_lock(&wws->wayland_surface->mutex);
     if (wayland_surface_reconfigure(wws->wayland_surface))
-- 
2.48.1


From dbd7521147b3c76504cf142beb346ae468f48003 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Jul 2024 11:03:57 +0200
Subject: [PATCH 84/98] win32u: Simplify offscreen surface previous surface
 reuse check.

---
 dlls/win32u/dce.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/dce.c b/dlls/win32u/dce.c
index 4a672d6c519..8bbd2592cf4 100644
--- a/dlls/win32u/dce.c
+++ b/dlls/win32u/dce.c
@@ -125,10 +125,7 @@ void create_offscreen_window_surface( HWND hwnd, const RECT *surface_rect, struc
     TRACE( "hwnd %p, surface_rect %s, window_surface %p.\n", hwnd, wine_dbgstr_rect( surface_rect ), window_surface );
 
     /* check that old surface is an offscreen_window_surface, or release it */
-    if ((previous = *window_surface) && previous->funcs == &offscreen_window_surface_funcs &&
-        EqualRect( surface_rect, &previous->rect )) return;
-    if (previous) window_surface_release( previous );
-    *window_surface = NULL;
+    if ((previous = *window_surface) && previous->funcs == &offscreen_window_surface_funcs) return;
 
     memset( info, 0, sizeof(*info) );
     info->bmiHeader.biSize        = sizeof(info->bmiHeader);
@@ -145,6 +142,8 @@ void create_offscreen_window_surface( HWND hwnd, const RECT *surface_rect, struc
 
     TRACE( "created window surface %p\n", surface );
     *window_surface = surface;
+
+    if (previous) window_surface_release( previous );
 }
 
 /* window surface common helpers */
-- 
2.48.1


From 303fec1c1d251c800c94edf63f8c6f0018671783 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Jul 2024 11:03:57 +0200
Subject: [PATCH 85/98] winex11: Rely on win32u previous surface reuse.

---
 dlls/winex11.drv/bitblt.c | 16 +++-------------
 1 file changed, 3 insertions(+), 13 deletions(-)

diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index 8c3e4f54437..8bd27fd13e1 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -1988,32 +1988,22 @@ HRGN expose_surface( struct window_surface *window_surface, const RECT *rect )
  */
 BOOL X11DRV_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface )
 {
+    struct window_surface *previous;
     struct x11drv_win_data *data;
     BOOL layered = NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
 
     TRACE( "hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect( surface_rect ), surface );
 
+    if ((previous = *surface) && previous->funcs == &x11drv_surface_funcs) return TRUE;
     if (!(data = get_win_data( hwnd ))) return TRUE; /* use default surface */
+    if (previous) window_surface_release( previous );
 
-    if (*surface) window_surface_release( *surface );
     *surface = NULL;  /* indicate that we want to draw directly to the window */
-
     if (data->embedded) goto done; /* draw directly to the window */
     if (data->whole_window == root_window) goto done; /* draw directly to the window */
     if (data->client_window) goto done; /* draw directly to the window */
     if (!client_side_graphics && !layered) goto done; /* draw directly to the window */
 
-    if (data->surface)
-    {
-        if (EqualRect( &data->surface->rect, surface_rect ))
-        {
-            /* existing surface is good enough */
-            window_surface_add_ref( data->surface );
-            *surface = data->surface;
-            goto done;
-        }
-    }
-
     *surface = create_surface( data->hwnd, data->whole_window, &data->vis, surface_rect, FALSE );
 
 done:
-- 
2.48.1


From f5cce2b2e8d9178b769ad67fdc7506e459d4a8f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Jul 2024 11:03:57 +0200
Subject: [PATCH 86/98] wineandroid: Rely on win32u previous surface reuse.

---
 dlls/wineandroid.drv/window.c | 17 +++--------------
 1 file changed, 3 insertions(+), 14 deletions(-)

diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
index 553ed985fae..0d6df89d06f 100644
--- a/dlls/wineandroid.drv/window.c
+++ b/dlls/wineandroid.drv/window.c
@@ -1067,28 +1067,17 @@ done:
  */
 BOOL ANDROID_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface )
 {
+    struct window_surface *previous;
     struct android_win_data *data;
 
     TRACE( "hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect( surface_rect ), surface );
 
+    if ((previous = *surface) && previous->funcs == &android_surface_funcs) return TRUE;
     if (!(data = get_win_data( hwnd ))) return TRUE; /* use default surface */
+    if (previous) window_surface_release( previous );
 
-    if (data->surface)
-    {
-        if (EqualRect( &data->surface->rect, surface_rect ))
-        {
-            /* existing surface is good enough */
-            window_surface_add_ref( data->surface );
-            if (*surface) window_surface_release( *surface );
-            *surface = data->surface;
-            goto done;
-        }
-    }
-
-    if (*surface) window_surface_release( *surface );
     *surface = create_surface( data->hwnd, surface_rect );
 
-done:
     release_win_data( data );
     return TRUE;
 }
-- 
2.48.1


From 9304bdc096cb259c82701491068f9201d165419d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Jul 2024 11:03:57 +0200
Subject: [PATCH 87/98] winewayland: Rely on win32u previous surface reuse.

---
 dlls/winewayland.drv/window_surface.c | 18 +++---------------
 1 file changed, 3 insertions(+), 15 deletions(-)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 961ba511c7a..8221423f336 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -543,29 +543,17 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  */
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface)
 {
+    struct window_surface *previous;
     struct wayland_win_data *data;
 
     TRACE("hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect(surface_rect), surface);
 
+    if ((previous = *surface) && previous->funcs == &wayland_window_surface_funcs) return TRUE;
     if (!(data = wayland_win_data_get(hwnd))) return TRUE; /* use default surface */
-
-    /* Release the dummy surface wine provides for toplevels. */
-    if (*surface) window_surface_release(*surface);
-    *surface = NULL;
-
-    /* Check if we can reuse our current window surface. */
-    if (data->window_surface &&
-        EqualRect(&data->window_surface->rect, surface_rect))
-    {
-        window_surface_add_ref(data->window_surface);
-        *surface = data->window_surface;
-        TRACE("reusing surface %p\n", *surface);
-        goto done;
-    }
+    if (previous) window_surface_release(previous);
 
     *surface = wayland_window_surface_create(data->hwnd, surface_rect);
 
-done:
     wayland_win_data_release(data);
     return TRUE;
 }
-- 
2.48.1


From aefb68eedbb7bb213f1e159e15aa8e93ae2bc1ff Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 17 Jul 2024 09:08:13 +0200
Subject: [PATCH 88/98] winemac: Remove unnecessary old window surface bounds
 copy.

Surface bounds aren't used anymore.
---
 dlls/winemac.drv/surface.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/dlls/winemac.drv/surface.c b/dlls/winemac.drv/surface.c
index fa47c7e474e..e97787b1805 100644
--- a/dlls/winemac.drv/surface.c
+++ b/dlls/winemac.drv/surface.c
@@ -151,8 +151,7 @@ static struct macdrv_window_surface *get_mac_surface(struct window_surface *surf
 /***********************************************************************
  *              create_surface
  */
-static struct window_surface *create_surface(HWND hwnd, macdrv_window window, const RECT *rect,
-                                             struct window_surface *old_surface)
+static struct window_surface *create_surface(HWND hwnd, macdrv_window window, const RECT *rect)
 {
     struct macdrv_window_surface *surface = NULL;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -195,7 +194,6 @@ static struct window_surface *create_surface(HWND hwnd, macdrv_window window, co
     if (!window_surface_init(&surface->header, &macdrv_surface_funcs, hwnd, rect, info, bitmap)) goto failed;
 
     surface->window = window;
-    if (old_surface) surface->header.bounds = old_surface->bounds;
     surface->provider = provider;
 
     window_background = macdrv_window_background_color();
@@ -238,7 +236,7 @@ BOOL macdrv_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct wind
         }
     }
 
-    *surface = create_surface(data->hwnd, data->cocoa_window, surface_rect, data->surface);
+    *surface = create_surface(data->hwnd, data->cocoa_window, surface_rect);
 
 done:
     release_win_data(data);
@@ -263,7 +261,7 @@ BOOL macdrv_CreateLayeredWindow(HWND hwnd, const RECT *surface_rect, COLORREF co
     surface = data->surface;
     if (!surface || !EqualRect(&surface->rect, surface_rect))
     {
-        data->surface = create_surface(data->hwnd, data->cocoa_window, surface_rect, NULL);
+        data->surface = create_surface(data->hwnd, data->cocoa_window, surface_rect);
         if (surface) window_surface_release(surface);
         surface = data->surface;
         if (data->unminimized_surface)
-- 
2.48.1


From 97b020e986b9cd7519e8aeff5833be149512335d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 17 Jul 2024 09:09:06 +0200
Subject: [PATCH 89/98] winemac: Rely on win32u previous surface reuse.

---
 dlls/winemac.drv/surface.c | 18 +++---------------
 1 file changed, 3 insertions(+), 15 deletions(-)

diff --git a/dlls/winemac.drv/surface.c b/dlls/winemac.drv/surface.c
index e97787b1805..7b9ffe27968 100644
--- a/dlls/winemac.drv/surface.c
+++ b/dlls/winemac.drv/surface.c
@@ -216,29 +216,17 @@ failed:
  */
 BOOL macdrv_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface)
 {
+    struct window_surface *previous;
     struct macdrv_win_data *data;
 
     TRACE("hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect(surface_rect), surface);
 
+    if ((previous = *surface) && previous->funcs == &macdrv_surface_funcs) return TRUE;
     if (!(data = get_win_data(hwnd))) return TRUE; /* use default surface */
-
-    if (*surface) window_surface_release(*surface);
-    *surface = NULL;
-
-    if (data->surface)
-    {
-        if (EqualRect(&data->surface->rect, surface_rect))
-        {
-            /* existing surface is good enough */
-            window_surface_add_ref(data->surface);
-            *surface = data->surface;
-            goto done;
-        }
-    }
+    if (previous) window_surface_release(previous);
 
     *surface = create_surface(data->hwnd, data->cocoa_window, surface_rect);
 
-done:
     release_win_data(data);
     return TRUE;
 }
-- 
2.48.1


From 3848feac226a874fb9ec3084df74c51f62a81266 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 19 Jun 2024 11:07:57 +0200
Subject: [PATCH 90/98] win32u: Avoid sending WM_PAINT to layered window
 surfaces.

And prevent drawing to layered surface.
---
 dlls/win32u/dibdrv/dc.c | 1 +
 dlls/win32u/window.c    | 7 +++++--
 server/protocol.def     | 5 +++--
 server/window.c         | 9 ++++++---
 4 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index ee257db6dd6..2fc9000025d 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -803,6 +803,7 @@ void dibdrv_set_window_surface( DC *dc, struct window_surface *surface )
 
     if (surface)
     {
+        if (surface->alpha_mask) surface = &dummy_surface;
         if (windev) push_dc_driver( &dc->physDev, windev, windev->funcs );
         else
         {
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index de33f612f92..c4afa453d72 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -1909,12 +1909,14 @@ static BOOL apply_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags, stru
 {
     WND *win;
     HWND surface_win = 0;
-    BOOL ret, needs_update = FALSE;
+    BOOL ret, is_layered, needs_update = FALSE;
     RECT old_visible_rect, old_window_rect, old_client_rect, extra_rects[3];
     struct window_surface *old_surface;
 
+    is_layered = new_surface && new_surface->alpha_mask;
+
     get_window_rects( hwnd, COORDS_SCREEN, &old_window_rect, NULL, get_thread_dpi() );
-    if (IsRectEmpty( &valid_rects[0] )) valid_rects = NULL;
+    if (IsRectEmpty( &valid_rects[0] ) || is_layered) valid_rects = NULL;
 
     if (!(win = get_win_ptr( hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS) return FALSE;
 
@@ -1949,6 +1951,7 @@ static BOOL apply_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags, stru
             wine_server_add_data( req, extra_rects, sizeof(extra_rects) );
         }
         if (new_surface) req->paint_flags |= SET_WINPOS_PAINT_SURFACE;
+        if (is_layered) req->paint_flags |= SET_WINPOS_LAYERED_WINDOW;
         if (win->pixel_format || win->internal_pixel_format)
             req->paint_flags |= SET_WINPOS_PIXEL_FORMAT;
 
diff --git a/server/protocol.def b/server/protocol.def
index 91752612eea..2c791cbdd46 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2603,8 +2603,9 @@ enum message_type
     user_handle_t  surface_win;   /* parent window that holds the surface */
     int            needs_update;  /* whether the surface region needs an update */
 @END
-#define SET_WINPOS_PAINT_SURFACE 0x01  /* window has a paintable surface */
-#define SET_WINPOS_PIXEL_FORMAT  0x02  /* window has a custom pixel format */
+#define SET_WINPOS_PAINT_SURFACE    0x01  /* window has a paintable surface */
+#define SET_WINPOS_PIXEL_FORMAT     0x02  /* window has a custom pixel format */
+#define SET_WINPOS_LAYERED_WINDOW   0x04  /* window is drawn with UpdateLayeredWindow */
 
 /* Get the window and client rectangles of a window */
 @REQ(get_window_rectangles)
diff --git a/server/window.c b/server/window.c
index 4ebfec3da12..564c69bf18d 100644
--- a/server/window.c
+++ b/server/window.c
@@ -123,9 +123,10 @@ static const struct object_ops window_ops =
 };
 
 /* flags that can be set by the client */
-#define PAINT_HAS_SURFACE        SET_WINPOS_PAINT_SURFACE
-#define PAINT_HAS_PIXEL_FORMAT   SET_WINPOS_PIXEL_FORMAT
-#define PAINT_CLIENT_FLAGS       (PAINT_HAS_SURFACE | PAINT_HAS_PIXEL_FORMAT)
+#define PAINT_HAS_SURFACE          SET_WINPOS_PAINT_SURFACE
+#define PAINT_HAS_PIXEL_FORMAT     SET_WINPOS_PIXEL_FORMAT
+#define PAINT_HAS_LAYERED_SURFACE  SET_WINPOS_LAYERED_WINDOW
+#define PAINT_CLIENT_FLAGS         (PAINT_HAS_SURFACE | PAINT_HAS_PIXEL_FORMAT | PAINT_HAS_LAYERED_SURFACE)
 /* flags only manipulated by the server */
 #define PAINT_INTERNAL           0x0010  /* internal WM_PAINT pending */
 #define PAINT_ERASE              0x0020  /* needs WM_ERASEBKGND */
@@ -2478,6 +2479,8 @@ DECL_HANDLER(set_window_pos)
     set_window_pos( win, previous, flags, &window_rect, &client_rect,
                     &visible_rect, &surface_rect, &valid_rect );
 
+    if (win->paint_flags & SET_WINPOS_LAYERED_WINDOW) validate_whole_window( win );
+
     reply->new_style = win->style;
     reply->new_ex_style = win->ex_style;
 
-- 
2.48.1


From f172b26a5f6c3d77ea2e918cbe0ba8fded1a3037 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 17 Jul 2024 09:10:25 +0200
Subject: [PATCH 91/98] win32u: Merge drivers CreateLayeredWindow with
 CreateWindowSurface.

---
 dlls/win32u/driver.c                  | 17 +--------
 dlls/win32u/window.c                  | 10 ++---
 dlls/wineandroid.drv/android.h        |  4 +-
 dlls/wineandroid.drv/init.c           |  1 -
 dlls/wineandroid.drv/window.c         | 36 +-----------------
 dlls/winemac.drv/gdi.c                |  1 -
 dlls/winemac.drv/macdrv.h             |  4 +-
 dlls/winemac.drv/surface.c            | 37 ++++--------------
 dlls/winewayland.drv/waylanddrv.h     |  2 +-
 dlls/winewayland.drv/window_surface.c |  4 +-
 dlls/winex11.drv/bitblt.c             | 55 +++++++++------------------
 dlls/winex11.drv/init.c               |  1 -
 dlls/winex11.drv/x11drv.h             |  4 +-
 include/wine/gdi_driver.h             |  5 +--
 14 files changed, 39 insertions(+), 142 deletions(-)

diff --git a/dlls/win32u/driver.c b/dlls/win32u/driver.c
index 76e717648d6..362f32b93d7 100644
--- a/dlls/win32u/driver.c
+++ b/dlls/win32u/driver.c
@@ -867,13 +867,6 @@ static LRESULT nulldrv_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
     return -1;
 }
 
-static BOOL nulldrv_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                         struct window_surface **surface )
-{
-    *surface = NULL;
-    return TRUE;
-}
-
 static void nulldrv_UpdateLayeredWindow( HWND hwnd, const RECT *window_rect, COLORREF color_key,
                                          BYTE alpha, UINT flags )
 {
@@ -889,7 +882,7 @@ static BOOL nulldrv_WindowPosChanging( HWND hwnd, UINT swp_flags, BOOL shaped, c
     return TRUE;
 }
 
-static BOOL nulldrv_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface )
+static BOOL nulldrv_CreateWindowSurface( HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface )
 {
     return FALSE;
 }
@@ -1217,12 +1210,6 @@ static void loaderdrv_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
     load_driver()->pSetWindowRgn( hwnd, hrgn, redraw );
 }
 
-static BOOL loaderdrv_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                           struct window_surface **surface )
-{
-    return load_driver()->pCreateLayeredWindow( hwnd, surface_rect, color_key, surface );
-}
-
 static void loaderdrv_UpdateLayeredWindow( HWND hwnd, const RECT *window_rect, COLORREF color_key,
                                            BYTE alpha, UINT flags )
 {
@@ -1293,7 +1280,6 @@ static const struct user_driver_funcs lazy_load_driver =
     nulldrv_SetWindowText,
     nulldrv_ShowWindow,
     nulldrv_SysCommand,
-    loaderdrv_CreateLayeredWindow,
     loaderdrv_UpdateLayeredWindow,
     nulldrv_WindowMessage,
     nulldrv_WindowPosChanging,
@@ -1381,7 +1367,6 @@ void __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version
     SET_USER_FUNC(SetWindowText);
     SET_USER_FUNC(ShowWindow);
     SET_USER_FUNC(SysCommand);
-    SET_USER_FUNC(CreateLayeredWindow);
     SET_USER_FUNC(UpdateLayeredWindow);
     SET_USER_FUNC(WindowMessage);
     SET_USER_FUNC(WindowPosChanging);
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index c4afa453d72..118de5d8b14 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -1874,8 +1874,9 @@ static struct window_surface *create_window_surface( HWND hwnd, UINT swp_flags,
         window_surface_add_ref( new_surface );
     }
 
+    if (create_layered || is_layered) needs_surface = TRUE;
     if (!needs_surface || IsRectEmpty( visible_rect )) needs_surface = FALSE; /* use default surface */
-    else needs_surface = !user_driver->pCreateWindowSurface( hwnd, surface_rect, &new_surface );
+    else needs_surface = !user_driver->pCreateWindowSurface( hwnd, create_layered, surface_rect, &new_surface );
 
     /* create or update window surface for top-level windows if the driver doesn't implement CreateWindowSurface */
     if (needs_surface && new_surface == &dummy_surface && (create_opaque && !create_layered))
@@ -2239,11 +2240,7 @@ BOOL WINAPI NtUserUpdateLayeredWindow( HWND hwnd, HDC hdc_dst, const POINT *pts_
 
     surface = create_window_surface( hwnd, swp_flags, TRUE, &window_rect, &client_rect, &visible_rect, &surface_rect );
     apply_window_pos( hwnd, 0, swp_flags, surface, &window_rect, &client_rect, &visible_rect, NULL );
-    if (surface) window_surface_release( surface );
-
-    if (!(flags & ULW_COLORKEY)) key = CLR_INVALID;
-    if (IsRectEmpty( &surface_rect )) window_surface_add_ref( (surface = &dummy_surface) );
-    else if (!(user_driver->pCreateLayeredWindow( hwnd, &surface_rect, key, &surface )) || !surface) return FALSE;
+    if (!surface) return FALSE;
 
     if (!hdc_src || surface == &dummy_surface) ret = TRUE;
     else
@@ -2276,6 +2273,7 @@ BOOL WINAPI NtUserUpdateLayeredWindow( HWND hwnd, HDC hdc_dst, const POINT *pts_
         NtGdiDeleteObjectApp( hdc );
         window_surface_unlock( surface );
 
+        if (!(flags & ULW_COLORKEY)) key = CLR_INVALID;
         window_surface_set_layered( surface, key, -1, 0xff000000 );
         window_surface_flush( surface );
 
diff --git a/dlls/wineandroid.drv/android.h b/dlls/wineandroid.drv/android.h
index 9f6bb2b999c..f31a295354b 100644
--- a/dlls/wineandroid.drv/android.h
+++ b/dlls/wineandroid.drv/android.h
@@ -96,12 +96,10 @@ extern void ANDROID_SetParent( HWND hwnd, HWND parent, HWND old_parent );
 extern void ANDROID_SetCapture( HWND hwnd, UINT flags );
 extern void ANDROID_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style );
 extern UINT ANDROID_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp );
-extern BOOL ANDROID_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                         struct window_surface **surface );
 extern LRESULT ANDROID_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern BOOL ANDROID_WindowPosChanging( HWND hwnd, UINT swp_flags, BOOL shaped, const RECT *window_rect,
                                        const RECT *client_rect, RECT *visible_rect );
-extern BOOL ANDROID_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface );
+extern BOOL ANDROID_CreateWindowSurface( HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface );
 extern void ANDROID_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
                                       const RECT *window_rect, const RECT *client_rect,
                                       const RECT *visible_rect, const RECT *valid_rects,
diff --git a/dlls/wineandroid.drv/init.c b/dlls/wineandroid.drv/init.c
index 25055ece395..d84a56716d8 100644
--- a/dlls/wineandroid.drv/init.c
+++ b/dlls/wineandroid.drv/init.c
@@ -347,7 +347,6 @@ static const struct user_driver_funcs android_drv_funcs =
     .pSetParent = ANDROID_SetParent,
     .pSetWindowStyle = ANDROID_SetWindowStyle,
     .pShowWindow = ANDROID_ShowWindow,
-    .pCreateLayeredWindow = ANDROID_CreateLayeredWindow,
     .pWindowMessage = ANDROID_WindowMessage,
     .pWindowPosChanging = ANDROID_WindowPosChanging,
     .pCreateWindowSurface = ANDROID_CreateWindowSurface,
diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
index 0d6df89d06f..65ce4180730 100644
--- a/dlls/wineandroid.drv/window.c
+++ b/dlls/wineandroid.drv/window.c
@@ -1065,12 +1065,12 @@ done:
 /***********************************************************************
  *           ANDROID_CreateWindowSurface
  */
-BOOL ANDROID_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface )
+BOOL ANDROID_CreateWindowSurface( HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface )
 {
     struct window_surface *previous;
     struct android_win_data *data;
 
-    TRACE( "hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect( surface_rect ), surface );
+    TRACE( "hwnd %p, layered %u, surface_rect %s, surface %p\n", hwnd, layered, wine_dbgstr_rect( surface_rect ), surface );
 
     if ((previous = *surface) && previous->funcs == &android_surface_funcs) return TRUE;
     if (!(data = get_win_data( hwnd ))) return TRUE; /* use default surface */
@@ -1245,38 +1245,6 @@ void ANDROID_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 }
 
 
-/*****************************************************************************
- *           ANDROID_CreateLayeredWindow
- */
-BOOL ANDROID_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                  struct window_surface **window_surface )
-{
-    struct window_surface *surface;
-    struct android_win_data *data;
-
-    if (!(data = get_win_data( hwnd ))) return FALSE;
-
-    surface = data->surface;
-    if (!is_argb_surface( surface ))
-    {
-        if (surface) window_surface_release( surface );
-        surface = NULL;
-    }
-
-    if (!surface || !EqualRect( &surface->rect, surface_rect ))
-    {
-        data->surface = create_surface( data->hwnd, surface_rect );
-        if (surface) window_surface_release( surface );
-        surface = data->surface;
-    }
-
-    if ((*window_surface = surface)) window_surface_add_ref( surface );
-    release_win_data( data );
-
-    return TRUE;
-}
-
-
 /**********************************************************************
  *           ANDROID_WindowMessage
  */
diff --git a/dlls/winemac.drv/gdi.c b/dlls/winemac.drv/gdi.c
index 0b12c65303d..dba4acc49a3 100644
--- a/dlls/winemac.drv/gdi.c
+++ b/dlls/winemac.drv/gdi.c
@@ -301,7 +301,6 @@ static const struct user_driver_funcs macdrv_funcs =
     .pToUnicodeEx = macdrv_ToUnicodeEx,
     .pUnregisterHotKey = macdrv_UnregisterHotKey,
     .pUpdateClipboard = macdrv_UpdateClipboard,
-    .pCreateLayeredWindow = macdrv_CreateLayeredWindow,
     .pUpdateLayeredWindow = macdrv_UpdateLayeredWindow,
     .pVkKeyScanEx = macdrv_VkKeyScanEx,
     .pImeProcessKey = macdrv_ImeProcessKey,
diff --git a/dlls/winemac.drv/macdrv.h b/dlls/winemac.drv/macdrv.h
index 6c9735bd8e4..c5649d1ad38 100644
--- a/dlls/winemac.drv/macdrv.h
+++ b/dlls/winemac.drv/macdrv.h
@@ -145,14 +145,12 @@ extern void macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alph
 extern void macdrv_SetWindowText(HWND hwnd, LPCWSTR text);
 extern UINT macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp);
 extern LRESULT macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam);
-extern BOOL macdrv_CreateLayeredWindow(HWND hwnd, const RECT *window_rect, COLORREF color_key,
-                                       struct window_surface **surface);
 extern void macdrv_UpdateLayeredWindow(HWND hwnd, const RECT *window_rect, COLORREF color_key,
                                        BYTE alpha, UINT flags);
 extern LRESULT macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 extern BOOL macdrv_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const RECT *window_rect,
                                      const RECT *client_rect, RECT *visible_rect);
-extern BOOL macdrv_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface);
+extern BOOL macdrv_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
 extern void macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
                                     const RECT *window_rect, const RECT *client_rect,
                                     const RECT *visible_rect, const RECT *valid_rects,
diff --git a/dlls/winemac.drv/surface.c b/dlls/winemac.drv/surface.c
index 7b9ffe27968..9bca2a651e5 100644
--- a/dlls/winemac.drv/surface.c
+++ b/dlls/winemac.drv/surface.c
@@ -214,44 +214,22 @@ failed:
 /***********************************************************************
  *              CreateWindowSurface   (MACDRV.@)
  */
-BOOL macdrv_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface)
+BOOL macdrv_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface)
 {
     struct window_surface *previous;
     struct macdrv_win_data *data;
 
-    TRACE("hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect(surface_rect), surface);
+    TRACE("hwnd %p, layered %u, surface_rect %s, surface %p\n", hwnd, layered, wine_dbgstr_rect(surface_rect), surface);
 
     if ((previous = *surface) && previous->funcs == &macdrv_surface_funcs) return TRUE;
     if (!(data = get_win_data(hwnd))) return TRUE; /* use default surface */
     if (previous) window_surface_release(previous);
 
-    *surface = create_surface(data->hwnd, data->cocoa_window, surface_rect);
-
-    release_win_data(data);
-    return TRUE;
-}
-
-
-/***********************************************************************
- *              CreateLayeredWindow   (MACDRV.@)
- */
-BOOL macdrv_CreateLayeredWindow(HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                struct window_surface **window_surface)
-{
-    struct window_surface *surface;
-    struct macdrv_win_data *data;
-
-    if (!(data = get_win_data(hwnd))) return FALSE;
-
-    data->layered = TRUE;
-    data->ulw_layered = TRUE;
-
-    surface = data->surface;
-    if (!surface || !EqualRect(&surface->rect, surface_rect))
+    if (layered)
     {
-        data->surface = create_surface(data->hwnd, data->cocoa_window, surface_rect);
-        if (surface) window_surface_release(surface);
-        surface = data->surface;
+        data->layered = TRUE;
+        data->ulw_layered = TRUE;
+
         if (data->unminimized_surface)
         {
             window_surface_release(data->unminimized_surface);
@@ -259,9 +237,8 @@ BOOL macdrv_CreateLayeredWindow(HWND hwnd, const RECT *surface_rect, COLORREF co
         }
     }
 
-    if ((*window_surface = surface)) window_surface_add_ref(surface);
+    *surface = create_surface(hwnd, data->cocoa_window, surface_rect);
 
     release_win_data(data);
-
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 378d408a719..9e42618b5a1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -383,7 +383,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
                               struct window_surface *surface);
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const RECT *window_rect,
                                const RECT *client_rect, RECT *visible_rect);
-BOOL WAYLAND_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface);
+BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 8221423f336..a3bbc24da7e 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -541,12 +541,12 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
 /***********************************************************************
  *           WAYLAND_CreateWindowSurface
  */
-BOOL WAYLAND_CreateWindowSurface(HWND hwnd, const RECT *surface_rect, struct window_surface **surface)
+BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface)
 {
     struct window_surface *previous;
     struct wayland_win_data *data;
 
-    TRACE("hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect(surface_rect), surface);
+    TRACE("hwnd %p, layered %u, surface_rect %s, surface %p\n", hwnd, layered, wine_dbgstr_rect(surface_rect), surface);
 
     if ((previous = *surface) && previous->funcs == &wayland_window_surface_funcs) return TRUE;
     if (!(data = wayland_win_data_get(hwnd))) return TRUE; /* use default surface */
diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index 8bd27fd13e1..1a584ff7fb6 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -1986,56 +1986,35 @@ HRGN expose_surface( struct window_surface *window_surface, const RECT *rect )
 /***********************************************************************
  *      CreateWindowSurface   (X11DRV.@)
  */
-BOOL X11DRV_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface )
+BOOL X11DRV_CreateWindowSurface( HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface )
 {
     struct window_surface *previous;
     struct x11drv_win_data *data;
-    BOOL layered = NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
 
-    TRACE( "hwnd %p, surface_rect %s, surface %p\n", hwnd, wine_dbgstr_rect( surface_rect ), surface );
+    TRACE( "hwnd %p, layered %u, surface_rect %s, surface %p\n", hwnd, layered, wine_dbgstr_rect( surface_rect ), surface );
 
     if ((previous = *surface) && previous->funcs == &x11drv_surface_funcs) return TRUE;
     if (!(data = get_win_data( hwnd ))) return TRUE; /* use default surface */
     if (previous) window_surface_release( previous );
 
-    *surface = NULL;  /* indicate that we want to draw directly to the window */
-    if (data->embedded) goto done; /* draw directly to the window */
-    if (data->whole_window == root_window) goto done; /* draw directly to the window */
-    if (data->client_window) goto done; /* draw directly to the window */
-    if (!client_side_graphics && !layered) goto done; /* draw directly to the window */
-
-    *surface = create_surface( data->hwnd, data->whole_window, &data->vis, surface_rect, FALSE );
-
-done:
-    release_win_data( data );
-    return TRUE;
-}
-
-
-/*****************************************************************************
- *              CreateLayeredWindow  (X11DRV.@)
- */
-BOOL X11DRV_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                 struct window_surface **window_surface )
-{
-    struct window_surface *surface;
-    struct x11drv_win_data *data;
-
-    if (!(data = get_win_data( hwnd ))) return FALSE;
-
-    data->layered = TRUE;
-    if (!data->embedded && argb_visual.visualid) set_window_visual( data, &argb_visual, TRUE );
-
-    surface = data->surface;
-    if (!surface || !EqualRect( &surface->rect, surface_rect ))
+    if (layered)
+    {
+        data->layered = TRUE;
+        if (!data->embedded && argb_visual.visualid) set_window_visual( data, &argb_visual, TRUE );
+    }
+    else
     {
-        data->surface = create_surface( data->hwnd, data->whole_window, &data->vis, surface_rect, data->use_alpha );
-        if (surface) window_surface_release( surface );
-        surface = data->surface;
+        *surface = NULL;  /* indicate that we want to draw directly to the window */
+        if (data->embedded) goto done; /* draw directly to the window */
+        if (data->whole_window == root_window) goto done; /* draw directly to the window */
+        if (data->client_window) goto done; /* draw directly to the window */
+        if (!client_side_graphics) goto done; /* draw directly to the window */
     }
 
-    if ((*window_surface = surface)) window_surface_add_ref( surface );
-    release_win_data( data );
+    *surface = create_surface( data->hwnd, data->whole_window, &data->vis, surface_rect,
+                               layered ? data->use_alpha : FALSE );
 
+done:
+    release_win_data( data );
     return TRUE;
 }
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 28729d1c14b..4a78073cb9b 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -420,7 +420,6 @@ static const struct user_driver_funcs x11drv_funcs =
     .pSysCommand = X11DRV_SysCommand,
     .pClipboardWindowProc = X11DRV_ClipboardWindowProc,
     .pUpdateClipboard = X11DRV_UpdateClipboard,
-    .pCreateLayeredWindow = X11DRV_CreateLayeredWindow,
     .pUpdateLayeredWindow = X11DRV_UpdateLayeredWindow,
     .pWindowMessage = X11DRV_WindowMessage,
     .pWindowPosChanging = X11DRV_WindowPosChanging,
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 0e4bdc52661..669781e8d70 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -240,14 +240,12 @@ extern UINT X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp );
 extern LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam );
 extern LRESULT X11DRV_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern void X11DRV_UpdateClipboard(void);
-extern BOOL X11DRV_CreateLayeredWindow( HWND hwnd, const RECT *surface_rect, COLORREF color_key,
-                                        struct window_surface **surface );
 extern void X11DRV_UpdateLayeredWindow( HWND hwnd, const RECT *window_rect, COLORREF color_key,
                                         BYTE alpha, UINT flags );
 extern LRESULT X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp );
 extern BOOL X11DRV_WindowPosChanging( HWND hwnd, UINT swp_flags, BOOL shaped, const RECT *window_rect,
                                       const RECT *client_rect, RECT *visible_rect );
-extern BOOL X11DRV_CreateWindowSurface( HWND hwnd, const RECT *surface_rect, struct window_surface **surface );
+extern BOOL X11DRV_CreateWindowSurface( HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface );
 extern void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
                                      const RECT *rectWindow, const RECT *rectClient,
                                      const RECT *visible_rect, const RECT *valid_rects,
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 774211fea15..8eec0ada4ca 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -179,7 +179,7 @@ struct gdi_dc_funcs
 };
 
 /* increment this when you change the DC function table */
-#define WINE_GDI_DRIVER_VERSION 87
+#define WINE_GDI_DRIVER_VERSION 88
 
 #define GDI_PRIORITY_NULL_DRV        0  /* null driver */
 #define GDI_PRIORITY_FONT_DRV      100  /* any font driver */
@@ -342,11 +342,10 @@ struct user_driver_funcs
     void    (*pSetWindowText)(HWND,LPCWSTR);
     UINT    (*pShowWindow)(HWND,INT,RECT*,UINT);
     LRESULT (*pSysCommand)(HWND,WPARAM,LPARAM);
-    BOOL    (*pCreateLayeredWindow)(HWND,const RECT *,COLORREF,struct window_surface **);
     void    (*pUpdateLayeredWindow)(HWND,const RECT *,COLORREF,BYTE,UINT);
     LRESULT (*pWindowMessage)(HWND,UINT,WPARAM,LPARAM);
     BOOL    (*pWindowPosChanging)(HWND,UINT,BOOL,const RECT *,const RECT *,RECT *);
-    BOOL    (*pCreateWindowSurface)(HWND,const RECT *,struct window_surface**);
+    BOOL    (*pCreateWindowSurface)(HWND,BOOL,const RECT *,struct window_surface**);
     void    (*pWindowPosChanged)(HWND,HWND,UINT,const RECT *,const RECT *,const RECT *,
                                  const RECT *,struct window_surface*);
     /* system parameters */
-- 
2.48.1


From 5ff68569e1e8e8b2644080a1183360848a1bdb1b Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 16:48:54 -0700
Subject: [PATCH 92/98] Trying to resolve segfault

---
 dlls/dxcore/main.c    |  2 +-
 dlls/dxcore/private.h | 54 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+), 1 deletion(-)
 create mode 100644 dlls/dxcore/private.h

diff --git a/dlls/dxcore/main.c b/dlls/dxcore/main.c
index ee7b0a21c03..719ac70fb96 100644
--- a/dlls/dxcore/main.c
+++ b/dlls/dxcore/main.c
@@ -17,7 +17,7 @@
  */
 
 #define DXCORE_INIT_GUID
-#include "dxcore_interface.h"
+#include "private.h"
 
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxcore);
diff --git a/dlls/dxcore/private.h b/dlls/dxcore/private.h
new file mode 100644
index 00000000000..6b2f7ecb524
--- /dev/null
+++ b/dlls/dxcore/private.h
@@ -0,0 +1,54 @@
+
+#ifndef __WINE_DXCORE_PRIVATE_H
+#define __WINE_DXCORE_PRIVATE_H
+
+#include "wine/debug.h"
+
+// #include <assert.h>
+
+#define COBJMACROS
+#include "winbase.h"
+#include "objbase.h"
+
+#include "dxgi1_6.h"
+#ifdef DXCORE_INIT_GUID
+#include "initguid.h"
+#endif
+
+#include "dxcore.h"
+#include "dxcore_interface.h"
+
+// IDXCoreAdapterFactory
+struct dxcore_factory {
+    IDXCoreAdapterFactory IDXCoreAdapterFactory_iface;
+    LONG refcount;
+};
+
+HRESULT dxcore_factory_create(REFIID iid, void** factory);
+
+// IDXCoreAdapterList
+struct dxcore_adapter_list {
+    IDXCoreAdapterList IDXCoreAdapterList_iface;
+    LONG refcount;
+    struct dxcore_factory *factory;
+    LONG len;
+    IDXGIFactory *dxgi_factory;
+    struct dxcore_adapter **adapters;
+};
+
+
+// IDXCoreAdapter
+struct dxcore_adapter {
+    IDXCoreAdapter IDXCoreAdapter_iface;
+    LONG refcount;
+    struct dxcore_factory *factory;
+    IDXGIAdapter *adapter;
+};
+
+HRESULT dxcore_adapter_create(
+    struct dxcore_factory *factory,
+    IDXGIAdapter *adapter,
+    struct dxcore_adapter **ppv
+);
+
+#endif
-- 
2.48.1


From 9bdc794612e7743c3ac671285fe59cdcc124f764 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 18:44:29 -0700
Subject: [PATCH 93/98] Revert "makedep: Generate a compile_commands.json
 file."

This reverts commit 65880e0c8c8f5cd699af6d80bf890d23f6c5d856.
---
 configure       |   3 +-
 configure.ac    |   3 +-
 tools/makedep.c | 131 +++++++-----------------------------------------
 3 files changed, 19 insertions(+), 118 deletions(-)

diff --git a/configure b/configure
index ec9a75f2d9b..11d78bd6dae 100755
--- a/configure
+++ b/configure
@@ -21928,7 +21928,7 @@ ac_config_commands="$ac_config_commands include/stamp-h"
 
 printf %s "creating Makefile rules..." >&6
 
-makedep_flags=" -C"
+makedep_flags=""
 test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
 
 wine_srcdir=
@@ -23101,7 +23101,6 @@ test "x$enable_tools" = xno || wine_fn_config_makefile tools/wrc enable_wrc
 as_fn_append CONFIGURE_TARGETS " TAGS"
 as_fn_append CONFIGURE_TARGETS " tags"
 as_fn_append CONFIGURE_TARGETS " autom4te.cache"
-as_fn_append CONFIGURE_TARGETS " compile_commands.json"
 as_fn_append CONFIGURE_TARGETS " config.log"
 as_fn_append CONFIGURE_TARGETS " config.status"
 as_fn_append CONFIGURE_TARGETS " include/config.h"
diff --git a/configure.ac b/configure.ac
index 23d3f8fbc49..b8063967e81 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2412,7 +2412,7 @@ AH_BOTTOM([#endif /* __WINE_CONFIG_H */])
 AC_CONFIG_COMMANDS([include/stamp-h], [echo timestamp > include/stamp-h])
 AS_ECHO_N("creating Makefile rules...") >&AS_MESSAGE_FD
 
-makedep_flags=" -C"
+makedep_flags=""
 test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
 
 wine_srcdir=
@@ -3583,7 +3583,6 @@ dnl Main ignore file
 WINE_IGNORE_FILE(TAGS)
 WINE_IGNORE_FILE(tags)
 WINE_IGNORE_FILE(autom4te.cache)
-WINE_IGNORE_FILE(compile_commands.json)
 WINE_IGNORE_FILE(config.log)
 WINE_IGNORE_FILE(config.status)
 WINE_IGNORE_FILE(include/config.h)
diff --git a/tools/makedep.c b/tools/makedep.c
index c185030ea66..25ddb92f7fa 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -240,27 +240,14 @@ static const char *output_makefile_name = "Makefile";
 static const char *input_file_name;
 static const char *output_file_name;
 static const char *temp_file_name;
-static int compile_commands_mode;
 static int silent_rules;
 static int input_line;
 static int output_column;
 static FILE *output_file;
 
-struct compile_command
-{
-    struct list      entry;
-    const char      *cmd;
-    const char      *source;
-    const char      *obj;
-    struct strarray args;
-};
-
-static struct list compile_commands = LIST_INIT( compile_commands );
-
 static const char Usage[] =
     "Usage: makedep [options]\n"
     "Options:\n"
-    "   -C          Generate compile_commands.json along with the makefile\n"
     "   -S          Generate Automake-style silent rules\n"
     "   -fxxx       Store output in file 'xxx' (default: Makefile)\n";
 
@@ -565,26 +552,6 @@ static char *concat_paths( const char *base, const char *path )
 }
 
 
-/*******************************************************************
- *         escape_cstring
- */
-static const char *escape_cstring( const char *str )
-{
-    char *ret;
-    unsigned int i = 0, j = 0;
-
-    if (!strpbrk( str, "\\\"" )) return str;
-    ret = xmalloc( 2 * strlen(str) + 1 );
-    while (str[i])
-    {
-        if (str[i] == '\\' || str[i] == '"') ret[j++] = '\\';
-        ret[j++] = str[i++];
-    }
-    ret[j] = 0;
-    return ret;
-}
-
-
 /*******************************************************************
  *         is_native_arch_disabled
  *
@@ -3199,7 +3166,7 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
                                     unsigned int arch )
 {
     const char *obj_name, *var_cc, *var_cflags;
-    struct strarray cflags = empty_strarray;
+    struct strarray arch_cflags = empty_strarray;
 
     if (make->disabled[arch] && !(source->file->flags & FLAG_C_IMPLIB)) return;
 
@@ -3230,46 +3197,46 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
     else
         strarray_add( &make->clean_files, obj_name );
 
-    if (!source->use_msvcrt) strarray_addall( &cflags, make->unix_cflags );
     if ((source->file->flags & FLAG_ARM64EC_X64) && !strcmp( archs.str[arch], "arm64ec" ))
     {
         var_cc     = "$(x86_64_CC)";
         var_cflags = "$(x86_64_CFLAGS)";
-        strarray_add( &cflags, "-D__arm64ec_x64__" );
-        strarray_addall( &cflags, get_expanded_make_var_array( top_makefile, "x86_64_EXTRACFLAGS" ));
+        strarray_add( &arch_cflags, "-D__arm64ec_x64__" );
+        strarray_addall( &arch_cflags, get_expanded_make_var_array( top_makefile, "x86_64_EXTRACFLAGS" ));
     }
     else
     {
         var_cc     = arch_make_variable( "CC", arch );
         var_cflags = arch_make_variable( "CFLAGS", arch );
-        strarray_addall( &cflags, make->extlib ? extra_cflags_extlib[arch] : extra_cflags[arch] );
+        strarray_addall( &arch_cflags, make->extlib ? extra_cflags_extlib[arch] : extra_cflags[arch] );
     }
 
+    output( "%s: %s\n", obj_dir_path( make, obj_name ), source->filename );
+    output( "\t%s%s -c -o $@ %s", cmd_prefix( "CC" ), var_cc, source->filename );
+    output_filenames( defines );
+    if (!source->use_msvcrt) output_filenames( make->unix_cflags );
+    output_filenames( arch_cflags );
+
     if (!arch)
     {
         if (source->file->flags & FLAG_C_UNIX)
         {
-            strarray_addall( &cflags, unix_dllflags );
+            output_filenames( unix_dllflags );
         }
         else if (make->module || make->testdll)
         {
-            strarray_addall( &cflags, dll_flags );
-            if (source->use_msvcrt) strarray_addall( &cflags, msvcrt_flags );
+            output_filenames( dll_flags );
+            if (source->use_msvcrt) output_filenames( msvcrt_flags );
             if (!unix_lib_supported && make->module && is_crt_module( make->module ))
-                strarray_add( &cflags, "-fno-builtin" );
+                output_filename( "-fno-builtin" );
         }
     }
     else
     {
-        if (make->module && is_crt_module( make->module )) strarray_add( &cflags, "-fno-builtin" );
+        if (make->module && is_crt_module( make->module )) output_filename( "-fno-builtin" );
     }
 
-    strarray_addall( &cflags, cpp_flags );
-
-    output( "%s: %s\n", obj_dir_path( make, obj_name ), source->filename );
-    output( "\t%s%s -c -o $@ %s", cmd_prefix( "CC" ), var_cc, source->filename );
-    output_filenames( defines );
-    output_filenames( cflags );
+    output_filenames( cpp_flags );
     output_filename( var_cflags );
     output( "\n" );
 
@@ -3287,29 +3254,6 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
                 root_src_dir_path( "tools/runtest" ), make->testdll,
                 obj_dir_path( make, arch_module_name( test_exe, arch )), obj );
     }
-
-    if (!(source->file->flags & FLAG_GENERATED))
-    {
-        struct compile_command *cmd = malloc( sizeof(*cmd) );
-
-        cmd->source = source->filename;
-        cmd->obj = obj_dir_path( make, obj_name );
-        cmd->args = empty_strarray;
-        strarray_addall( &cmd->args, defines );
-        strarray_addall( &cmd->args, cflags );
-
-        if ((source->file->flags & FLAG_ARM64EC_X64) && !strcmp( archs.str[arch], "arm64ec" ))
-        {
-            cmd->cmd = get_expanded_make_variable( make, "x86_64_CC" );
-            strarray_add( &cmd->args, get_expanded_make_variable( make, "x86_64_CFLAGS" ));
-        }
-        else
-        {
-            cmd->cmd = get_expanded_arch_var( make, "CC", arch );
-            strarray_add( &cmd->args, get_expanded_arch_var( make, "CFLAGS", arch ));
-        }
-        list_add_tail( &compile_commands, &cmd->entry );
-    }
 }
 
 
@@ -4099,41 +4043,6 @@ static void output_linguas( const struct makefile *make )
 }
 
 
-/*******************************************************************
- *         output_compile_commands
- */
-static void output_compile_commands( const char *dest )
-{
-    struct compile_command *cmd;
-    unsigned int i;
-    const char *dir;
-    char buffer[PATH_MAX];
-
-    output_file = create_temp_file( dest );
-
-    getcwd( buffer, sizeof(buffer) );
-    dir = escape_cstring( buffer );
-
-    output( "[\n" );
-    LIST_FOR_EACH_ENTRY( cmd, &compile_commands, struct compile_command, entry )
-    {
-        output( "  {\n" );
-        output( "    \"command\": \"%s -c -o %s %s", cmd->cmd, cmd->obj, cmd->source );
-        for (i = 0; i < cmd->args.count; i++) output( " %s", escape_cstring( cmd->args.str[i] ));
-        output( "\",\n" );
-        output( "    \"file\": \"%s\",\n", cmd->source );
-        output( "    \"output\": \"%s\",\n", cmd->obj );
-        output( "    \"directory\": \"%s\"\n", dir );
-        output( "  }%s\n", list_next( &compile_commands, &cmd->entry ) ? "," : "" );
-    }
-    output( "]\n" );
-
-    if (fclose( output_file )) fatal_perror( "write" );
-    output_file = NULL;
-    rename_temp_file( dest );
-}
-
-
 /*******************************************************************
  *         output_testlist
  */
@@ -4307,8 +4216,7 @@ static void output_top_makefile( struct makefile *make )
     makedep = strmake( "%s%s",tools_dir_path( make, "makedep" ), tools_ext );
     output( "Makefile: %s\n", makedep );
     output( "depend: %s\n", makedep );
-    output( "\t%s%s%s\n", makedep,
-            compile_commands_mode ? " -C" : "",
+    output( "\t%s%s\n", makedep,
             silent_rules ? " -S" : "" );
     strarray_add( &make->phony_targets, "depend" );
 
@@ -4488,9 +4396,6 @@ static int parse_option( const char *opt )
     case 'f':
         if (opt[2]) output_makefile_name = opt + 2;
         break;
-    case 'C':
-        compile_commands_mode = 1;
-        break;
     case 'S':
         silent_rules = 1;
         break;
@@ -4645,7 +4550,5 @@ int main( int argc, char *argv[] )
     output_dependencies( top_makefile );
     for (i = 0; i < subdirs.count; i++) output_dependencies( submakes[i] );
 
-    if (compile_commands_mode) output_compile_commands( "compile_commands.json" );
-
     return 0;
 }
-- 
2.48.1


From 98268109bf8eb405c384766e62bf338700fb834d Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Thu, 1 Aug 2024 19:51:00 -0700
Subject: [PATCH 94/98] Run tools/make_requests

---
 include/wine/server_protocol.h | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index fe800aa8240..74bf0f0c839 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -3530,8 +3530,9 @@ struct set_window_pos_reply
     user_handle_t  surface_win;
     int            needs_update;
 };
-#define SET_WINPOS_PAINT_SURFACE 0x01
-#define SET_WINPOS_PIXEL_FORMAT  0x02
+#define SET_WINPOS_PAINT_SURFACE    0x01
+#define SET_WINPOS_PIXEL_FORMAT     0x02
+#define SET_WINPOS_LAYERED_WINDOW   0x04
 
 
 struct get_window_rectangles_request
@@ -6598,7 +6599,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 836
+#define SERVER_PROTOCOL_VERSION 837
 
 /* ### protocol_version end ### */
 
-- 
2.48.1


From db36d6e0044119c5ace69e396fdf8199942470fd Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Fri, 2 Aug 2024 08:04:02 -0700
Subject: [PATCH 95/98] Reapply "makedep: Generate a compile_commands.json
 file."

This reverts commit 9bdc794612e7743c3ac671285fe59cdcc124f764.
---
 configure       |   3 +-
 configure.ac    |   3 +-
 tools/makedep.c | 131 +++++++++++++++++++++++++++++++++++++++++-------
 3 files changed, 118 insertions(+), 19 deletions(-)

diff --git a/configure b/configure
index 11d78bd6dae..ec9a75f2d9b 100755
--- a/configure
+++ b/configure
@@ -21928,7 +21928,7 @@ ac_config_commands="$ac_config_commands include/stamp-h"
 
 printf %s "creating Makefile rules..." >&6
 
-makedep_flags=""
+makedep_flags=" -C"
 test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
 
 wine_srcdir=
@@ -23101,6 +23101,7 @@ test "x$enable_tools" = xno || wine_fn_config_makefile tools/wrc enable_wrc
 as_fn_append CONFIGURE_TARGETS " TAGS"
 as_fn_append CONFIGURE_TARGETS " tags"
 as_fn_append CONFIGURE_TARGETS " autom4te.cache"
+as_fn_append CONFIGURE_TARGETS " compile_commands.json"
 as_fn_append CONFIGURE_TARGETS " config.log"
 as_fn_append CONFIGURE_TARGETS " config.status"
 as_fn_append CONFIGURE_TARGETS " include/config.h"
diff --git a/configure.ac b/configure.ac
index b8063967e81..23d3f8fbc49 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2412,7 +2412,7 @@ AH_BOTTOM([#endif /* __WINE_CONFIG_H */])
 AC_CONFIG_COMMANDS([include/stamp-h], [echo timestamp > include/stamp-h])
 AS_ECHO_N("creating Makefile rules...") >&AS_MESSAGE_FD
 
-makedep_flags=""
+makedep_flags=" -C"
 test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
 
 wine_srcdir=
@@ -3583,6 +3583,7 @@ dnl Main ignore file
 WINE_IGNORE_FILE(TAGS)
 WINE_IGNORE_FILE(tags)
 WINE_IGNORE_FILE(autom4te.cache)
+WINE_IGNORE_FILE(compile_commands.json)
 WINE_IGNORE_FILE(config.log)
 WINE_IGNORE_FILE(config.status)
 WINE_IGNORE_FILE(include/config.h)
diff --git a/tools/makedep.c b/tools/makedep.c
index 25ddb92f7fa..c185030ea66 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -240,14 +240,27 @@ static const char *output_makefile_name = "Makefile";
 static const char *input_file_name;
 static const char *output_file_name;
 static const char *temp_file_name;
+static int compile_commands_mode;
 static int silent_rules;
 static int input_line;
 static int output_column;
 static FILE *output_file;
 
+struct compile_command
+{
+    struct list      entry;
+    const char      *cmd;
+    const char      *source;
+    const char      *obj;
+    struct strarray args;
+};
+
+static struct list compile_commands = LIST_INIT( compile_commands );
+
 static const char Usage[] =
     "Usage: makedep [options]\n"
     "Options:\n"
+    "   -C          Generate compile_commands.json along with the makefile\n"
     "   -S          Generate Automake-style silent rules\n"
     "   -fxxx       Store output in file 'xxx' (default: Makefile)\n";
 
@@ -552,6 +565,26 @@ static char *concat_paths( const char *base, const char *path )
 }
 
 
+/*******************************************************************
+ *         escape_cstring
+ */
+static const char *escape_cstring( const char *str )
+{
+    char *ret;
+    unsigned int i = 0, j = 0;
+
+    if (!strpbrk( str, "\\\"" )) return str;
+    ret = xmalloc( 2 * strlen(str) + 1 );
+    while (str[i])
+    {
+        if (str[i] == '\\' || str[i] == '"') ret[j++] = '\\';
+        ret[j++] = str[i++];
+    }
+    ret[j] = 0;
+    return ret;
+}
+
+
 /*******************************************************************
  *         is_native_arch_disabled
  *
@@ -3166,7 +3199,7 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
                                     unsigned int arch )
 {
     const char *obj_name, *var_cc, *var_cflags;
-    struct strarray arch_cflags = empty_strarray;
+    struct strarray cflags = empty_strarray;
 
     if (make->disabled[arch] && !(source->file->flags & FLAG_C_IMPLIB)) return;
 
@@ -3197,46 +3230,46 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
     else
         strarray_add( &make->clean_files, obj_name );
 
+    if (!source->use_msvcrt) strarray_addall( &cflags, make->unix_cflags );
     if ((source->file->flags & FLAG_ARM64EC_X64) && !strcmp( archs.str[arch], "arm64ec" ))
     {
         var_cc     = "$(x86_64_CC)";
         var_cflags = "$(x86_64_CFLAGS)";
-        strarray_add( &arch_cflags, "-D__arm64ec_x64__" );
-        strarray_addall( &arch_cflags, get_expanded_make_var_array( top_makefile, "x86_64_EXTRACFLAGS" ));
+        strarray_add( &cflags, "-D__arm64ec_x64__" );
+        strarray_addall( &cflags, get_expanded_make_var_array( top_makefile, "x86_64_EXTRACFLAGS" ));
     }
     else
     {
         var_cc     = arch_make_variable( "CC", arch );
         var_cflags = arch_make_variable( "CFLAGS", arch );
-        strarray_addall( &arch_cflags, make->extlib ? extra_cflags_extlib[arch] : extra_cflags[arch] );
+        strarray_addall( &cflags, make->extlib ? extra_cflags_extlib[arch] : extra_cflags[arch] );
     }
 
-    output( "%s: %s\n", obj_dir_path( make, obj_name ), source->filename );
-    output( "\t%s%s -c -o $@ %s", cmd_prefix( "CC" ), var_cc, source->filename );
-    output_filenames( defines );
-    if (!source->use_msvcrt) output_filenames( make->unix_cflags );
-    output_filenames( arch_cflags );
-
     if (!arch)
     {
         if (source->file->flags & FLAG_C_UNIX)
         {
-            output_filenames( unix_dllflags );
+            strarray_addall( &cflags, unix_dllflags );
         }
         else if (make->module || make->testdll)
         {
-            output_filenames( dll_flags );
-            if (source->use_msvcrt) output_filenames( msvcrt_flags );
+            strarray_addall( &cflags, dll_flags );
+            if (source->use_msvcrt) strarray_addall( &cflags, msvcrt_flags );
             if (!unix_lib_supported && make->module && is_crt_module( make->module ))
-                output_filename( "-fno-builtin" );
+                strarray_add( &cflags, "-fno-builtin" );
         }
     }
     else
     {
-        if (make->module && is_crt_module( make->module )) output_filename( "-fno-builtin" );
+        if (make->module && is_crt_module( make->module )) strarray_add( &cflags, "-fno-builtin" );
     }
 
-    output_filenames( cpp_flags );
+    strarray_addall( &cflags, cpp_flags );
+
+    output( "%s: %s\n", obj_dir_path( make, obj_name ), source->filename );
+    output( "\t%s%s -c -o $@ %s", cmd_prefix( "CC" ), var_cc, source->filename );
+    output_filenames( defines );
+    output_filenames( cflags );
     output_filename( var_cflags );
     output( "\n" );
 
@@ -3254,6 +3287,29 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
                 root_src_dir_path( "tools/runtest" ), make->testdll,
                 obj_dir_path( make, arch_module_name( test_exe, arch )), obj );
     }
+
+    if (!(source->file->flags & FLAG_GENERATED))
+    {
+        struct compile_command *cmd = malloc( sizeof(*cmd) );
+
+        cmd->source = source->filename;
+        cmd->obj = obj_dir_path( make, obj_name );
+        cmd->args = empty_strarray;
+        strarray_addall( &cmd->args, defines );
+        strarray_addall( &cmd->args, cflags );
+
+        if ((source->file->flags & FLAG_ARM64EC_X64) && !strcmp( archs.str[arch], "arm64ec" ))
+        {
+            cmd->cmd = get_expanded_make_variable( make, "x86_64_CC" );
+            strarray_add( &cmd->args, get_expanded_make_variable( make, "x86_64_CFLAGS" ));
+        }
+        else
+        {
+            cmd->cmd = get_expanded_arch_var( make, "CC", arch );
+            strarray_add( &cmd->args, get_expanded_arch_var( make, "CFLAGS", arch ));
+        }
+        list_add_tail( &compile_commands, &cmd->entry );
+    }
 }
 
 
@@ -4043,6 +4099,41 @@ static void output_linguas( const struct makefile *make )
 }
 
 
+/*******************************************************************
+ *         output_compile_commands
+ */
+static void output_compile_commands( const char *dest )
+{
+    struct compile_command *cmd;
+    unsigned int i;
+    const char *dir;
+    char buffer[PATH_MAX];
+
+    output_file = create_temp_file( dest );
+
+    getcwd( buffer, sizeof(buffer) );
+    dir = escape_cstring( buffer );
+
+    output( "[\n" );
+    LIST_FOR_EACH_ENTRY( cmd, &compile_commands, struct compile_command, entry )
+    {
+        output( "  {\n" );
+        output( "    \"command\": \"%s -c -o %s %s", cmd->cmd, cmd->obj, cmd->source );
+        for (i = 0; i < cmd->args.count; i++) output( " %s", escape_cstring( cmd->args.str[i] ));
+        output( "\",\n" );
+        output( "    \"file\": \"%s\",\n", cmd->source );
+        output( "    \"output\": \"%s\",\n", cmd->obj );
+        output( "    \"directory\": \"%s\"\n", dir );
+        output( "  }%s\n", list_next( &compile_commands, &cmd->entry ) ? "," : "" );
+    }
+    output( "]\n" );
+
+    if (fclose( output_file )) fatal_perror( "write" );
+    output_file = NULL;
+    rename_temp_file( dest );
+}
+
+
 /*******************************************************************
  *         output_testlist
  */
@@ -4216,7 +4307,8 @@ static void output_top_makefile( struct makefile *make )
     makedep = strmake( "%s%s",tools_dir_path( make, "makedep" ), tools_ext );
     output( "Makefile: %s\n", makedep );
     output( "depend: %s\n", makedep );
-    output( "\t%s%s\n", makedep,
+    output( "\t%s%s%s\n", makedep,
+            compile_commands_mode ? " -C" : "",
             silent_rules ? " -S" : "" );
     strarray_add( &make->phony_targets, "depend" );
 
@@ -4396,6 +4488,9 @@ static int parse_option( const char *opt )
     case 'f':
         if (opt[2]) output_makefile_name = opt + 2;
         break;
+    case 'C':
+        compile_commands_mode = 1;
+        break;
     case 'S':
         silent_rules = 1;
         break;
@@ -4550,5 +4645,7 @@ int main( int argc, char *argv[] )
     output_dependencies( top_makefile );
     for (i = 0; i < subdirs.count; i++) output_dependencies( submakes[i] );
 
+    if (compile_commands_mode) output_compile_commands( "compile_commands.json" );
+
     return 0;
 }
-- 
2.48.1


From 018b8e0a30cff8d5c5d697e1aa4bdd48d0edf73d Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Sat, 3 Aug 2024 07:39:14 -0700
Subject: [PATCH 96/98] Revert "__avg__ patch for opencl"

This reverts commit b3e836f7c6bca10745384a7eab715c575ad0e180.
---
 dlls/opencl/Makefile.in            |   3 +-
 dlls/opencl/cl_khr_d3d10_sharing.c | 164 -----------------------------
 dlls/opencl/extensions.h           |  10 --
 dlls/opencl/make_opencl            |  17 +--
 dlls/opencl/opencl_types.h         |  23 ----
 dlls/opencl/pe_thunks.c            |   7 --
 dlls/opencl/pe_wrappers.c          |  30 +-----
 7 files changed, 4 insertions(+), 250 deletions(-)
 delete mode 100644 dlls/opencl/cl_khr_d3d10_sharing.c
 delete mode 100644 dlls/opencl/extensions.h

diff --git a/dlls/opencl/Makefile.in b/dlls/opencl/Makefile.in
index aac44bdb20d..69df0a3073c 100644
--- a/dlls/opencl/Makefile.in
+++ b/dlls/opencl/Makefile.in
@@ -6,5 +6,4 @@ SOURCES = \
 	pe_thunks.c \
 	pe_wrappers.c \
 	unix_thunks.c \
-	unix_wrappers.c \
-	cl_khr_d3d10_sharing.c
+	unix_wrappers.c
diff --git a/dlls/opencl/cl_khr_d3d10_sharing.c b/dlls/opencl/cl_khr_d3d10_sharing.c
deleted file mode 100644
index 737afce9ea9..00000000000
--- a/dlls/opencl/cl_khr_d3d10_sharing.c
+++ /dev/null
@@ -1,164 +0,0 @@
-#include "opencl_private.h"
-#include "opencl_types.h"
-#include "unixlib.h"
-#include "extensions.h"
-
-#define COBJMACROS
-#include "objbase.h"
-#include "initguid.h"
-#include "dxgi1_6.h"
-
-
-WINE_DEFAULT_DEBUG_CHANNEL(opencl);
-
-
-cl_int compare_dxgi_cl_device(IUnknown* d3d_adapter, cl_device_id cl_device, cl_bool *result) {
-    cl_int err;
-    IDXGIAdapter *this;
-    DXGI_ADAPTER_DESC info;
-    WCHAR *cl_name;
-    struct clGetDeviceInfo_params params;
-
-    // note: it is possible to compare the UUID if the device supports cl_khr_device_uuid
-    // and I would like to do that, but I also want built in DXVK support :)
-    // also SLI isn't really supported anymore so probs not relevant
-    if (FAILED(IUnknown_QueryInterface(d3d_adapter, &IID_IDXGIAdapter, (void **)&this))) {
-        ERR("Not a IDXGIAdapter %p.\n", d3d_adapter);
-        return CL_DEVICE_NOT_FOUND;
-    }
-
-    if (FAILED(IDXGIAdapter_GetDesc(this, &info))) {
-        ERR("Could not get adapter info %p.\n", this);
-        IUnknown_Release(this);
-        return CL_DEVICE_NOT_FOUND;
-    }
-    IUnknown_Release(this);
-
-
-    params.device = cl_device;
-    params.param_name = CL_DEVICE_NAME;
-    params.param_value = NULL;
-    params.param_value_size = 0;
-    params.param_value_size_ret = &params.param_value_size;
-    if ((err = OPENCL_CALL( clGetDeviceInfo, &params ))) {
-        ERR("Error getting device name of %p; %d.\n", cl_device, err);
-        return err;
-    }
-
-    if (!(params.param_value = calloc(params.param_value_size+1, 1)))
-        err = CL_OUT_OF_HOST_MEMORY;
-    if (!(cl_name = calloc(params.param_value_size+1, sizeof(WCHAR))))
-        err = CL_OUT_OF_HOST_MEMORY;
-
-    if (err) {
-        if (params.param_value) free(params.param_value);
-        if (cl_name) free(params.param_value);
-        return err;
-    }
-
-    if ((err = OPENCL_CALL( clGetDeviceInfo, &params ))) {
-        ERR("Error getting device name of %p; %d.\n", cl_device, err);
-        return err;
-    }
-
-    mbstowcs(cl_name, params.param_value, params.param_value_size);
-    free(params.param_value);
-
-    TRACE("cl_name %s, from %lld, d3d %s.\n", wine_dbgstr_w(cl_name), params.param_value_size, wine_dbgstr_w(info.Description));
-    *result = (wcscmp(cl_name, info.Description) == 0);
-
-    free(cl_name);
-
-    return CL_SUCCESS;
-}
-
-
-cl_int WINAPI dxgi_adapter_to_opencl(
-    IUnknown *adapter,
-    cl_platform_id platform,
-    cl_uint d3d_device_set,
-    cl_uint num_entries,
-    cl_device_id *devices,
-    cl_uint *num_devices
-) {
-    struct clGetDeviceIDs_params ids_params;
-
-    int i;
-    cl_int err;
-    cl_uint p_num_devices;
-    cl_bool same_device;
-
-
-    ids_params.platform = platform;
-    ids_params.device_type = CL_DEVICE_TYPE_ALL;
-    ids_params.num_devices = &ids_params.num_entries;
-    ids_params.num_entries = 0;
-    ids_params.devices = NULL;
-
-    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params )))
-        return err;
-
-    if (!(ids_params.devices = calloc(ids_params.num_entries, sizeof(cl_device_id))))
-        return CL_OUT_OF_HOST_MEMORY;
-
-    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params ))) {
-        free(ids_params.devices);
-        return err;
-    }
-
-    p_num_devices = 0;
-
-    // compare devices
-    for (i=0; i<ids_params.num_entries; i++) {
-        err = compare_dxgi_cl_device(adapter, ids_params.devices[i], &same_device);
-        if (err)
-            break;
-
-        if (!same_device)
-            continue;
-
-        if (devices) {
-            if (num_entries > p_num_devices) {
-                devices[p_num_devices] = ids_params.devices[i];
-            } else {
-                err = CL_INVALID_VALUE;
-                break;
-            }
-        }
-        p_num_devices++;
-    }
-
-    free(ids_params.devices);
-
-    if ((!err) && num_devices)
-        *num_devices = p_num_devices;
-
-    return err;
-}
-
-
-cl_int WINAPI clGetDeviceIDsFromD3D10KHR(
-    cl_platform_id platform,
-    cl_uint d3d_device_source,
-    void* d3d_object,
-    cl_uint d3d_device_set,
-    cl_uint num_entries,
-    cl_device_id* devices,
-    cl_uint* num_devices
-) {
-    TRACE("platform %p, device_source %d, d3d_object %p, d3d_device_set %u, num_entries %u, devices %p, num_devices %p semi-stub!\n",
-        platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
-
-    return dxgi_adapter_to_opencl((IUnknown*)d3d_object, platform,
-            d3d_device_set, num_entries, devices, num_devices);
-}
-
-
-void* cl_khr_d3d10_sharing_get_function(const char* name) {
-    // NOTE: other functions in this extension seem non-trivial to implement,
-    // involve lots of deep knowledge of D3D and OpenCL (which I do not have),
-    // and may involve a heavy rewrite of this whole OpenCL wrapper.
-    if (!strcmp(name, "clGetDeviceIDsFromD3D10KHR"))
-        return clGetDeviceIDsFromD3D10KHR;
-    return NULL;
-}
diff --git a/dlls/opencl/extensions.h b/dlls/opencl/extensions.h
deleted file mode 100644
index 4c7e9955751..00000000000
--- a/dlls/opencl/extensions.h
+++ /dev/null
@@ -1,10 +0,0 @@
-struct extension_info {
-    const char *name;
-    void* (*get_function)(const char*);
-};
-
-void* cl_khr_d3d10_sharing_get_function(const char*);
-
-static struct extension_info known_extensions[] = {
-    {"cl_khr_d3d10_sharing", cl_khr_d3d10_sharing_get_function}
-};
diff --git a/dlls/opencl/make_opencl b/dlls/opencl/make_opencl
index af2839b649c..6d9881c84b3 100755
--- a/dlls/opencl/make_opencl
+++ b/dlls/opencl/make_opencl
@@ -60,6 +60,7 @@ my %unsupported_extensions =
         # Needs wined3d integration.
         "cl_intel_d3d11_nv12_media_sharing" => 1,
         "cl_intel_dx9_media_sharing" => 1,
+        "cl_khr_d3d10_sharing" => 1,
         "cl_khr_d3d11_sharing" => 1,
         "cl_khr_dx9_media_sharing" => 1,
         "cl_nv_d3d9_sharing" => 1,
@@ -75,11 +76,6 @@ my %unsupported_extensions =
         "cl_arm_shared_virtual_memory" => 1,
     );
 
-my %provided_extensions =
-    (
-        "cl_khr_d3d10_sharing" => 1,
-    );
-
 sub generate_pe_thunk($$)
 {
     my ($name, $func_ref) = @_;
@@ -513,8 +509,6 @@ sub parse_file($)
         # support KHR_gl_sharing yet, but we need to export the functions anyway
         # (some applications expect them to be present).
         parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_gl_sharing";
-        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_device_uuid";
-        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_d3d10_sharing";
     }
 }
 
@@ -538,8 +532,7 @@ print PE "/* Automatically generated from OpenCL registry files; DO NOT EDIT! */
 
 print PE "#include \"opencl_private.h\"\n";
 print PE "#include \"opencl_types.h\"\n";
-print PE "#include \"unixlib.h\"\n";
-print PE "#include \"extensions.h\"\n\n";
+print PE "#include \"unixlib.h\"\n\n";
 
 print PE "WINE_DEFAULT_DEBUG_CHANNEL(opencl);\n" if $gen_traces;
 
@@ -568,12 +561,6 @@ foreach (sort keys %unsupported_extensions)
 print PE <<EOF
     };
 
-    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
-    {
-        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
-            return TRUE;
-    }
-
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/opencl_types.h b/dlls/opencl/opencl_types.h
index b752f6f13f8..b116bb55259 100644
--- a/dlls/opencl/opencl_types.h
+++ b/dlls/opencl/opencl_types.h
@@ -79,8 +79,6 @@ typedef struct _cl_image_desc
  cl_mem mem_object;
  };
 } cl_image_desc;
-typedef cl_uint          cl_d3d10_device_source_khr;
-typedef cl_uint          cl_d3d10_device_set_khr;
 typedef cl_uint          cl_gl_context_info;
 typedef cl_uint          cl_gl_object_type;
 typedef cl_uint          cl_gl_texture_info;
@@ -92,7 +90,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_ADDRESS_MIRRORED_REPEAT 0x1134
 #define CL_ADDRESS_NONE 0x1130
 #define CL_ADDRESS_REPEAT 0x1133
-#define CL_ALL_DEVICES_FOR_D3D10_KHR 0x4013
 #define CL_ARGB 0x10B7
 #define CL_BGRA 0x10B6
 #define CL_BLOCKING CL_TRUE
@@ -106,7 +103,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CHAR_BIT 8
 #define CL_CHAR_MAX CL_SCHAR_MAX
 #define CL_CHAR_MIN CL_SCHAR_MIN
-#define CL_COMMAND_ACQUIRE_D3D10_OBJECTS_KHR 0x4017
 #define CL_COMMAND_ACQUIRE_GL_OBJECTS 0x11FF
 #define CL_COMMAND_BARRIER 0x1205
 #define CL_COMMAND_COPY_BUFFER 0x11F5
@@ -125,7 +121,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMMAND_READ_BUFFER 0x11F3
 #define CL_COMMAND_READ_BUFFER_RECT 0x1201
 #define CL_COMMAND_READ_IMAGE 0x11F6
-#define CL_COMMAND_RELEASE_D3D10_OBJECTS_KHR 0x4018
 #define CL_COMMAND_RELEASE_GL_OBJECTS 0x1200
 #define CL_COMMAND_TASK 0x11F1
 #define CL_COMMAND_UNMAP_MEM_OBJECT 0x11FD
@@ -136,8 +131,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMPILER_NOT_AVAILABLE -3
 #define CL_COMPILE_PROGRAM_FAILURE -15
 #define CL_COMPLETE 0x0
-#define CL_CONTEXT_D3D10_DEVICE_KHR 0x4014
-#define CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR 0x402C
 #define CL_CONTEXT_DEVICES 0x1081
 #define CL_CONTEXT_INTEROP_USER_SYNC 0x1085
 #define CL_CONTEXT_NUM_DEVICES 0x1083
@@ -145,10 +138,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CONTEXT_PROPERTIES 0x1082
 #define CL_CONTEXT_REFERENCE_COUNT 0x1080
 #define CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR 0x2006
-#define CL_D3D10_DEVICE_KHR 0x4010
-#define CL_D3D10_DXGI_ADAPTER_KHR 0x4011
-#define CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR -1004
-#define CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR -1005
 #define CL_DBL_DIG 15
 #define CL_DBL_EPSILON 2.220446049250313080847e-16
 #define CL_DBL_MANT_DIG 53
@@ -191,8 +180,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_LINKER_AVAILABLE 0x103E
 #define CL_DEVICE_LOCAL_MEM_SIZE 0x1023
 #define CL_DEVICE_LOCAL_MEM_TYPE 0x1022
-#define CL_DEVICE_LUID_KHR 0x106D
-#define CL_DEVICE_LUID_VALID_KHR 0x106C
 #define CL_DEVICE_MAX_CLOCK_FREQUENCY 0x100C
 #define CL_DEVICE_MAX_COMPUTE_UNITS 0x1002
 #define CL_DEVICE_MAX_CONSTANT_ARGS 0x1021
@@ -215,7 +202,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_INT 0x1038
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG 0x1039
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT 0x1037
-#define CL_DEVICE_NODE_MASK_KHR 0x106E
 #define CL_DEVICE_NOT_AVAILABLE -2
 #define CL_DEVICE_NOT_FOUND -1
 #define CL_DEVICE_OPENCL_C_VERSION 0x103D
@@ -251,11 +237,9 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_TYPE_CUSTOM (1 << 4)
 #define CL_DEVICE_TYPE_DEFAULT (1 << 0)
 #define CL_DEVICE_TYPE_GPU (1 << 2)
-#define CL_DEVICE_UUID_KHR 0x106A
 #define CL_DEVICE_VENDOR 0x102C
 #define CL_DEVICE_VENDOR_ID 0x1001
 #define CL_DEVICE_VERSION 0x102F
-#define CL_DRIVER_UUID_KHR 0x106B
 #define CL_DRIVER_VERSION 0x102D
 #define CL_EGL_DISPLAY_KHR 0x2009
 #define CL_EVENT_COMMAND_EXECUTION_STATUS 0x11D3
@@ -307,7 +291,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_HUGE_VALF ((cl_float) 1e50)
 #define CL_IMAGE_ARRAY_SIZE 0x1117
 #define CL_IMAGE_BUFFER 0x1118
-#define CL_IMAGE_D3D10_SUBRESOURCE_KHR 0x4016
 #define CL_IMAGE_DEPTH 0x1116
 #define CL_IMAGE_ELEMENT_SIZE 0x1111
 #define CL_IMAGE_FORMAT 0x1110
@@ -332,8 +315,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_INVALID_COMMAND_QUEUE -36
 #define CL_INVALID_COMPILER_OPTIONS -66
 #define CL_INVALID_CONTEXT -34
-#define CL_INVALID_D3D10_DEVICE_KHR -1002
-#define CL_INVALID_D3D10_RESOURCE_KHR -1003
 #define CL_INVALID_DEVICE -33
 #define CL_INVALID_DEVICE_PARTITION_COUNT -68
 #define CL_INVALID_DEVICE_TYPE -31
@@ -400,7 +381,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_LOCAL 0x1
 #define CL_LONG_MAX ((cl_long) 0x7FFFFFFFFFFFFFFFLL)
 #define CL_LONG_MIN ((cl_long) -0x7FFFFFFFFFFFFFFFLL - 1LL)
-#define CL_LUID_SIZE_KHR 8
 #define CL_LUMINANCE 0x10B9
 #define CL_MAP_FAILURE -12
 #define CL_MAP_READ (1 << 0)
@@ -412,7 +392,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_MEM_CONTEXT 0x1106
 #define CL_MEM_COPY_HOST_PTR (1 << 5)
 #define CL_MEM_COPY_OVERLAP -8
-#define CL_MEM_D3D10_RESOURCE_KHR 0x4015
 #define CL_MEM_FLAGS 0x1101
 #define CL_MEM_HOST_NO_ACCESS (1 << 9)
 #define CL_MEM_HOST_PTR 0x1103
@@ -448,7 +427,6 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_PLATFORM_PROFILE 0x0900
 #define CL_PLATFORM_VENDOR 0x0903
 #define CL_PLATFORM_VERSION 0x0901
-#define CL_PREFERRED_DEVICES_FOR_D3D10_KHR 0x4012
 #define CL_PROFILING_COMMAND_END 0x1283
 #define CL_PROFILING_COMMAND_QUEUED 0x1280
 #define CL_PROFILING_COMMAND_START 0x1282
@@ -518,5 +496,4 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_UNSIGNED_INT32 0x10DC
 #define CL_UNSIGNED_INT8 0x10DA
 #define CL_USHRT_MAX 65535
-#define CL_UUID_SIZE_KHR 16
 #define CL_WGL_HDC_KHR 0x200B
diff --git a/dlls/opencl/pe_thunks.c b/dlls/opencl/pe_thunks.c
index 288a19e7e7a..f34826e5377 100644
--- a/dlls/opencl/pe_thunks.c
+++ b/dlls/opencl/pe_thunks.c
@@ -3,7 +3,6 @@
 #include "opencl_private.h"
 #include "opencl_types.h"
 #include "unixlib.h"
-#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -668,12 +667,6 @@ BOOL extension_is_supported( const char *name, size_t len )
         "cl_qcom_ext_host_ptr",
     };
 
-    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
-    {
-        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
-            return TRUE;
-    }
-
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/pe_wrappers.c b/dlls/opencl/pe_wrappers.c
index 00896b7c37c..3b6846009c1 100644
--- a/dlls/opencl/pe_wrappers.c
+++ b/dlls/opencl/pe_wrappers.c
@@ -22,7 +22,6 @@
 #include "opencl_types.h"
 #include "unixlib.h"
 #include "wine/wgl.h"
-#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -36,13 +35,6 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
 
     ext = unix_exts;
     win_size = 0;
-
-    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
-        if (!strstr(ext, known_extensions[i].name)) {
-            win_size += strlen(known_extensions[i].name) + 1;
-        }
-    }
-
     while (*ext)
     {
         const char *end = strchr( ext, ' ' );
@@ -61,17 +53,6 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
     if (size < win_size) return CL_INVALID_VALUE;
 
     win_exts[0] = 0;
-
-    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
-        size_t len;
-        if (!strstr(unix_exts, known_extensions[i].name)) {
-            len = strlen(known_extensions[i].name);
-            if (p != win_exts) *p++ = ' ';
-            memcpy(p, known_extensions[i].name, len);
-            p += len;
-        }
-    }
-
     ext = unix_exts;
     while (*ext)
     {
@@ -193,17 +174,8 @@ cl_int WINAPI clGetDeviceInfo( cl_device_id device, cl_device_info name,
 
 void * WINAPI clGetExtensionFunctionAddress( const char *func_name )
 {
-    int i;
     void * ret = 0;
     TRACE("(%s)\n",func_name);
-    for (i=0; i<ARRAY_SIZE(known_extensions); i++) {
-        if (known_extensions->get_function == NULL)
-            continue;
-        ret = known_extensions->get_function(func_name);
-        if (ret)
-            break;
-    }
-    return ret;
 #if 0
     ret = clGetExtensionFunctionAddress(func_name);
 #else
@@ -225,7 +197,7 @@ cl_int WINAPI clSetCommandQueueProperty( cl_command_queue command_queue, cl_comm
 void * WINAPI clGetExtensionFunctionAddressForPlatform( cl_platform_id platform, const char *func_name )
 {
     FIXME( "(%p, %s) stub!\n", platform, debugstr_a(func_name) );
-    return clGetExtensionFunctionAddress(func_name);
+    return NULL;
 }
 
 
-- 
2.48.1


From 326ffae82760b29995e1e5b66e24429602fe0609 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Sat, 3 Aug 2024 21:42:00 -0700
Subject: [PATCH 97/98] __avg__'s second patch changes for opencl

---
 dlls/opencl/Makefile.in            |   3 +-
 dlls/opencl/cl_khr_d3d10_sharing.c | 144 +++++++++++++++++++++++++++++
 dlls/opencl/extensions.h           |  10 ++
 dlls/opencl/make_opencl            |  17 +++-
 dlls/opencl/opencl_types.h         |  23 +++++
 dlls/opencl/pe_thunks.c            |  11 ++-
 dlls/opencl/pe_wrappers.c          |  30 +++++-
 7 files changed, 233 insertions(+), 5 deletions(-)
 create mode 100644 dlls/opencl/cl_khr_d3d10_sharing.c
 create mode 100644 dlls/opencl/extensions.h

diff --git a/dlls/opencl/Makefile.in b/dlls/opencl/Makefile.in
index 69df0a3073c..aac44bdb20d 100644
--- a/dlls/opencl/Makefile.in
+++ b/dlls/opencl/Makefile.in
@@ -6,4 +6,5 @@ SOURCES = \
 	pe_thunks.c \
 	pe_wrappers.c \
 	unix_thunks.c \
-	unix_wrappers.c
+	unix_wrappers.c \
+	cl_khr_d3d10_sharing.c
diff --git a/dlls/opencl/cl_khr_d3d10_sharing.c b/dlls/opencl/cl_khr_d3d10_sharing.c
new file mode 100644
index 00000000000..5b569bebad8
--- /dev/null
+++ b/dlls/opencl/cl_khr_d3d10_sharing.c
@@ -0,0 +1,144 @@
+#include "opencl_private.h"
+#include "opencl_types.h"
+#include "unixlib.h"
+#include "extensions.h"
+
+#define COBJMACROS
+#include "objbase.h"
+#include "initguid.h"
+#include "wine/wined3d.h"
+#include "wine/winedxgi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(opencl);
+
+
+cl_int compare_dxgi_cl_device(IUnknown* d3d_adapter, cl_device_id cl_device, cl_bool *result) {
+    cl_int err;
+    IWineDXGIAdapter *this;
+    DWORD cl_vid;
+    struct wine_dxgi_adapter_info dx_info;
+    struct clGetDeviceInfo_params params;
+
+    /*
+    So it turns out that the ROCM opencl driver sets the name to a weird codename,
+    and does not support cl_khr_device_uuid, so we can't use those to confirm the devices are the same.
+    There's also some funkiness with clSetEventCallback and/or clFlush.
+    */
+    if (FAILED(IUnknown_QueryInterface(d3d_adapter, &IID_IWineDXGIAdapter, (void **)&this))) {
+        ERR("Not a IDXGIAdapter %p.\n", d3d_adapter);
+        return CL_DEVICE_NOT_FOUND;
+    }
+
+    if (FAILED(IWineDXGIAdapter_get_adapter_info(this, &dx_info))) {
+        ERR("Could not get adapter info %p.\n", this);
+        IUnknown_Release(this);
+        return CL_DEVICE_NOT_FOUND;
+    }
+    IUnknown_Release(this);
+
+    params.device = cl_device;
+    params.param_name = CL_DEVICE_VENDOR_ID;
+    params.param_value = &cl_vid;
+    params.param_value_size = sizeof(cl_vid);
+    params.param_value_size_ret = NULL;
+    if ((err = OPENCL_CALL( clGetDeviceInfo, &params ))) {
+        ERR("Error getting device uuid of %p; %d.\n", cl_device, err);
+        return err;
+    }
+
+    *result = cl_vid == dx_info.vendor_id;
+    TRACE("cl_vid %ld, dx_uuid %ld, samedevice %i\n", cl_vid, dx_info.vendor_id, *result);
+
+    return CL_SUCCESS;
+}
+
+
+cl_int WINAPI dxgi_adapter_to_opencl(
+    IUnknown *adapter,
+    cl_platform_id platform,
+    cl_uint d3d_device_set,
+    cl_uint num_entries,
+    cl_device_id *devices,
+    cl_uint *num_devices
+) {
+    struct clGetDeviceIDs_params ids_params;
+
+    int i;
+    cl_int err;
+    cl_uint p_num_devices;
+    cl_bool same_device;
+
+
+    ids_params.platform = platform;
+    ids_params.device_type = CL_DEVICE_TYPE_ALL;
+    ids_params.num_devices = &ids_params.num_entries;
+    ids_params.num_entries = 0;
+    ids_params.devices = NULL;
+
+    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params )))
+        return err;
+
+    if (!(ids_params.devices = calloc(ids_params.num_entries, sizeof(cl_device_id))))
+        return CL_OUT_OF_HOST_MEMORY;
+
+    if ((err = OPENCL_CALL( clGetDeviceIDs , &ids_params ))) {
+        free(ids_params.devices);
+        return err;
+    }
+
+    p_num_devices = 0;
+
+    // compare devices
+    for (i=0; i<ids_params.num_entries; i++) {
+        err = compare_dxgi_cl_device(adapter, ids_params.devices[i], &same_device);
+        if (err)
+            break;
+
+        if (!same_device)
+            continue;
+
+        if (devices) {
+            if (num_entries > p_num_devices) {
+                devices[p_num_devices] = ids_params.devices[i];
+            } else {
+                err = CL_INVALID_VALUE;
+                break;
+            }
+        }
+        p_num_devices++;
+    }
+
+    free(ids_params.devices);
+
+    if ((!err) && num_devices)
+        *num_devices = p_num_devices;
+
+    return err;
+}
+
+
+cl_int WINAPI clGetDeviceIDsFromD3D10KHR(
+    cl_platform_id platform,
+    cl_uint d3d_device_source,
+    void* d3d_object,
+    cl_uint d3d_device_set,
+    cl_uint num_entries,
+    cl_device_id* devices,
+    cl_uint* num_devices
+) {
+    TRACE("platform %p, device_source %d, d3d_object %p, d3d_device_set %u, num_entries %u, devices %p, num_devices %p semi-stub!\n",
+        platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
+
+    return dxgi_adapter_to_opencl((IUnknown*)d3d_object, platform,
+            d3d_device_set, num_entries, devices, num_devices);
+}
+
+
+void* cl_khr_d3d10_sharing_get_function(const char* name) {
+    // NOTE: other functions in this extension seem non-trivial to implement,
+    // involve lots of deep knowledge of D3D and OpenCL (which I do not have),
+    // and may involve a heavy rewrite of this whole OpenCL wrapper.
+    if (!strcmp(name, "clGetDeviceIDsFromD3D10KHR"))
+        return clGetDeviceIDsFromD3D10KHR;
+    return NULL;
+}
diff --git a/dlls/opencl/extensions.h b/dlls/opencl/extensions.h
new file mode 100644
index 00000000000..4c7e9955751
--- /dev/null
+++ b/dlls/opencl/extensions.h
@@ -0,0 +1,10 @@
+struct extension_info {
+    const char *name;
+    void* (*get_function)(const char*);
+};
+
+void* cl_khr_d3d10_sharing_get_function(const char*);
+
+static struct extension_info known_extensions[] = {
+    {"cl_khr_d3d10_sharing", cl_khr_d3d10_sharing_get_function}
+};
diff --git a/dlls/opencl/make_opencl b/dlls/opencl/make_opencl
index 6d9881c84b3..af2839b649c 100755
--- a/dlls/opencl/make_opencl
+++ b/dlls/opencl/make_opencl
@@ -60,7 +60,6 @@ my %unsupported_extensions =
         # Needs wined3d integration.
         "cl_intel_d3d11_nv12_media_sharing" => 1,
         "cl_intel_dx9_media_sharing" => 1,
-        "cl_khr_d3d10_sharing" => 1,
         "cl_khr_d3d11_sharing" => 1,
         "cl_khr_dx9_media_sharing" => 1,
         "cl_nv_d3d9_sharing" => 1,
@@ -76,6 +75,11 @@ my %unsupported_extensions =
         "cl_arm_shared_virtual_memory" => 1,
     );
 
+my %provided_extensions =
+    (
+        "cl_khr_d3d10_sharing" => 1,
+    );
+
 sub generate_pe_thunk($$)
 {
     my ($name, $func_ref) = @_;
@@ -509,6 +513,8 @@ sub parse_file($)
         # support KHR_gl_sharing yet, but we need to export the functions anyway
         # (some applications expect them to be present).
         parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_gl_sharing";
+        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_device_uuid";
+        parse_feature($ext, 0) if lc($ext->{name}) eq "cl_khr_d3d10_sharing";
     }
 }
 
@@ -532,7 +538,8 @@ print PE "/* Automatically generated from OpenCL registry files; DO NOT EDIT! */
 
 print PE "#include \"opencl_private.h\"\n";
 print PE "#include \"opencl_types.h\"\n";
-print PE "#include \"unixlib.h\"\n\n";
+print PE "#include \"unixlib.h\"\n";
+print PE "#include \"extensions.h\"\n\n";
 
 print PE "WINE_DEFAULT_DEBUG_CHANNEL(opencl);\n" if $gen_traces;
 
@@ -561,6 +568,12 @@ foreach (sort keys %unsupported_extensions)
 print PE <<EOF
     };
 
+    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
+    {
+        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
+            return TRUE;
+    }
+
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/opencl_types.h b/dlls/opencl/opencl_types.h
index b116bb55259..b752f6f13f8 100644
--- a/dlls/opencl/opencl_types.h
+++ b/dlls/opencl/opencl_types.h
@@ -79,6 +79,8 @@ typedef struct _cl_image_desc
  cl_mem mem_object;
  };
 } cl_image_desc;
+typedef cl_uint          cl_d3d10_device_source_khr;
+typedef cl_uint          cl_d3d10_device_set_khr;
 typedef cl_uint          cl_gl_context_info;
 typedef cl_uint          cl_gl_object_type;
 typedef cl_uint          cl_gl_texture_info;
@@ -90,6 +92,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_ADDRESS_MIRRORED_REPEAT 0x1134
 #define CL_ADDRESS_NONE 0x1130
 #define CL_ADDRESS_REPEAT 0x1133
+#define CL_ALL_DEVICES_FOR_D3D10_KHR 0x4013
 #define CL_ARGB 0x10B7
 #define CL_BGRA 0x10B6
 #define CL_BLOCKING CL_TRUE
@@ -103,6 +106,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CHAR_BIT 8
 #define CL_CHAR_MAX CL_SCHAR_MAX
 #define CL_CHAR_MIN CL_SCHAR_MIN
+#define CL_COMMAND_ACQUIRE_D3D10_OBJECTS_KHR 0x4017
 #define CL_COMMAND_ACQUIRE_GL_OBJECTS 0x11FF
 #define CL_COMMAND_BARRIER 0x1205
 #define CL_COMMAND_COPY_BUFFER 0x11F5
@@ -121,6 +125,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMMAND_READ_BUFFER 0x11F3
 #define CL_COMMAND_READ_BUFFER_RECT 0x1201
 #define CL_COMMAND_READ_IMAGE 0x11F6
+#define CL_COMMAND_RELEASE_D3D10_OBJECTS_KHR 0x4018
 #define CL_COMMAND_RELEASE_GL_OBJECTS 0x1200
 #define CL_COMMAND_TASK 0x11F1
 #define CL_COMMAND_UNMAP_MEM_OBJECT 0x11FD
@@ -131,6 +136,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_COMPILER_NOT_AVAILABLE -3
 #define CL_COMPILE_PROGRAM_FAILURE -15
 #define CL_COMPLETE 0x0
+#define CL_CONTEXT_D3D10_DEVICE_KHR 0x4014
+#define CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR 0x402C
 #define CL_CONTEXT_DEVICES 0x1081
 #define CL_CONTEXT_INTEROP_USER_SYNC 0x1085
 #define CL_CONTEXT_NUM_DEVICES 0x1083
@@ -138,6 +145,10 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_CONTEXT_PROPERTIES 0x1082
 #define CL_CONTEXT_REFERENCE_COUNT 0x1080
 #define CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR 0x2006
+#define CL_D3D10_DEVICE_KHR 0x4010
+#define CL_D3D10_DXGI_ADAPTER_KHR 0x4011
+#define CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR -1004
+#define CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR -1005
 #define CL_DBL_DIG 15
 #define CL_DBL_EPSILON 2.220446049250313080847e-16
 #define CL_DBL_MANT_DIG 53
@@ -180,6 +191,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_LINKER_AVAILABLE 0x103E
 #define CL_DEVICE_LOCAL_MEM_SIZE 0x1023
 #define CL_DEVICE_LOCAL_MEM_TYPE 0x1022
+#define CL_DEVICE_LUID_KHR 0x106D
+#define CL_DEVICE_LUID_VALID_KHR 0x106C
 #define CL_DEVICE_MAX_CLOCK_FREQUENCY 0x100C
 #define CL_DEVICE_MAX_COMPUTE_UNITS 0x1002
 #define CL_DEVICE_MAX_CONSTANT_ARGS 0x1021
@@ -202,6 +215,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_INT 0x1038
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG 0x1039
 #define CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT 0x1037
+#define CL_DEVICE_NODE_MASK_KHR 0x106E
 #define CL_DEVICE_NOT_AVAILABLE -2
 #define CL_DEVICE_NOT_FOUND -1
 #define CL_DEVICE_OPENCL_C_VERSION 0x103D
@@ -237,9 +251,11 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_DEVICE_TYPE_CUSTOM (1 << 4)
 #define CL_DEVICE_TYPE_DEFAULT (1 << 0)
 #define CL_DEVICE_TYPE_GPU (1 << 2)
+#define CL_DEVICE_UUID_KHR 0x106A
 #define CL_DEVICE_VENDOR 0x102C
 #define CL_DEVICE_VENDOR_ID 0x1001
 #define CL_DEVICE_VERSION 0x102F
+#define CL_DRIVER_UUID_KHR 0x106B
 #define CL_DRIVER_VERSION 0x102D
 #define CL_EGL_DISPLAY_KHR 0x2009
 #define CL_EVENT_COMMAND_EXECUTION_STATUS 0x11D3
@@ -291,6 +307,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_HUGE_VALF ((cl_float) 1e50)
 #define CL_IMAGE_ARRAY_SIZE 0x1117
 #define CL_IMAGE_BUFFER 0x1118
+#define CL_IMAGE_D3D10_SUBRESOURCE_KHR 0x4016
 #define CL_IMAGE_DEPTH 0x1116
 #define CL_IMAGE_ELEMENT_SIZE 0x1111
 #define CL_IMAGE_FORMAT 0x1110
@@ -315,6 +332,8 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_INVALID_COMMAND_QUEUE -36
 #define CL_INVALID_COMPILER_OPTIONS -66
 #define CL_INVALID_CONTEXT -34
+#define CL_INVALID_D3D10_DEVICE_KHR -1002
+#define CL_INVALID_D3D10_RESOURCE_KHR -1003
 #define CL_INVALID_DEVICE -33
 #define CL_INVALID_DEVICE_PARTITION_COUNT -68
 #define CL_INVALID_DEVICE_TYPE -31
@@ -381,6 +400,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_LOCAL 0x1
 #define CL_LONG_MAX ((cl_long) 0x7FFFFFFFFFFFFFFFLL)
 #define CL_LONG_MIN ((cl_long) -0x7FFFFFFFFFFFFFFFLL - 1LL)
+#define CL_LUID_SIZE_KHR 8
 #define CL_LUMINANCE 0x10B9
 #define CL_MAP_FAILURE -12
 #define CL_MAP_READ (1 << 0)
@@ -392,6 +412,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_MEM_CONTEXT 0x1106
 #define CL_MEM_COPY_HOST_PTR (1 << 5)
 #define CL_MEM_COPY_OVERLAP -8
+#define CL_MEM_D3D10_RESOURCE_KHR 0x4015
 #define CL_MEM_FLAGS 0x1101
 #define CL_MEM_HOST_NO_ACCESS (1 << 9)
 #define CL_MEM_HOST_PTR 0x1103
@@ -427,6 +448,7 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_PLATFORM_PROFILE 0x0900
 #define CL_PLATFORM_VENDOR 0x0903
 #define CL_PLATFORM_VERSION 0x0901
+#define CL_PREFERRED_DEVICES_FOR_D3D10_KHR 0x4012
 #define CL_PROFILING_COMMAND_END 0x1283
 #define CL_PROFILING_COMMAND_QUEUED 0x1280
 #define CL_PROFILING_COMMAND_START 0x1282
@@ -496,4 +518,5 @@ typedef cl_uint          cl_gl_platform_info;
 #define CL_UNSIGNED_INT32 0x10DC
 #define CL_UNSIGNED_INT8 0x10DA
 #define CL_USHRT_MAX 65535
+#define CL_UUID_SIZE_KHR 16
 #define CL_WGL_HDC_KHR 0x200B
diff --git a/dlls/opencl/pe_thunks.c b/dlls/opencl/pe_thunks.c
index f34826e5377..30ee098a395 100644
--- a/dlls/opencl/pe_thunks.c
+++ b/dlls/opencl/pe_thunks.c
@@ -3,6 +3,7 @@
 #include "opencl_private.h"
 #include "opencl_types.h"
 #include "unixlib.h"
+#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -581,9 +582,11 @@ cl_int WINAPI clRetainSampler( cl_sampler sampler )
 
 cl_int WINAPI clSetEventCallback( cl_event event, cl_int command_exec_callback_type, void (WINAPI* pfn_notify)(cl_event event, cl_int event_command_status, void *user_data), void* user_data )
 {
+    cl_int ret;
     struct clSetEventCallback_params params = { event, command_exec_callback_type, pfn_notify, user_data };
     TRACE( "(%p, %d, %p, %p)\n", event, command_exec_callback_type, pfn_notify, user_data );
-    return OPENCL_CALL( clSetEventCallback, &params );
+    ret = OPENCL_CALL( clSetEventCallback, &params );
+    return ret;
 }
 
 cl_int WINAPI clSetKernelArg( cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void* arg_value )
@@ -667,6 +670,12 @@ BOOL extension_is_supported( const char *name, size_t len )
         "cl_qcom_ext_host_ptr",
     };
 
+    for (i = 0; i< ARRAY_SIZE(known_extensions); i++)
+    {
+        if (known_extensions[i].get_function && !strncasecmp( name, known_extensions[i].name, len ))
+            return TRUE;
+    }
+
     for (i = 0; i < ARRAY_SIZE(unsupported); ++i)
     {
         if (!strncasecmp( name, unsupported[i], len ))
diff --git a/dlls/opencl/pe_wrappers.c b/dlls/opencl/pe_wrappers.c
index 3b6846009c1..00896b7c37c 100644
--- a/dlls/opencl/pe_wrappers.c
+++ b/dlls/opencl/pe_wrappers.c
@@ -22,6 +22,7 @@
 #include "opencl_types.h"
 #include "unixlib.h"
 #include "wine/wgl.h"
+#include "extensions.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(opencl);
 
@@ -35,6 +36,13 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
 
     ext = unix_exts;
     win_size = 0;
+
+    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        if (!strstr(ext, known_extensions[i].name)) {
+            win_size += strlen(known_extensions[i].name) + 1;
+        }
+    }
+
     while (*ext)
     {
         const char *end = strchr( ext, ' ' );
@@ -53,6 +61,17 @@ static cl_int filter_extensions( const char *unix_exts, SIZE_T size, char *win_e
     if (size < win_size) return CL_INVALID_VALUE;
 
     win_exts[0] = 0;
+
+    for (int i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        size_t len;
+        if (!strstr(unix_exts, known_extensions[i].name)) {
+            len = strlen(known_extensions[i].name);
+            if (p != win_exts) *p++ = ' ';
+            memcpy(p, known_extensions[i].name, len);
+            p += len;
+        }
+    }
+
     ext = unix_exts;
     while (*ext)
     {
@@ -174,8 +193,17 @@ cl_int WINAPI clGetDeviceInfo( cl_device_id device, cl_device_info name,
 
 void * WINAPI clGetExtensionFunctionAddress( const char *func_name )
 {
+    int i;
     void * ret = 0;
     TRACE("(%s)\n",func_name);
+    for (i=0; i<ARRAY_SIZE(known_extensions); i++) {
+        if (known_extensions->get_function == NULL)
+            continue;
+        ret = known_extensions->get_function(func_name);
+        if (ret)
+            break;
+    }
+    return ret;
 #if 0
     ret = clGetExtensionFunctionAddress(func_name);
 #else
@@ -197,7 +225,7 @@ cl_int WINAPI clSetCommandQueueProperty( cl_command_queue command_queue, cl_comm
 void * WINAPI clGetExtensionFunctionAddressForPlatform( cl_platform_id platform, const char *func_name )
 {
     FIXME( "(%p, %s) stub!\n", platform, debugstr_a(func_name) );
-    return NULL;
+    return clGetExtensionFunctionAddress(func_name);
 }
 
 
-- 
2.48.1


From a7c9b19e1a26cf49c63a7c19189a3e2bbe2c6ac2 Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Sat, 3 Aug 2024 21:50:31 -0700
Subject: [PATCH 98/98] Immediately call the callback

This is very not correct, but affinity hangs on startup otherwise.
I tried calling the unix space function, but the callback is in the
pe address space likely. And I'm not sure how to translate the calls
from opencl -> wine server -> the pe process. I tried a wrapper function
but it still crashes.
---
 dlls/opencl/pe_thunks.c     | 1 +
 dlls/opencl/unix_wrappers.c | 5 ++++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/opencl/pe_thunks.c b/dlls/opencl/pe_thunks.c
index 30ee098a395..dc84ce71e8f 100644
--- a/dlls/opencl/pe_thunks.c
+++ b/dlls/opencl/pe_thunks.c
@@ -586,6 +586,7 @@ cl_int WINAPI clSetEventCallback( cl_event event, cl_int command_exec_callback_t
     struct clSetEventCallback_params params = { event, command_exec_callback_type, pfn_notify, user_data };
     TRACE( "(%p, %d, %p, %p)\n", event, command_exec_callback_type, pfn_notify, user_data );
     ret = OPENCL_CALL( clSetEventCallback, &params );
+    params.pfn_notify(event, command_exec_callback_type, user_data);
     return ret;
 }
 
diff --git a/dlls/opencl/unix_wrappers.c b/dlls/opencl/unix_wrappers.c
index 5967979dba2..365e21eacc7 100644
--- a/dlls/opencl/unix_wrappers.c
+++ b/dlls/opencl/unix_wrappers.c
@@ -64,8 +64,11 @@ NTSTATUS wrap_clEnqueueNativeKernel( void *args )
 
 NTSTATUS wrap_clSetEventCallback( void *args )
 {
+    cl_int ret;
+    struct clSetEventCallback_params *params = args;
+    TRACE("(%p, %i, %p, %p) \n", params->event, params->command_exec_callback_type, params->pfn_notify, params->user_data);
     FIXME( "not yet implemented\n" );
-    return CL_INVALID_OPERATION;
+    return CL_SUCCESS;
 }
 
 NTSTATUS wrap_clSetMemObjectDestructorCallback( void *args )
-- 
2.48.1

